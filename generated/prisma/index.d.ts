
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model active_storage_attachments
 * 
 */
export type active_storage_attachments = $Result.DefaultSelection<Prisma.$active_storage_attachmentsPayload>
/**
 * Model active_storage_blobs
 * 
 */
export type active_storage_blobs = $Result.DefaultSelection<Prisma.$active_storage_blobsPayload>
/**
 * Model active_storage_variant_records
 * 
 */
export type active_storage_variant_records = $Result.DefaultSelection<Prisma.$active_storage_variant_recordsPayload>
/**
 * Model addresses
 * 
 */
export type addresses = $Result.DefaultSelection<Prisma.$addressesPayload>
/**
 * Model ar_internal_metadata
 * 
 */
export type ar_internal_metadata = $Result.DefaultSelection<Prisma.$ar_internal_metadataPayload>
/**
 * Model balances
 * 
 */
export type balances = $Result.DefaultSelection<Prisma.$balancesPayload>
/**
 * Model budget_categories
 * 
 */
export type budget_categories = $Result.DefaultSelection<Prisma.$budget_categoriesPayload>
/**
 * Model budgets
 * 
 */
export type budgets = $Result.DefaultSelection<Prisma.$budgetsPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model chats
 * 
 */
export type chats = $Result.DefaultSelection<Prisma.$chatsPayload>
/**
 * Model credit_cards
 * 
 */
export type credit_cards = $Result.DefaultSelection<Prisma.$credit_cardsPayload>
/**
 * Model cryptos
 * 
 */
export type cryptos = $Result.DefaultSelection<Prisma.$cryptosPayload>
/**
 * Model data_enrichments
 * 
 */
export type data_enrichments = $Result.DefaultSelection<Prisma.$data_enrichmentsPayload>
/**
 * Model depositories
 * 
 */
export type depositories = $Result.DefaultSelection<Prisma.$depositoriesPayload>
/**
 * Model entries
 * 
 */
export type entries = $Result.DefaultSelection<Prisma.$entriesPayload>
/**
 * Model exchange_rates
 * 
 */
export type exchange_rates = $Result.DefaultSelection<Prisma.$exchange_ratesPayload>
/**
 * Model families
 * 
 */
export type families = $Result.DefaultSelection<Prisma.$familiesPayload>
/**
 * Model holdings
 * 
 */
export type holdings = $Result.DefaultSelection<Prisma.$holdingsPayload>
/**
 * Model impersonation_session_logs
 * 
 */
export type impersonation_session_logs = $Result.DefaultSelection<Prisma.$impersonation_session_logsPayload>
/**
 * Model impersonation_sessions
 * 
 */
export type impersonation_sessions = $Result.DefaultSelection<Prisma.$impersonation_sessionsPayload>
/**
 * Model import_mappings
 * 
 */
export type import_mappings = $Result.DefaultSelection<Prisma.$import_mappingsPayload>
/**
 * Model import_rows
 * 
 */
export type import_rows = $Result.DefaultSelection<Prisma.$import_rowsPayload>
/**
 * Model imports
 * 
 */
export type imports = $Result.DefaultSelection<Prisma.$importsPayload>
/**
 * Model investments
 * 
 */
export type investments = $Result.DefaultSelection<Prisma.$investmentsPayload>
/**
 * Model invitations
 * 
 */
export type invitations = $Result.DefaultSelection<Prisma.$invitationsPayload>
/**
 * Model invite_codes
 * 
 */
export type invite_codes = $Result.DefaultSelection<Prisma.$invite_codesPayload>
/**
 * Model loans
 * 
 */
export type loans = $Result.DefaultSelection<Prisma.$loansPayload>
/**
 * Model merchants
 * 
 */
export type merchants = $Result.DefaultSelection<Prisma.$merchantsPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model other_assets
 * 
 */
export type other_assets = $Result.DefaultSelection<Prisma.$other_assetsPayload>
/**
 * Model other_liabilities
 * 
 */
export type other_liabilities = $Result.DefaultSelection<Prisma.$other_liabilitiesPayload>
/**
 * Model plaid_accounts
 * 
 */
export type plaid_accounts = $Result.DefaultSelection<Prisma.$plaid_accountsPayload>
/**
 * Model plaid_items
 * 
 */
export type plaid_items = $Result.DefaultSelection<Prisma.$plaid_itemsPayload>
/**
 * Model properties
 * 
 */
export type properties = $Result.DefaultSelection<Prisma.$propertiesPayload>
/**
 * Model rejected_transfers
 * 
 */
export type rejected_transfers = $Result.DefaultSelection<Prisma.$rejected_transfersPayload>
/**
 * Model rule_actions
 * 
 */
export type rule_actions = $Result.DefaultSelection<Prisma.$rule_actionsPayload>
/**
 * Model rule_conditions
 * 
 */
export type rule_conditions = $Result.DefaultSelection<Prisma.$rule_conditionsPayload>
/**
 * Model rules
 * 
 */
export type rules = $Result.DefaultSelection<Prisma.$rulesPayload>
/**
 * Model schema_migrations
 * 
 */
export type schema_migrations = $Result.DefaultSelection<Prisma.$schema_migrationsPayload>
/**
 * Model securities
 * 
 */
export type securities = $Result.DefaultSelection<Prisma.$securitiesPayload>
/**
 * Model security_prices
 * 
 */
export type security_prices = $Result.DefaultSelection<Prisma.$security_pricesPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model settings
 * 
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>
/**
 * Model stock_exchanges
 * 
 */
export type stock_exchanges = $Result.DefaultSelection<Prisma.$stock_exchangesPayload>
/**
 * Model syncs
 * 
 */
export type syncs = $Result.DefaultSelection<Prisma.$syncsPayload>
/**
 * Model taggings
 * 
 */
export type taggings = $Result.DefaultSelection<Prisma.$taggingsPayload>
/**
 * Model tags
 * 
 */
export type tags = $Result.DefaultSelection<Prisma.$tagsPayload>
/**
 * Model tool_calls
 * 
 */
export type tool_calls = $Result.DefaultSelection<Prisma.$tool_callsPayload>
/**
 * Model trades
 * 
 */
export type trades = $Result.DefaultSelection<Prisma.$tradesPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model transfers
 * 
 */
export type transfers = $Result.DefaultSelection<Prisma.$transfersPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model valuations
 * 
 */
export type valuations = $Result.DefaultSelection<Prisma.$valuationsPayload>
/**
 * Model vehicles
 * 
 */
export type vehicles = $Result.DefaultSelection<Prisma.$vehiclesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const account_status: {
  ok: 'ok',
  syncing: 'syncing',
  error: 'error'
};

export type account_status = (typeof account_status)[keyof typeof account_status]

}

export type account_status = $Enums.account_status

export const account_status: typeof $Enums.account_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.active_storage_attachments`: Exposes CRUD operations for the **active_storage_attachments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Active_storage_attachments
    * const active_storage_attachments = await prisma.active_storage_attachments.findMany()
    * ```
    */
  get active_storage_attachments(): Prisma.active_storage_attachmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.active_storage_blobs`: Exposes CRUD operations for the **active_storage_blobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Active_storage_blobs
    * const active_storage_blobs = await prisma.active_storage_blobs.findMany()
    * ```
    */
  get active_storage_blobs(): Prisma.active_storage_blobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.active_storage_variant_records`: Exposes CRUD operations for the **active_storage_variant_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Active_storage_variant_records
    * const active_storage_variant_records = await prisma.active_storage_variant_records.findMany()
    * ```
    */
  get active_storage_variant_records(): Prisma.active_storage_variant_recordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addresses`: Exposes CRUD operations for the **addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.addresses.findMany()
    * ```
    */
  get addresses(): Prisma.addressesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ar_internal_metadata`: Exposes CRUD operations for the **ar_internal_metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ar_internal_metadata
    * const ar_internal_metadata = await prisma.ar_internal_metadata.findMany()
    * ```
    */
  get ar_internal_metadata(): Prisma.ar_internal_metadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.balances`: Exposes CRUD operations for the **balances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Balances
    * const balances = await prisma.balances.findMany()
    * ```
    */
  get balances(): Prisma.balancesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget_categories`: Exposes CRUD operations for the **budget_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budget_categories
    * const budget_categories = await prisma.budget_categories.findMany()
    * ```
    */
  get budget_categories(): Prisma.budget_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budgets`: Exposes CRUD operations for the **budgets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budgets.findMany()
    * ```
    */
  get budgets(): Prisma.budgetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chats`: Exposes CRUD operations for the **chats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chats.findMany()
    * ```
    */
  get chats(): Prisma.chatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credit_cards`: Exposes CRUD operations for the **credit_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credit_cards
    * const credit_cards = await prisma.credit_cards.findMany()
    * ```
    */
  get credit_cards(): Prisma.credit_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cryptos`: Exposes CRUD operations for the **cryptos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cryptos
    * const cryptos = await prisma.cryptos.findMany()
    * ```
    */
  get cryptos(): Prisma.cryptosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.data_enrichments`: Exposes CRUD operations for the **data_enrichments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Data_enrichments
    * const data_enrichments = await prisma.data_enrichments.findMany()
    * ```
    */
  get data_enrichments(): Prisma.data_enrichmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.depositories`: Exposes CRUD operations for the **depositories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Depositories
    * const depositories = await prisma.depositories.findMany()
    * ```
    */
  get depositories(): Prisma.depositoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entries`: Exposes CRUD operations for the **entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entries
    * const entries = await prisma.entries.findMany()
    * ```
    */
  get entries(): Prisma.entriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchange_rates`: Exposes CRUD operations for the **exchange_rates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchange_rates
    * const exchange_rates = await prisma.exchange_rates.findMany()
    * ```
    */
  get exchange_rates(): Prisma.exchange_ratesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.families`: Exposes CRUD operations for the **families** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Families
    * const families = await prisma.families.findMany()
    * ```
    */
  get families(): Prisma.familiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holdings`: Exposes CRUD operations for the **holdings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holdings
    * const holdings = await prisma.holdings.findMany()
    * ```
    */
  get holdings(): Prisma.holdingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impersonation_session_logs`: Exposes CRUD operations for the **impersonation_session_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Impersonation_session_logs
    * const impersonation_session_logs = await prisma.impersonation_session_logs.findMany()
    * ```
    */
  get impersonation_session_logs(): Prisma.impersonation_session_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impersonation_sessions`: Exposes CRUD operations for the **impersonation_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Impersonation_sessions
    * const impersonation_sessions = await prisma.impersonation_sessions.findMany()
    * ```
    */
  get impersonation_sessions(): Prisma.impersonation_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.import_mappings`: Exposes CRUD operations for the **import_mappings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Import_mappings
    * const import_mappings = await prisma.import_mappings.findMany()
    * ```
    */
  get import_mappings(): Prisma.import_mappingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.import_rows`: Exposes CRUD operations for the **import_rows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Import_rows
    * const import_rows = await prisma.import_rows.findMany()
    * ```
    */
  get import_rows(): Prisma.import_rowsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.imports`: Exposes CRUD operations for the **imports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Imports
    * const imports = await prisma.imports.findMany()
    * ```
    */
  get imports(): Prisma.importsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investments`: Exposes CRUD operations for the **investments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investments
    * const investments = await prisma.investments.findMany()
    * ```
    */
  get investments(): Prisma.investmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitations`: Exposes CRUD operations for the **invitations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitations.findMany()
    * ```
    */
  get invitations(): Prisma.invitationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invite_codes`: Exposes CRUD operations for the **invite_codes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invite_codes
    * const invite_codes = await prisma.invite_codes.findMany()
    * ```
    */
  get invite_codes(): Prisma.invite_codesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loans`: Exposes CRUD operations for the **loans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Loans
    * const loans = await prisma.loans.findMany()
    * ```
    */
  get loans(): Prisma.loansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.merchants`: Exposes CRUD operations for the **merchants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Merchants
    * const merchants = await prisma.merchants.findMany()
    * ```
    */
  get merchants(): Prisma.merchantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.other_assets`: Exposes CRUD operations for the **other_assets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Other_assets
    * const other_assets = await prisma.other_assets.findMany()
    * ```
    */
  get other_assets(): Prisma.other_assetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.other_liabilities`: Exposes CRUD operations for the **other_liabilities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Other_liabilities
    * const other_liabilities = await prisma.other_liabilities.findMany()
    * ```
    */
  get other_liabilities(): Prisma.other_liabilitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plaid_accounts`: Exposes CRUD operations for the **plaid_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plaid_accounts
    * const plaid_accounts = await prisma.plaid_accounts.findMany()
    * ```
    */
  get plaid_accounts(): Prisma.plaid_accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plaid_items`: Exposes CRUD operations for the **plaid_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plaid_items
    * const plaid_items = await prisma.plaid_items.findMany()
    * ```
    */
  get plaid_items(): Prisma.plaid_itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.properties`: Exposes CRUD operations for the **properties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.properties.findMany()
    * ```
    */
  get properties(): Prisma.propertiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rejected_transfers`: Exposes CRUD operations for the **rejected_transfers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rejected_transfers
    * const rejected_transfers = await prisma.rejected_transfers.findMany()
    * ```
    */
  get rejected_transfers(): Prisma.rejected_transfersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rule_actions`: Exposes CRUD operations for the **rule_actions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rule_actions
    * const rule_actions = await prisma.rule_actions.findMany()
    * ```
    */
  get rule_actions(): Prisma.rule_actionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rule_conditions`: Exposes CRUD operations for the **rule_conditions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rule_conditions
    * const rule_conditions = await prisma.rule_conditions.findMany()
    * ```
    */
  get rule_conditions(): Prisma.rule_conditionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rules`: Exposes CRUD operations for the **rules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rules
    * const rules = await prisma.rules.findMany()
    * ```
    */
  get rules(): Prisma.rulesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schema_migrations`: Exposes CRUD operations for the **schema_migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schema_migrations
    * const schema_migrations = await prisma.schema_migrations.findMany()
    * ```
    */
  get schema_migrations(): Prisma.schema_migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securities`: Exposes CRUD operations for the **securities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Securities
    * const securities = await prisma.securities.findMany()
    * ```
    */
  get securities(): Prisma.securitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.security_prices`: Exposes CRUD operations for the **security_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Security_prices
    * const security_prices = await prisma.security_prices.findMany()
    * ```
    */
  get security_prices(): Prisma.security_pricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock_exchanges`: Exposes CRUD operations for the **stock_exchanges** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stock_exchanges
    * const stock_exchanges = await prisma.stock_exchanges.findMany()
    * ```
    */
  get stock_exchanges(): Prisma.stock_exchangesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncs`: Exposes CRUD operations for the **syncs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syncs
    * const syncs = await prisma.syncs.findMany()
    * ```
    */
  get syncs(): Prisma.syncsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taggings`: Exposes CRUD operations for the **taggings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taggings
    * const taggings = await prisma.taggings.findMany()
    * ```
    */
  get taggings(): Prisma.taggingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tool_calls`: Exposes CRUD operations for the **tool_calls** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tool_calls
    * const tool_calls = await prisma.tool_calls.findMany()
    * ```
    */
  get tool_calls(): Prisma.tool_callsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trades`: Exposes CRUD operations for the **trades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trades
    * const trades = await prisma.trades.findMany()
    * ```
    */
  get trades(): Prisma.tradesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transfers`: Exposes CRUD operations for the **transfers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transfers
    * const transfers = await prisma.transfers.findMany()
    * ```
    */
  get transfers(): Prisma.transfersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.valuations`: Exposes CRUD operations for the **valuations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Valuations
    * const valuations = await prisma.valuations.findMany()
    * ```
    */
  get valuations(): Prisma.valuationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicles`: Exposes CRUD operations for the **vehicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicles.findMany()
    * ```
    */
  get vehicles(): Prisma.vehiclesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accounts: 'accounts',
    active_storage_attachments: 'active_storage_attachments',
    active_storage_blobs: 'active_storage_blobs',
    active_storage_variant_records: 'active_storage_variant_records',
    addresses: 'addresses',
    ar_internal_metadata: 'ar_internal_metadata',
    balances: 'balances',
    budget_categories: 'budget_categories',
    budgets: 'budgets',
    categories: 'categories',
    chats: 'chats',
    credit_cards: 'credit_cards',
    cryptos: 'cryptos',
    data_enrichments: 'data_enrichments',
    depositories: 'depositories',
    entries: 'entries',
    exchange_rates: 'exchange_rates',
    families: 'families',
    holdings: 'holdings',
    impersonation_session_logs: 'impersonation_session_logs',
    impersonation_sessions: 'impersonation_sessions',
    import_mappings: 'import_mappings',
    import_rows: 'import_rows',
    imports: 'imports',
    investments: 'investments',
    invitations: 'invitations',
    invite_codes: 'invite_codes',
    loans: 'loans',
    merchants: 'merchants',
    messages: 'messages',
    other_assets: 'other_assets',
    other_liabilities: 'other_liabilities',
    plaid_accounts: 'plaid_accounts',
    plaid_items: 'plaid_items',
    properties: 'properties',
    rejected_transfers: 'rejected_transfers',
    rule_actions: 'rule_actions',
    rule_conditions: 'rule_conditions',
    rules: 'rules',
    schema_migrations: 'schema_migrations',
    securities: 'securities',
    security_prices: 'security_prices',
    sessions: 'sessions',
    settings: 'settings',
    stock_exchanges: 'stock_exchanges',
    syncs: 'syncs',
    taggings: 'taggings',
    tags: 'tags',
    tool_calls: 'tool_calls',
    trades: 'trades',
    transactions: 'transactions',
    transfers: 'transfers',
    users: 'users',
    valuations: 'valuations',
    vehicles: 'vehicles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "accounts" | "active_storage_attachments" | "active_storage_blobs" | "active_storage_variant_records" | "addresses" | "ar_internal_metadata" | "balances" | "budget_categories" | "budgets" | "categories" | "chats" | "credit_cards" | "cryptos" | "data_enrichments" | "depositories" | "entries" | "exchange_rates" | "families" | "holdings" | "impersonation_session_logs" | "impersonation_sessions" | "import_mappings" | "import_rows" | "imports" | "investments" | "invitations" | "invite_codes" | "loans" | "merchants" | "messages" | "other_assets" | "other_liabilities" | "plaid_accounts" | "plaid_items" | "properties" | "rejected_transfers" | "rule_actions" | "rule_conditions" | "rules" | "schema_migrations" | "securities" | "security_prices" | "sessions" | "settings" | "stock_exchanges" | "syncs" | "taggings" | "tags" | "tool_calls" | "trades" | "transactions" | "transfers" | "users" | "valuations" | "vehicles"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      active_storage_attachments: {
        payload: Prisma.$active_storage_attachmentsPayload<ExtArgs>
        fields: Prisma.active_storage_attachmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.active_storage_attachmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.active_storage_attachmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          findFirst: {
            args: Prisma.active_storage_attachmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.active_storage_attachmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          findMany: {
            args: Prisma.active_storage_attachmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>[]
          }
          create: {
            args: Prisma.active_storage_attachmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          createMany: {
            args: Prisma.active_storage_attachmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.active_storage_attachmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>[]
          }
          delete: {
            args: Prisma.active_storage_attachmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          update: {
            args: Prisma.active_storage_attachmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          deleteMany: {
            args: Prisma.active_storage_attachmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.active_storage_attachmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.active_storage_attachmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>[]
          }
          upsert: {
            args: Prisma.active_storage_attachmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_attachmentsPayload>
          }
          aggregate: {
            args: Prisma.Active_storage_attachmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActive_storage_attachments>
          }
          groupBy: {
            args: Prisma.active_storage_attachmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_attachmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.active_storage_attachmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_attachmentsCountAggregateOutputType> | number
          }
        }
      }
      active_storage_blobs: {
        payload: Prisma.$active_storage_blobsPayload<ExtArgs>
        fields: Prisma.active_storage_blobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.active_storage_blobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.active_storage_blobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          findFirst: {
            args: Prisma.active_storage_blobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.active_storage_blobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          findMany: {
            args: Prisma.active_storage_blobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>[]
          }
          create: {
            args: Prisma.active_storage_blobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          createMany: {
            args: Prisma.active_storage_blobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.active_storage_blobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>[]
          }
          delete: {
            args: Prisma.active_storage_blobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          update: {
            args: Prisma.active_storage_blobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          deleteMany: {
            args: Prisma.active_storage_blobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.active_storage_blobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.active_storage_blobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>[]
          }
          upsert: {
            args: Prisma.active_storage_blobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_blobsPayload>
          }
          aggregate: {
            args: Prisma.Active_storage_blobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActive_storage_blobs>
          }
          groupBy: {
            args: Prisma.active_storage_blobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_blobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.active_storage_blobsCountArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_blobsCountAggregateOutputType> | number
          }
        }
      }
      active_storage_variant_records: {
        payload: Prisma.$active_storage_variant_recordsPayload<ExtArgs>
        fields: Prisma.active_storage_variant_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.active_storage_variant_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.active_storage_variant_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          findFirst: {
            args: Prisma.active_storage_variant_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.active_storage_variant_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          findMany: {
            args: Prisma.active_storage_variant_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>[]
          }
          create: {
            args: Prisma.active_storage_variant_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          createMany: {
            args: Prisma.active_storage_variant_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.active_storage_variant_recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>[]
          }
          delete: {
            args: Prisma.active_storage_variant_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          update: {
            args: Prisma.active_storage_variant_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          deleteMany: {
            args: Prisma.active_storage_variant_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.active_storage_variant_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.active_storage_variant_recordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>[]
          }
          upsert: {
            args: Prisma.active_storage_variant_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$active_storage_variant_recordsPayload>
          }
          aggregate: {
            args: Prisma.Active_storage_variant_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActive_storage_variant_records>
          }
          groupBy: {
            args: Prisma.active_storage_variant_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_variant_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.active_storage_variant_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Active_storage_variant_recordsCountAggregateOutputType> | number
          }
        }
      }
      addresses: {
        payload: Prisma.$addressesPayload<ExtArgs>
        fields: Prisma.addressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.addressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.addressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          findFirst: {
            args: Prisma.addressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.addressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          findMany: {
            args: Prisma.addressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>[]
          }
          create: {
            args: Prisma.addressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          createMany: {
            args: Prisma.addressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.addressesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>[]
          }
          delete: {
            args: Prisma.addressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          update: {
            args: Prisma.addressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          deleteMany: {
            args: Prisma.addressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.addressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.addressesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>[]
          }
          upsert: {
            args: Prisma.addressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$addressesPayload>
          }
          aggregate: {
            args: Prisma.AddressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddresses>
          }
          groupBy: {
            args: Prisma.addressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.addressesCountArgs<ExtArgs>
            result: $Utils.Optional<AddressesCountAggregateOutputType> | number
          }
        }
      }
      ar_internal_metadata: {
        payload: Prisma.$ar_internal_metadataPayload<ExtArgs>
        fields: Prisma.ar_internal_metadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ar_internal_metadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ar_internal_metadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          findFirst: {
            args: Prisma.ar_internal_metadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ar_internal_metadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          findMany: {
            args: Prisma.ar_internal_metadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>[]
          }
          create: {
            args: Prisma.ar_internal_metadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          createMany: {
            args: Prisma.ar_internal_metadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ar_internal_metadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>[]
          }
          delete: {
            args: Prisma.ar_internal_metadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          update: {
            args: Prisma.ar_internal_metadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          deleteMany: {
            args: Prisma.ar_internal_metadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ar_internal_metadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ar_internal_metadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>[]
          }
          upsert: {
            args: Prisma.ar_internal_metadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ar_internal_metadataPayload>
          }
          aggregate: {
            args: Prisma.Ar_internal_metadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAr_internal_metadata>
          }
          groupBy: {
            args: Prisma.ar_internal_metadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ar_internal_metadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ar_internal_metadataCountArgs<ExtArgs>
            result: $Utils.Optional<Ar_internal_metadataCountAggregateOutputType> | number
          }
        }
      }
      balances: {
        payload: Prisma.$balancesPayload<ExtArgs>
        fields: Prisma.balancesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.balancesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.balancesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          findFirst: {
            args: Prisma.balancesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.balancesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          findMany: {
            args: Prisma.balancesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>[]
          }
          create: {
            args: Prisma.balancesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          createMany: {
            args: Prisma.balancesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.balancesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>[]
          }
          delete: {
            args: Prisma.balancesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          update: {
            args: Prisma.balancesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          deleteMany: {
            args: Prisma.balancesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.balancesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.balancesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>[]
          }
          upsert: {
            args: Prisma.balancesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$balancesPayload>
          }
          aggregate: {
            args: Prisma.BalancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBalances>
          }
          groupBy: {
            args: Prisma.balancesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BalancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.balancesCountArgs<ExtArgs>
            result: $Utils.Optional<BalancesCountAggregateOutputType> | number
          }
        }
      }
      budget_categories: {
        payload: Prisma.$budget_categoriesPayload<ExtArgs>
        fields: Prisma.budget_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budget_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budget_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          findFirst: {
            args: Prisma.budget_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budget_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          findMany: {
            args: Prisma.budget_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>[]
          }
          create: {
            args: Prisma.budget_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          createMany: {
            args: Prisma.budget_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.budget_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>[]
          }
          delete: {
            args: Prisma.budget_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          update: {
            args: Prisma.budget_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.budget_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budget_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.budget_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.budget_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budget_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Budget_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget_categories>
          }
          groupBy: {
            args: Prisma.budget_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Budget_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.budget_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Budget_categoriesCountAggregateOutputType> | number
          }
        }
      }
      budgets: {
        payload: Prisma.$budgetsPayload<ExtArgs>
        fields: Prisma.budgetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.budgetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.budgetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          findFirst: {
            args: Prisma.budgetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.budgetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          findMany: {
            args: Prisma.budgetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>[]
          }
          create: {
            args: Prisma.budgetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          createMany: {
            args: Prisma.budgetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.budgetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>[]
          }
          delete: {
            args: Prisma.budgetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          update: {
            args: Prisma.budgetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          deleteMany: {
            args: Prisma.budgetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.budgetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.budgetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>[]
          }
          upsert: {
            args: Prisma.budgetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$budgetsPayload>
          }
          aggregate: {
            args: Prisma.BudgetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudgets>
          }
          groupBy: {
            args: Prisma.budgetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.budgetsCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetsCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      chats: {
        payload: Prisma.$chatsPayload<ExtArgs>
        fields: Prisma.chatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findFirst: {
            args: Prisma.chatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findMany: {
            args: Prisma.chatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          create: {
            args: Prisma.chatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          createMany: {
            args: Prisma.chatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          delete: {
            args: Prisma.chatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          update: {
            args: Prisma.chatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          deleteMany: {
            args: Prisma.chatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          upsert: {
            args: Prisma.chatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          aggregate: {
            args: Prisma.ChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChats>
          }
          groupBy: {
            args: Prisma.chatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatsCountAggregateOutputType> | number
          }
        }
      }
      credit_cards: {
        payload: Prisma.$credit_cardsPayload<ExtArgs>
        fields: Prisma.credit_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.credit_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.credit_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          findFirst: {
            args: Prisma.credit_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.credit_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          findMany: {
            args: Prisma.credit_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>[]
          }
          create: {
            args: Prisma.credit_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          createMany: {
            args: Prisma.credit_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.credit_cardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>[]
          }
          delete: {
            args: Prisma.credit_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          update: {
            args: Prisma.credit_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          deleteMany: {
            args: Prisma.credit_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.credit_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.credit_cardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>[]
          }
          upsert: {
            args: Prisma.credit_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$credit_cardsPayload>
          }
          aggregate: {
            args: Prisma.Credit_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredit_cards>
          }
          groupBy: {
            args: Prisma.credit_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Credit_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.credit_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Credit_cardsCountAggregateOutputType> | number
          }
        }
      }
      cryptos: {
        payload: Prisma.$cryptosPayload<ExtArgs>
        fields: Prisma.cryptosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cryptosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cryptosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          findFirst: {
            args: Prisma.cryptosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cryptosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          findMany: {
            args: Prisma.cryptosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>[]
          }
          create: {
            args: Prisma.cryptosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          createMany: {
            args: Prisma.cryptosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cryptosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>[]
          }
          delete: {
            args: Prisma.cryptosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          update: {
            args: Prisma.cryptosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          deleteMany: {
            args: Prisma.cryptosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cryptosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cryptosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>[]
          }
          upsert: {
            args: Prisma.cryptosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cryptosPayload>
          }
          aggregate: {
            args: Prisma.CryptosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCryptos>
          }
          groupBy: {
            args: Prisma.cryptosGroupByArgs<ExtArgs>
            result: $Utils.Optional<CryptosGroupByOutputType>[]
          }
          count: {
            args: Prisma.cryptosCountArgs<ExtArgs>
            result: $Utils.Optional<CryptosCountAggregateOutputType> | number
          }
        }
      }
      data_enrichments: {
        payload: Prisma.$data_enrichmentsPayload<ExtArgs>
        fields: Prisma.data_enrichmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.data_enrichmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.data_enrichmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          findFirst: {
            args: Prisma.data_enrichmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.data_enrichmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          findMany: {
            args: Prisma.data_enrichmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>[]
          }
          create: {
            args: Prisma.data_enrichmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          createMany: {
            args: Prisma.data_enrichmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.data_enrichmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>[]
          }
          delete: {
            args: Prisma.data_enrichmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          update: {
            args: Prisma.data_enrichmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          deleteMany: {
            args: Prisma.data_enrichmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.data_enrichmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.data_enrichmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>[]
          }
          upsert: {
            args: Prisma.data_enrichmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$data_enrichmentsPayload>
          }
          aggregate: {
            args: Prisma.Data_enrichmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateData_enrichments>
          }
          groupBy: {
            args: Prisma.data_enrichmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Data_enrichmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.data_enrichmentsCountArgs<ExtArgs>
            result: $Utils.Optional<Data_enrichmentsCountAggregateOutputType> | number
          }
        }
      }
      depositories: {
        payload: Prisma.$depositoriesPayload<ExtArgs>
        fields: Prisma.depositoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.depositoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.depositoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          findFirst: {
            args: Prisma.depositoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.depositoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          findMany: {
            args: Prisma.depositoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>[]
          }
          create: {
            args: Prisma.depositoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          createMany: {
            args: Prisma.depositoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.depositoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>[]
          }
          delete: {
            args: Prisma.depositoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          update: {
            args: Prisma.depositoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          deleteMany: {
            args: Prisma.depositoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.depositoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.depositoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>[]
          }
          upsert: {
            args: Prisma.depositoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$depositoriesPayload>
          }
          aggregate: {
            args: Prisma.DepositoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepositories>
          }
          groupBy: {
            args: Prisma.depositoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.depositoriesCountArgs<ExtArgs>
            result: $Utils.Optional<DepositoriesCountAggregateOutputType> | number
          }
        }
      }
      entries: {
        payload: Prisma.$entriesPayload<ExtArgs>
        fields: Prisma.entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          findFirst: {
            args: Prisma.entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          findMany: {
            args: Prisma.entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>[]
          }
          create: {
            args: Prisma.entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          createMany: {
            args: Prisma.entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.entriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>[]
          }
          delete: {
            args: Prisma.entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          update: {
            args: Prisma.entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          deleteMany: {
            args: Prisma.entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.entriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>[]
          }
          upsert: {
            args: Prisma.entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entriesPayload>
          }
          aggregate: {
            args: Prisma.EntriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntries>
          }
          groupBy: {
            args: Prisma.entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entriesCountArgs<ExtArgs>
            result: $Utils.Optional<EntriesCountAggregateOutputType> | number
          }
        }
      }
      exchange_rates: {
        payload: Prisma.$exchange_ratesPayload<ExtArgs>
        fields: Prisma.exchange_ratesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exchange_ratesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exchange_ratesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          findFirst: {
            args: Prisma.exchange_ratesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exchange_ratesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          findMany: {
            args: Prisma.exchange_ratesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>[]
          }
          create: {
            args: Prisma.exchange_ratesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          createMany: {
            args: Prisma.exchange_ratesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.exchange_ratesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>[]
          }
          delete: {
            args: Prisma.exchange_ratesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          update: {
            args: Prisma.exchange_ratesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          deleteMany: {
            args: Prisma.exchange_ratesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exchange_ratesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.exchange_ratesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>[]
          }
          upsert: {
            args: Prisma.exchange_ratesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchange_ratesPayload>
          }
          aggregate: {
            args: Prisma.Exchange_ratesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchange_rates>
          }
          groupBy: {
            args: Prisma.exchange_ratesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Exchange_ratesGroupByOutputType>[]
          }
          count: {
            args: Prisma.exchange_ratesCountArgs<ExtArgs>
            result: $Utils.Optional<Exchange_ratesCountAggregateOutputType> | number
          }
        }
      }
      families: {
        payload: Prisma.$familiesPayload<ExtArgs>
        fields: Prisma.familiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.familiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.familiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          findFirst: {
            args: Prisma.familiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.familiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          findMany: {
            args: Prisma.familiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>[]
          }
          create: {
            args: Prisma.familiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          createMany: {
            args: Prisma.familiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.familiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>[]
          }
          delete: {
            args: Prisma.familiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          update: {
            args: Prisma.familiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          deleteMany: {
            args: Prisma.familiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.familiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.familiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>[]
          }
          upsert: {
            args: Prisma.familiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$familiesPayload>
          }
          aggregate: {
            args: Prisma.FamiliesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilies>
          }
          groupBy: {
            args: Prisma.familiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamiliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.familiesCountArgs<ExtArgs>
            result: $Utils.Optional<FamiliesCountAggregateOutputType> | number
          }
        }
      }
      holdings: {
        payload: Prisma.$holdingsPayload<ExtArgs>
        fields: Prisma.holdingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.holdingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.holdingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          findFirst: {
            args: Prisma.holdingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.holdingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          findMany: {
            args: Prisma.holdingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>[]
          }
          create: {
            args: Prisma.holdingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          createMany: {
            args: Prisma.holdingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.holdingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>[]
          }
          delete: {
            args: Prisma.holdingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          update: {
            args: Prisma.holdingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          deleteMany: {
            args: Prisma.holdingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.holdingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.holdingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>[]
          }
          upsert: {
            args: Prisma.holdingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holdingsPayload>
          }
          aggregate: {
            args: Prisma.HoldingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoldings>
          }
          groupBy: {
            args: Prisma.holdingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HoldingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.holdingsCountArgs<ExtArgs>
            result: $Utils.Optional<HoldingsCountAggregateOutputType> | number
          }
        }
      }
      impersonation_session_logs: {
        payload: Prisma.$impersonation_session_logsPayload<ExtArgs>
        fields: Prisma.impersonation_session_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.impersonation_session_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.impersonation_session_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          findFirst: {
            args: Prisma.impersonation_session_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.impersonation_session_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          findMany: {
            args: Prisma.impersonation_session_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>[]
          }
          create: {
            args: Prisma.impersonation_session_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          createMany: {
            args: Prisma.impersonation_session_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.impersonation_session_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>[]
          }
          delete: {
            args: Prisma.impersonation_session_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          update: {
            args: Prisma.impersonation_session_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          deleteMany: {
            args: Prisma.impersonation_session_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.impersonation_session_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.impersonation_session_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>[]
          }
          upsert: {
            args: Prisma.impersonation_session_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_session_logsPayload>
          }
          aggregate: {
            args: Prisma.Impersonation_session_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpersonation_session_logs>
          }
          groupBy: {
            args: Prisma.impersonation_session_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Impersonation_session_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.impersonation_session_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Impersonation_session_logsCountAggregateOutputType> | number
          }
        }
      }
      impersonation_sessions: {
        payload: Prisma.$impersonation_sessionsPayload<ExtArgs>
        fields: Prisma.impersonation_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.impersonation_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.impersonation_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          findFirst: {
            args: Prisma.impersonation_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.impersonation_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          findMany: {
            args: Prisma.impersonation_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>[]
          }
          create: {
            args: Prisma.impersonation_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          createMany: {
            args: Prisma.impersonation_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.impersonation_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>[]
          }
          delete: {
            args: Prisma.impersonation_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          update: {
            args: Prisma.impersonation_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.impersonation_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.impersonation_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.impersonation_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.impersonation_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$impersonation_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Impersonation_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpersonation_sessions>
          }
          groupBy: {
            args: Prisma.impersonation_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Impersonation_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.impersonation_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Impersonation_sessionsCountAggregateOutputType> | number
          }
        }
      }
      import_mappings: {
        payload: Prisma.$import_mappingsPayload<ExtArgs>
        fields: Prisma.import_mappingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.import_mappingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.import_mappingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          findFirst: {
            args: Prisma.import_mappingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.import_mappingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          findMany: {
            args: Prisma.import_mappingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>[]
          }
          create: {
            args: Prisma.import_mappingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          createMany: {
            args: Prisma.import_mappingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.import_mappingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>[]
          }
          delete: {
            args: Prisma.import_mappingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          update: {
            args: Prisma.import_mappingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          deleteMany: {
            args: Prisma.import_mappingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.import_mappingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.import_mappingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>[]
          }
          upsert: {
            args: Prisma.import_mappingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_mappingsPayload>
          }
          aggregate: {
            args: Prisma.Import_mappingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImport_mappings>
          }
          groupBy: {
            args: Prisma.import_mappingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Import_mappingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.import_mappingsCountArgs<ExtArgs>
            result: $Utils.Optional<Import_mappingsCountAggregateOutputType> | number
          }
        }
      }
      import_rows: {
        payload: Prisma.$import_rowsPayload<ExtArgs>
        fields: Prisma.import_rowsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.import_rowsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.import_rowsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          findFirst: {
            args: Prisma.import_rowsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.import_rowsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          findMany: {
            args: Prisma.import_rowsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>[]
          }
          create: {
            args: Prisma.import_rowsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          createMany: {
            args: Prisma.import_rowsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.import_rowsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>[]
          }
          delete: {
            args: Prisma.import_rowsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          update: {
            args: Prisma.import_rowsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          deleteMany: {
            args: Prisma.import_rowsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.import_rowsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.import_rowsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>[]
          }
          upsert: {
            args: Prisma.import_rowsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$import_rowsPayload>
          }
          aggregate: {
            args: Prisma.Import_rowsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImport_rows>
          }
          groupBy: {
            args: Prisma.import_rowsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Import_rowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.import_rowsCountArgs<ExtArgs>
            result: $Utils.Optional<Import_rowsCountAggregateOutputType> | number
          }
        }
      }
      imports: {
        payload: Prisma.$importsPayload<ExtArgs>
        fields: Prisma.importsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.importsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.importsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          findFirst: {
            args: Prisma.importsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.importsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          findMany: {
            args: Prisma.importsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>[]
          }
          create: {
            args: Prisma.importsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          createMany: {
            args: Prisma.importsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.importsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>[]
          }
          delete: {
            args: Prisma.importsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          update: {
            args: Prisma.importsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          deleteMany: {
            args: Prisma.importsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.importsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.importsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>[]
          }
          upsert: {
            args: Prisma.importsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$importsPayload>
          }
          aggregate: {
            args: Prisma.ImportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImports>
          }
          groupBy: {
            args: Prisma.importsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.importsCountArgs<ExtArgs>
            result: $Utils.Optional<ImportsCountAggregateOutputType> | number
          }
        }
      }
      investments: {
        payload: Prisma.$investmentsPayload<ExtArgs>
        fields: Prisma.investmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          findFirst: {
            args: Prisma.investmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          findMany: {
            args: Prisma.investmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>[]
          }
          create: {
            args: Prisma.investmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          createMany: {
            args: Prisma.investmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.investmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>[]
          }
          delete: {
            args: Prisma.investmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          update: {
            args: Prisma.investmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          deleteMany: {
            args: Prisma.investmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.investmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>[]
          }
          upsert: {
            args: Prisma.investmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investmentsPayload>
          }
          aggregate: {
            args: Prisma.InvestmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestments>
          }
          groupBy: {
            args: Prisma.investmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.investmentsCountArgs<ExtArgs>
            result: $Utils.Optional<InvestmentsCountAggregateOutputType> | number
          }
        }
      }
      invitations: {
        payload: Prisma.$invitationsPayload<ExtArgs>
        fields: Prisma.invitationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invitationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invitationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findFirst: {
            args: Prisma.invitationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invitationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          findMany: {
            args: Prisma.invitationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          create: {
            args: Prisma.invitationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          createMany: {
            args: Prisma.invitationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invitationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          delete: {
            args: Prisma.invitationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          update: {
            args: Prisma.invitationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          deleteMany: {
            args: Prisma.invitationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invitationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invitationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>[]
          }
          upsert: {
            args: Prisma.invitationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitationsPayload>
          }
          aggregate: {
            args: Prisma.InvitationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitations>
          }
          groupBy: {
            args: Prisma.invitationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.invitationsCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationsCountAggregateOutputType> | number
          }
        }
      }
      invite_codes: {
        payload: Prisma.$invite_codesPayload<ExtArgs>
        fields: Prisma.invite_codesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invite_codesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invite_codesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          findFirst: {
            args: Prisma.invite_codesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invite_codesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          findMany: {
            args: Prisma.invite_codesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>[]
          }
          create: {
            args: Prisma.invite_codesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          createMany: {
            args: Prisma.invite_codesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.invite_codesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>[]
          }
          delete: {
            args: Prisma.invite_codesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          update: {
            args: Prisma.invite_codesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          deleteMany: {
            args: Prisma.invite_codesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invite_codesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.invite_codesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>[]
          }
          upsert: {
            args: Prisma.invite_codesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invite_codesPayload>
          }
          aggregate: {
            args: Prisma.Invite_codesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite_codes>
          }
          groupBy: {
            args: Prisma.invite_codesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invite_codesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invite_codesCountArgs<ExtArgs>
            result: $Utils.Optional<Invite_codesCountAggregateOutputType> | number
          }
        }
      }
      loans: {
        payload: Prisma.$loansPayload<ExtArgs>
        fields: Prisma.loansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          findFirst: {
            args: Prisma.loansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          findMany: {
            args: Prisma.loansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>[]
          }
          create: {
            args: Prisma.loansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          createMany: {
            args: Prisma.loansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.loansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>[]
          }
          delete: {
            args: Prisma.loansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          update: {
            args: Prisma.loansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          deleteMany: {
            args: Prisma.loansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.loansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>[]
          }
          upsert: {
            args: Prisma.loansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loansPayload>
          }
          aggregate: {
            args: Prisma.LoansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoans>
          }
          groupBy: {
            args: Prisma.loansGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoansGroupByOutputType>[]
          }
          count: {
            args: Prisma.loansCountArgs<ExtArgs>
            result: $Utils.Optional<LoansCountAggregateOutputType> | number
          }
        }
      }
      merchants: {
        payload: Prisma.$merchantsPayload<ExtArgs>
        fields: Prisma.merchantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.merchantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.merchantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          findFirst: {
            args: Prisma.merchantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.merchantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          findMany: {
            args: Prisma.merchantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>[]
          }
          create: {
            args: Prisma.merchantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          createMany: {
            args: Prisma.merchantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.merchantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>[]
          }
          delete: {
            args: Prisma.merchantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          update: {
            args: Prisma.merchantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          deleteMany: {
            args: Prisma.merchantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.merchantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.merchantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>[]
          }
          upsert: {
            args: Prisma.merchantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$merchantsPayload>
          }
          aggregate: {
            args: Prisma.MerchantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMerchants>
          }
          groupBy: {
            args: Prisma.merchantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MerchantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.merchantsCountArgs<ExtArgs>
            result: $Utils.Optional<MerchantsCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      other_assets: {
        payload: Prisma.$other_assetsPayload<ExtArgs>
        fields: Prisma.other_assetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.other_assetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.other_assetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          findFirst: {
            args: Prisma.other_assetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.other_assetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          findMany: {
            args: Prisma.other_assetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>[]
          }
          create: {
            args: Prisma.other_assetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          createMany: {
            args: Prisma.other_assetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.other_assetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>[]
          }
          delete: {
            args: Prisma.other_assetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          update: {
            args: Prisma.other_assetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          deleteMany: {
            args: Prisma.other_assetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.other_assetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.other_assetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>[]
          }
          upsert: {
            args: Prisma.other_assetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_assetsPayload>
          }
          aggregate: {
            args: Prisma.Other_assetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOther_assets>
          }
          groupBy: {
            args: Prisma.other_assetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Other_assetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.other_assetsCountArgs<ExtArgs>
            result: $Utils.Optional<Other_assetsCountAggregateOutputType> | number
          }
        }
      }
      other_liabilities: {
        payload: Prisma.$other_liabilitiesPayload<ExtArgs>
        fields: Prisma.other_liabilitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.other_liabilitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.other_liabilitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          findFirst: {
            args: Prisma.other_liabilitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.other_liabilitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          findMany: {
            args: Prisma.other_liabilitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>[]
          }
          create: {
            args: Prisma.other_liabilitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          createMany: {
            args: Prisma.other_liabilitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.other_liabilitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>[]
          }
          delete: {
            args: Prisma.other_liabilitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          update: {
            args: Prisma.other_liabilitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          deleteMany: {
            args: Prisma.other_liabilitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.other_liabilitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.other_liabilitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>[]
          }
          upsert: {
            args: Prisma.other_liabilitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$other_liabilitiesPayload>
          }
          aggregate: {
            args: Prisma.Other_liabilitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOther_liabilities>
          }
          groupBy: {
            args: Prisma.other_liabilitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Other_liabilitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.other_liabilitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Other_liabilitiesCountAggregateOutputType> | number
          }
        }
      }
      plaid_accounts: {
        payload: Prisma.$plaid_accountsPayload<ExtArgs>
        fields: Prisma.plaid_accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plaid_accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plaid_accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          findFirst: {
            args: Prisma.plaid_accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plaid_accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          findMany: {
            args: Prisma.plaid_accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>[]
          }
          create: {
            args: Prisma.plaid_accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          createMany: {
            args: Prisma.plaid_accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plaid_accountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>[]
          }
          delete: {
            args: Prisma.plaid_accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          update: {
            args: Prisma.plaid_accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          deleteMany: {
            args: Prisma.plaid_accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plaid_accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plaid_accountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>[]
          }
          upsert: {
            args: Prisma.plaid_accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_accountsPayload>
          }
          aggregate: {
            args: Prisma.Plaid_accountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaid_accounts>
          }
          groupBy: {
            args: Prisma.plaid_accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plaid_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.plaid_accountsCountArgs<ExtArgs>
            result: $Utils.Optional<Plaid_accountsCountAggregateOutputType> | number
          }
        }
      }
      plaid_items: {
        payload: Prisma.$plaid_itemsPayload<ExtArgs>
        fields: Prisma.plaid_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plaid_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plaid_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          findFirst: {
            args: Prisma.plaid_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plaid_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          findMany: {
            args: Prisma.plaid_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>[]
          }
          create: {
            args: Prisma.plaid_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          createMany: {
            args: Prisma.plaid_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plaid_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>[]
          }
          delete: {
            args: Prisma.plaid_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          update: {
            args: Prisma.plaid_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          deleteMany: {
            args: Prisma.plaid_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plaid_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plaid_itemsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>[]
          }
          upsert: {
            args: Prisma.plaid_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plaid_itemsPayload>
          }
          aggregate: {
            args: Prisma.Plaid_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaid_items>
          }
          groupBy: {
            args: Prisma.plaid_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Plaid_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.plaid_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Plaid_itemsCountAggregateOutputType> | number
          }
        }
      }
      properties: {
        payload: Prisma.$propertiesPayload<ExtArgs>
        fields: Prisma.propertiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.propertiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.propertiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          findFirst: {
            args: Prisma.propertiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.propertiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          findMany: {
            args: Prisma.propertiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>[]
          }
          create: {
            args: Prisma.propertiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          createMany: {
            args: Prisma.propertiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.propertiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>[]
          }
          delete: {
            args: Prisma.propertiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          update: {
            args: Prisma.propertiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          deleteMany: {
            args: Prisma.propertiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.propertiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.propertiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>[]
          }
          upsert: {
            args: Prisma.propertiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$propertiesPayload>
          }
          aggregate: {
            args: Prisma.PropertiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperties>
          }
          groupBy: {
            args: Prisma.propertiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.propertiesCountArgs<ExtArgs>
            result: $Utils.Optional<PropertiesCountAggregateOutputType> | number
          }
        }
      }
      rejected_transfers: {
        payload: Prisma.$rejected_transfersPayload<ExtArgs>
        fields: Prisma.rejected_transfersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rejected_transfersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rejected_transfersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          findFirst: {
            args: Prisma.rejected_transfersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rejected_transfersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          findMany: {
            args: Prisma.rejected_transfersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>[]
          }
          create: {
            args: Prisma.rejected_transfersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          createMany: {
            args: Prisma.rejected_transfersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rejected_transfersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>[]
          }
          delete: {
            args: Prisma.rejected_transfersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          update: {
            args: Prisma.rejected_transfersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          deleteMany: {
            args: Prisma.rejected_transfersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rejected_transfersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rejected_transfersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>[]
          }
          upsert: {
            args: Prisma.rejected_transfersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rejected_transfersPayload>
          }
          aggregate: {
            args: Prisma.Rejected_transfersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRejected_transfers>
          }
          groupBy: {
            args: Prisma.rejected_transfersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rejected_transfersGroupByOutputType>[]
          }
          count: {
            args: Prisma.rejected_transfersCountArgs<ExtArgs>
            result: $Utils.Optional<Rejected_transfersCountAggregateOutputType> | number
          }
        }
      }
      rule_actions: {
        payload: Prisma.$rule_actionsPayload<ExtArgs>
        fields: Prisma.rule_actionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rule_actionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rule_actionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          findFirst: {
            args: Prisma.rule_actionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rule_actionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          findMany: {
            args: Prisma.rule_actionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>[]
          }
          create: {
            args: Prisma.rule_actionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          createMany: {
            args: Prisma.rule_actionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rule_actionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>[]
          }
          delete: {
            args: Prisma.rule_actionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          update: {
            args: Prisma.rule_actionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          deleteMany: {
            args: Prisma.rule_actionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rule_actionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rule_actionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>[]
          }
          upsert: {
            args: Prisma.rule_actionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_actionsPayload>
          }
          aggregate: {
            args: Prisma.Rule_actionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRule_actions>
          }
          groupBy: {
            args: Prisma.rule_actionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rule_actionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rule_actionsCountArgs<ExtArgs>
            result: $Utils.Optional<Rule_actionsCountAggregateOutputType> | number
          }
        }
      }
      rule_conditions: {
        payload: Prisma.$rule_conditionsPayload<ExtArgs>
        fields: Prisma.rule_conditionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rule_conditionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rule_conditionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          findFirst: {
            args: Prisma.rule_conditionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rule_conditionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          findMany: {
            args: Prisma.rule_conditionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>[]
          }
          create: {
            args: Prisma.rule_conditionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          createMany: {
            args: Prisma.rule_conditionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rule_conditionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>[]
          }
          delete: {
            args: Prisma.rule_conditionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          update: {
            args: Prisma.rule_conditionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          deleteMany: {
            args: Prisma.rule_conditionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rule_conditionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rule_conditionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>[]
          }
          upsert: {
            args: Prisma.rule_conditionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rule_conditionsPayload>
          }
          aggregate: {
            args: Prisma.Rule_conditionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRule_conditions>
          }
          groupBy: {
            args: Prisma.rule_conditionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rule_conditionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rule_conditionsCountArgs<ExtArgs>
            result: $Utils.Optional<Rule_conditionsCountAggregateOutputType> | number
          }
        }
      }
      rules: {
        payload: Prisma.$rulesPayload<ExtArgs>
        fields: Prisma.rulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          findFirst: {
            args: Prisma.rulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          findMany: {
            args: Prisma.rulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>[]
          }
          create: {
            args: Prisma.rulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          createMany: {
            args: Prisma.rulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>[]
          }
          delete: {
            args: Prisma.rulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          update: {
            args: Prisma.rulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          deleteMany: {
            args: Prisma.rulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>[]
          }
          upsert: {
            args: Prisma.rulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rulesPayload>
          }
          aggregate: {
            args: Prisma.RulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRules>
          }
          groupBy: {
            args: Prisma.rulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rulesCountArgs<ExtArgs>
            result: $Utils.Optional<RulesCountAggregateOutputType> | number
          }
        }
      }
      schema_migrations: {
        payload: Prisma.$schema_migrationsPayload<ExtArgs>
        fields: Prisma.schema_migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schema_migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schema_migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findFirst: {
            args: Prisma.schema_migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schema_migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          findMany: {
            args: Prisma.schema_migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          create: {
            args: Prisma.schema_migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          createMany: {
            args: Prisma.schema_migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.schema_migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          delete: {
            args: Prisma.schema_migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          update: {
            args: Prisma.schema_migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          deleteMany: {
            args: Prisma.schema_migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.schema_migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.schema_migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>[]
          }
          upsert: {
            args: Prisma.schema_migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$schema_migrationsPayload>
          }
          aggregate: {
            args: Prisma.Schema_migrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchema_migrations>
          }
          groupBy: {
            args: Prisma.schema_migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.schema_migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Schema_migrationsCountAggregateOutputType> | number
          }
        }
      }
      securities: {
        payload: Prisma.$securitiesPayload<ExtArgs>
        fields: Prisma.securitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.securitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.securitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          findFirst: {
            args: Prisma.securitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.securitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          findMany: {
            args: Prisma.securitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>[]
          }
          create: {
            args: Prisma.securitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          createMany: {
            args: Prisma.securitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.securitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>[]
          }
          delete: {
            args: Prisma.securitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          update: {
            args: Prisma.securitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          deleteMany: {
            args: Prisma.securitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.securitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.securitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>[]
          }
          upsert: {
            args: Prisma.securitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$securitiesPayload>
          }
          aggregate: {
            args: Prisma.SecuritiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurities>
          }
          groupBy: {
            args: Prisma.securitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecuritiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.securitiesCountArgs<ExtArgs>
            result: $Utils.Optional<SecuritiesCountAggregateOutputType> | number
          }
        }
      }
      security_prices: {
        payload: Prisma.$security_pricesPayload<ExtArgs>
        fields: Prisma.security_pricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.security_pricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.security_pricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          findFirst: {
            args: Prisma.security_pricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.security_pricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          findMany: {
            args: Prisma.security_pricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>[]
          }
          create: {
            args: Prisma.security_pricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          createMany: {
            args: Prisma.security_pricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.security_pricesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>[]
          }
          delete: {
            args: Prisma.security_pricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          update: {
            args: Prisma.security_pricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          deleteMany: {
            args: Prisma.security_pricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.security_pricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.security_pricesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>[]
          }
          upsert: {
            args: Prisma.security_pricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$security_pricesPayload>
          }
          aggregate: {
            args: Prisma.Security_pricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurity_prices>
          }
          groupBy: {
            args: Prisma.security_pricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Security_pricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.security_pricesCountArgs<ExtArgs>
            result: $Utils.Optional<Security_pricesCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>
        fields: Prisma.settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.settingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[]
          }
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      stock_exchanges: {
        payload: Prisma.$stock_exchangesPayload<ExtArgs>
        fields: Prisma.stock_exchangesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stock_exchangesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stock_exchangesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          findFirst: {
            args: Prisma.stock_exchangesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stock_exchangesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          findMany: {
            args: Prisma.stock_exchangesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>[]
          }
          create: {
            args: Prisma.stock_exchangesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          createMany: {
            args: Prisma.stock_exchangesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.stock_exchangesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>[]
          }
          delete: {
            args: Prisma.stock_exchangesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          update: {
            args: Prisma.stock_exchangesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          deleteMany: {
            args: Prisma.stock_exchangesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stock_exchangesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.stock_exchangesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>[]
          }
          upsert: {
            args: Prisma.stock_exchangesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_exchangesPayload>
          }
          aggregate: {
            args: Prisma.Stock_exchangesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock_exchanges>
          }
          groupBy: {
            args: Prisma.stock_exchangesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stock_exchangesGroupByOutputType>[]
          }
          count: {
            args: Prisma.stock_exchangesCountArgs<ExtArgs>
            result: $Utils.Optional<Stock_exchangesCountAggregateOutputType> | number
          }
        }
      }
      syncs: {
        payload: Prisma.$syncsPayload<ExtArgs>
        fields: Prisma.syncsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.syncsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.syncsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          findFirst: {
            args: Prisma.syncsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.syncsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          findMany: {
            args: Prisma.syncsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>[]
          }
          create: {
            args: Prisma.syncsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          createMany: {
            args: Prisma.syncsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.syncsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>[]
          }
          delete: {
            args: Prisma.syncsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          update: {
            args: Prisma.syncsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          deleteMany: {
            args: Prisma.syncsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.syncsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.syncsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>[]
          }
          upsert: {
            args: Prisma.syncsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$syncsPayload>
          }
          aggregate: {
            args: Prisma.SyncsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncs>
          }
          groupBy: {
            args: Prisma.syncsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncsGroupByOutputType>[]
          }
          count: {
            args: Prisma.syncsCountArgs<ExtArgs>
            result: $Utils.Optional<SyncsCountAggregateOutputType> | number
          }
        }
      }
      taggings: {
        payload: Prisma.$taggingsPayload<ExtArgs>
        fields: Prisma.taggingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.taggingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.taggingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          findFirst: {
            args: Prisma.taggingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.taggingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          findMany: {
            args: Prisma.taggingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>[]
          }
          create: {
            args: Prisma.taggingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          createMany: {
            args: Prisma.taggingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.taggingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>[]
          }
          delete: {
            args: Prisma.taggingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          update: {
            args: Prisma.taggingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          deleteMany: {
            args: Prisma.taggingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.taggingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.taggingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>[]
          }
          upsert: {
            args: Prisma.taggingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taggingsPayload>
          }
          aggregate: {
            args: Prisma.TaggingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaggings>
          }
          groupBy: {
            args: Prisma.taggingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaggingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.taggingsCountArgs<ExtArgs>
            result: $Utils.Optional<TaggingsCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: Prisma.$tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      tool_calls: {
        payload: Prisma.$tool_callsPayload<ExtArgs>
        fields: Prisma.tool_callsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tool_callsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tool_callsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          findFirst: {
            args: Prisma.tool_callsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tool_callsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          findMany: {
            args: Prisma.tool_callsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>[]
          }
          create: {
            args: Prisma.tool_callsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          createMany: {
            args: Prisma.tool_callsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tool_callsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>[]
          }
          delete: {
            args: Prisma.tool_callsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          update: {
            args: Prisma.tool_callsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          deleteMany: {
            args: Prisma.tool_callsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tool_callsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tool_callsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>[]
          }
          upsert: {
            args: Prisma.tool_callsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tool_callsPayload>
          }
          aggregate: {
            args: Prisma.Tool_callsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTool_calls>
          }
          groupBy: {
            args: Prisma.tool_callsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tool_callsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tool_callsCountArgs<ExtArgs>
            result: $Utils.Optional<Tool_callsCountAggregateOutputType> | number
          }
        }
      }
      trades: {
        payload: Prisma.$tradesPayload<ExtArgs>
        fields: Prisma.tradesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tradesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tradesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          findFirst: {
            args: Prisma.tradesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tradesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          findMany: {
            args: Prisma.tradesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          create: {
            args: Prisma.tradesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          createMany: {
            args: Prisma.tradesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tradesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          delete: {
            args: Prisma.tradesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          update: {
            args: Prisma.tradesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          deleteMany: {
            args: Prisma.tradesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tradesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tradesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>[]
          }
          upsert: {
            args: Prisma.tradesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tradesPayload>
          }
          aggregate: {
            args: Prisma.TradesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrades>
          }
          groupBy: {
            args: Prisma.tradesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TradesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tradesCountArgs<ExtArgs>
            result: $Utils.Optional<TradesCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      transfers: {
        payload: Prisma.$transfersPayload<ExtArgs>
        fields: Prisma.transfersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transfersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transfersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          findFirst: {
            args: Prisma.transfersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transfersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          findMany: {
            args: Prisma.transfersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>[]
          }
          create: {
            args: Prisma.transfersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          createMany: {
            args: Prisma.transfersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.transfersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>[]
          }
          delete: {
            args: Prisma.transfersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          update: {
            args: Prisma.transfersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          deleteMany: {
            args: Prisma.transfersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transfersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.transfersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>[]
          }
          upsert: {
            args: Prisma.transfersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transfersPayload>
          }
          aggregate: {
            args: Prisma.TransfersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransfers>
          }
          groupBy: {
            args: Prisma.transfersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransfersGroupByOutputType>[]
          }
          count: {
            args: Prisma.transfersCountArgs<ExtArgs>
            result: $Utils.Optional<TransfersCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      valuations: {
        payload: Prisma.$valuationsPayload<ExtArgs>
        fields: Prisma.valuationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.valuationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.valuationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          findFirst: {
            args: Prisma.valuationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.valuationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          findMany: {
            args: Prisma.valuationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>[]
          }
          create: {
            args: Prisma.valuationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          createMany: {
            args: Prisma.valuationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.valuationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>[]
          }
          delete: {
            args: Prisma.valuationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          update: {
            args: Prisma.valuationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          deleteMany: {
            args: Prisma.valuationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.valuationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.valuationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>[]
          }
          upsert: {
            args: Prisma.valuationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$valuationsPayload>
          }
          aggregate: {
            args: Prisma.ValuationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValuations>
          }
          groupBy: {
            args: Prisma.valuationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValuationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.valuationsCountArgs<ExtArgs>
            result: $Utils.Optional<ValuationsCountAggregateOutputType> | number
          }
        }
      }
      vehicles: {
        payload: Prisma.$vehiclesPayload<ExtArgs>
        fields: Prisma.vehiclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehiclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehiclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findFirst: {
            args: Prisma.vehiclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehiclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          findMany: {
            args: Prisma.vehiclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          create: {
            args: Prisma.vehiclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          createMany: {
            args: Prisma.vehiclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.vehiclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          delete: {
            args: Prisma.vehiclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          update: {
            args: Prisma.vehiclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          deleteMany: {
            args: Prisma.vehiclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehiclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.vehiclesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>[]
          }
          upsert: {
            args: Prisma.vehiclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclesPayload>
          }
          aggregate: {
            args: Prisma.VehiclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicles>
          }
          groupBy: {
            args: Prisma.vehiclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehiclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.vehiclesCountArgs<ExtArgs>
            result: $Utils.Optional<VehiclesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    accounts?: accountsOmit
    active_storage_attachments?: active_storage_attachmentsOmit
    active_storage_blobs?: active_storage_blobsOmit
    active_storage_variant_records?: active_storage_variant_recordsOmit
    addresses?: addressesOmit
    ar_internal_metadata?: ar_internal_metadataOmit
    balances?: balancesOmit
    budget_categories?: budget_categoriesOmit
    budgets?: budgetsOmit
    categories?: categoriesOmit
    chats?: chatsOmit
    credit_cards?: credit_cardsOmit
    cryptos?: cryptosOmit
    data_enrichments?: data_enrichmentsOmit
    depositories?: depositoriesOmit
    entries?: entriesOmit
    exchange_rates?: exchange_ratesOmit
    families?: familiesOmit
    holdings?: holdingsOmit
    impersonation_session_logs?: impersonation_session_logsOmit
    impersonation_sessions?: impersonation_sessionsOmit
    import_mappings?: import_mappingsOmit
    import_rows?: import_rowsOmit
    imports?: importsOmit
    investments?: investmentsOmit
    invitations?: invitationsOmit
    invite_codes?: invite_codesOmit
    loans?: loansOmit
    merchants?: merchantsOmit
    messages?: messagesOmit
    other_assets?: other_assetsOmit
    other_liabilities?: other_liabilitiesOmit
    plaid_accounts?: plaid_accountsOmit
    plaid_items?: plaid_itemsOmit
    properties?: propertiesOmit
    rejected_transfers?: rejected_transfersOmit
    rule_actions?: rule_actionsOmit
    rule_conditions?: rule_conditionsOmit
    rules?: rulesOmit
    schema_migrations?: schema_migrationsOmit
    securities?: securitiesOmit
    security_prices?: security_pricesOmit
    sessions?: sessionsOmit
    settings?: settingsOmit
    stock_exchanges?: stock_exchangesOmit
    syncs?: syncsOmit
    taggings?: taggingsOmit
    tags?: tagsOmit
    tool_calls?: tool_callsOmit
    trades?: tradesOmit
    transactions?: transactionsOmit
    transfers?: transfersOmit
    users?: usersOmit
    valuations?: valuationsOmit
    vehicles?: vehiclesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountsCountOutputType
   */

  export type AccountsCountOutputType = {
    balances: number
    entries: number
    holdings: number
  }

  export type AccountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    balances?: boolean | AccountsCountOutputTypeCountBalancesArgs
    entries?: boolean | AccountsCountOutputTypeCountEntriesArgs
    holdings?: boolean | AccountsCountOutputTypeCountHoldingsArgs
  }

  // Custom InputTypes
  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountsCountOutputType
     */
    select?: AccountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balancesWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entriesWhereInput
  }

  /**
   * AccountsCountOutputType without action
   */
  export type AccountsCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holdingsWhereInput
  }


  /**
   * Count Type Active_storage_blobsCountOutputType
   */

  export type Active_storage_blobsCountOutputType = {
    active_storage_attachments: number
    active_storage_variant_records: number
  }

  export type Active_storage_blobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_attachments?: boolean | Active_storage_blobsCountOutputTypeCountActive_storage_attachmentsArgs
    active_storage_variant_records?: boolean | Active_storage_blobsCountOutputTypeCountActive_storage_variant_recordsArgs
  }

  // Custom InputTypes
  /**
   * Active_storage_blobsCountOutputType without action
   */
  export type Active_storage_blobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Active_storage_blobsCountOutputType
     */
    select?: Active_storage_blobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Active_storage_blobsCountOutputType without action
   */
  export type Active_storage_blobsCountOutputTypeCountActive_storage_attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_storage_attachmentsWhereInput
  }

  /**
   * Active_storage_blobsCountOutputType without action
   */
  export type Active_storage_blobsCountOutputTypeCountActive_storage_variant_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_storage_variant_recordsWhereInput
  }


  /**
   * Count Type BudgetsCountOutputType
   */

  export type BudgetsCountOutputType = {
    budget_categories: number
  }

  export type BudgetsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_categories?: boolean | BudgetsCountOutputTypeCountBudget_categoriesArgs
  }

  // Custom InputTypes
  /**
   * BudgetsCountOutputType without action
   */
  export type BudgetsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BudgetsCountOutputType
     */
    select?: BudgetsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BudgetsCountOutputType without action
   */
  export type BudgetsCountOutputTypeCountBudget_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_categoriesWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    budget_categories: number
    transactions: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_categories?: boolean | CategoriesCountOutputTypeCountBudget_categoriesArgs
    transactions?: boolean | CategoriesCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountBudget_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_categoriesWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type ChatsCountOutputType
   */

  export type ChatsCountOutputType = {
    messages: number
    users_users_last_viewed_chat_idTochats: number
  }

  export type ChatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatsCountOutputTypeCountMessagesArgs
    users_users_last_viewed_chat_idTochats?: boolean | ChatsCountOutputTypeCountUsers_users_last_viewed_chat_idTochatsArgs
  }

  // Custom InputTypes
  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatsCountOutputType
     */
    select?: ChatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountUsers_users_last_viewed_chat_idTochatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type FamiliesCountOutputType
   */

  export type FamiliesCountOutputType = {
    accounts: number
    budgets: number
    categories: number
    imports: number
    invitations: number
    merchants: number
    plaid_items: number
    rules: number
    tags: number
    users: number
  }

  export type FamiliesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | FamiliesCountOutputTypeCountAccountsArgs
    budgets?: boolean | FamiliesCountOutputTypeCountBudgetsArgs
    categories?: boolean | FamiliesCountOutputTypeCountCategoriesArgs
    imports?: boolean | FamiliesCountOutputTypeCountImportsArgs
    invitations?: boolean | FamiliesCountOutputTypeCountInvitationsArgs
    merchants?: boolean | FamiliesCountOutputTypeCountMerchantsArgs
    plaid_items?: boolean | FamiliesCountOutputTypeCountPlaid_itemsArgs
    rules?: boolean | FamiliesCountOutputTypeCountRulesArgs
    tags?: boolean | FamiliesCountOutputTypeCountTagsArgs
    users?: boolean | FamiliesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamiliesCountOutputType
     */
    select?: FamiliesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budgetsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountImportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: importsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountMerchantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: merchantsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountPlaid_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plaid_itemsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rulesWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
  }

  /**
   * FamiliesCountOutputType without action
   */
  export type FamiliesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Impersonation_sessionsCountOutputType
   */

  export type Impersonation_sessionsCountOutputType = {
    impersonation_session_logs: number
    sessions: number
  }

  export type Impersonation_sessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_session_logs?: boolean | Impersonation_sessionsCountOutputTypeCountImpersonation_session_logsArgs
    sessions?: boolean | Impersonation_sessionsCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * Impersonation_sessionsCountOutputType without action
   */
  export type Impersonation_sessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impersonation_sessionsCountOutputType
     */
    select?: Impersonation_sessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Impersonation_sessionsCountOutputType without action
   */
  export type Impersonation_sessionsCountOutputTypeCountImpersonation_session_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: impersonation_session_logsWhereInput
  }

  /**
   * Impersonation_sessionsCountOutputType without action
   */
  export type Impersonation_sessionsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }


  /**
   * Count Type ImportsCountOutputType
   */

  export type ImportsCountOutputType = {
    accounts: number
    entries: number
    import_rows: number
  }

  export type ImportsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | ImportsCountOutputTypeCountAccountsArgs
    entries?: boolean | ImportsCountOutputTypeCountEntriesArgs
    import_rows?: boolean | ImportsCountOutputTypeCountImport_rowsArgs
  }

  // Custom InputTypes
  /**
   * ImportsCountOutputType without action
   */
  export type ImportsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportsCountOutputType
     */
    select?: ImportsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportsCountOutputType without action
   */
  export type ImportsCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * ImportsCountOutputType without action
   */
  export type ImportsCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entriesWhereInput
  }

  /**
   * ImportsCountOutputType without action
   */
  export type ImportsCountOutputTypeCountImport_rowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: import_rowsWhereInput
  }


  /**
   * Count Type MerchantsCountOutputType
   */

  export type MerchantsCountOutputType = {
    transactions: number
  }

  export type MerchantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | MerchantsCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * MerchantsCountOutputType without action
   */
  export type MerchantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MerchantsCountOutputType
     */
    select?: MerchantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MerchantsCountOutputType without action
   */
  export type MerchantsCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type MessagesCountOutputType
   */

  export type MessagesCountOutputType = {
    tool_calls: number
  }

  export type MessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tool_calls?: boolean | MessagesCountOutputTypeCountTool_callsArgs
  }

  // Custom InputTypes
  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesCountOutputType
     */
    select?: MessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountTool_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tool_callsWhereInput
  }


  /**
   * Count Type Plaid_accountsCountOutputType
   */

  export type Plaid_accountsCountOutputType = {
    accounts: number
  }

  export type Plaid_accountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | Plaid_accountsCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * Plaid_accountsCountOutputType without action
   */
  export type Plaid_accountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plaid_accountsCountOutputType
     */
    select?: Plaid_accountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Plaid_accountsCountOutputType without action
   */
  export type Plaid_accountsCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }


  /**
   * Count Type Plaid_itemsCountOutputType
   */

  export type Plaid_itemsCountOutputType = {
    plaid_accounts: number
  }

  export type Plaid_itemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plaid_accounts?: boolean | Plaid_itemsCountOutputTypeCountPlaid_accountsArgs
  }

  // Custom InputTypes
  /**
   * Plaid_itemsCountOutputType without action
   */
  export type Plaid_itemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plaid_itemsCountOutputType
     */
    select?: Plaid_itemsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Plaid_itemsCountOutputType without action
   */
  export type Plaid_itemsCountOutputTypeCountPlaid_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plaid_accountsWhereInput
  }


  /**
   * Count Type Rule_conditionsCountOutputType
   */

  export type Rule_conditionsCountOutputType = {
    other_rule_conditions: number
  }

  export type Rule_conditionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_rule_conditions?: boolean | Rule_conditionsCountOutputTypeCountOther_rule_conditionsArgs
  }

  // Custom InputTypes
  /**
   * Rule_conditionsCountOutputType without action
   */
  export type Rule_conditionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rule_conditionsCountOutputType
     */
    select?: Rule_conditionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Rule_conditionsCountOutputType without action
   */
  export type Rule_conditionsCountOutputTypeCountOther_rule_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rule_conditionsWhereInput
  }


  /**
   * Count Type RulesCountOutputType
   */

  export type RulesCountOutputType = {
    rule_actions: number
    rule_conditions: number
  }

  export type RulesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule_actions?: boolean | RulesCountOutputTypeCountRule_actionsArgs
    rule_conditions?: boolean | RulesCountOutputTypeCountRule_conditionsArgs
  }

  // Custom InputTypes
  /**
   * RulesCountOutputType without action
   */
  export type RulesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RulesCountOutputType
     */
    select?: RulesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RulesCountOutputType without action
   */
  export type RulesCountOutputTypeCountRule_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rule_actionsWhereInput
  }

  /**
   * RulesCountOutputType without action
   */
  export type RulesCountOutputTypeCountRule_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rule_conditionsWhereInput
  }


  /**
   * Count Type SecuritiesCountOutputType
   */

  export type SecuritiesCountOutputType = {
    holdings: number
    security_prices: number
    trades: number
  }

  export type SecuritiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holdings?: boolean | SecuritiesCountOutputTypeCountHoldingsArgs
    security_prices?: boolean | SecuritiesCountOutputTypeCountSecurity_pricesArgs
    trades?: boolean | SecuritiesCountOutputTypeCountTradesArgs
  }

  // Custom InputTypes
  /**
   * SecuritiesCountOutputType without action
   */
  export type SecuritiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritiesCountOutputType
     */
    select?: SecuritiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SecuritiesCountOutputType without action
   */
  export type SecuritiesCountOutputTypeCountHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holdingsWhereInput
  }

  /**
   * SecuritiesCountOutputType without action
   */
  export type SecuritiesCountOutputTypeCountSecurity_pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: security_pricesWhereInput
  }

  /**
   * SecuritiesCountOutputType without action
   */
  export type SecuritiesCountOutputTypeCountTradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tradesWhereInput
  }


  /**
   * Count Type SyncsCountOutputType
   */

  export type SyncsCountOutputType = {
    other_syncs: number
  }

  export type SyncsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_syncs?: boolean | SyncsCountOutputTypeCountOther_syncsArgs
  }

  // Custom InputTypes
  /**
   * SyncsCountOutputType without action
   */
  export type SyncsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncsCountOutputType
     */
    select?: SyncsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyncsCountOutputType without action
   */
  export type SyncsCountOutputTypeCountOther_syncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: syncsWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    taggings: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taggings?: boolean | TagsCountOutputTypeCountTaggingsArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountTaggingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taggingsWhereInput
  }


  /**
   * Count Type TransactionsCountOutputType
   */

  export type TransactionsCountOutputType = {
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions: number
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions: number
    transfers_transfers_outflow_transaction_idTotransactions: number
    transfers_transfers_inflow_transaction_idTotransactions: number
  }

  export type TransactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: boolean | TransactionsCountOutputTypeCountRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: boolean | TransactionsCountOutputTypeCountRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs
    transfers_transfers_outflow_transaction_idTotransactions?: boolean | TransactionsCountOutputTypeCountTransfers_transfers_outflow_transaction_idTotransactionsArgs
    transfers_transfers_inflow_transaction_idTotransactions?: boolean | TransactionsCountOutputTypeCountTransfers_transfers_inflow_transaction_idTotransactionsArgs
  }

  // Custom InputTypes
  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsCountOutputType
     */
    select?: TransactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejected_transfersWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejected_transfersWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountTransfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transfersWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountTransfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transfersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    chats_chats_user_idTousers: number
    impersonation_sessions_impersonation_sessions_impersonator_idTousers: number
    impersonation_sessions_impersonation_sessions_impersonated_idTousers: number
    invitations: number
    sessions: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats_chats_user_idTousers?: boolean | UsersCountOutputTypeCountChats_chats_user_idTousersArgs
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: boolean | UsersCountOutputTypeCountImpersonation_sessions_impersonation_sessions_impersonator_idTousersArgs
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: boolean | UsersCountOutputTypeCountImpersonation_sessions_impersonation_sessions_impersonated_idTousersArgs
    invitations?: boolean | UsersCountOutputTypeCountInvitationsArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChats_chats_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountImpersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: impersonation_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountImpersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: impersonation_sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    balance: Decimal | null
    cash_balance: Decimal | null
  }

  export type AccountsSumAggregateOutputType = {
    balance: Decimal | null
    cash_balance: Decimal | null
  }

  export type AccountsMinAggregateOutputType = {
    id: string | null
    subtype: string | null
    family_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    accountable_type: string | null
    accountable_id: string | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean | null
    classification: string | null
    import_id: string | null
    plaid_account_id: string | null
    scheduled_for_deletion: boolean | null
    last_synced_at: Date | null
    cash_balance: Decimal | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: string | null
    subtype: string | null
    family_id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    accountable_type: string | null
    accountable_id: string | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean | null
    classification: string | null
    import_id: string | null
    plaid_account_id: string | null
    scheduled_for_deletion: boolean | null
    last_synced_at: Date | null
    cash_balance: Decimal | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    subtype: number
    family_id: number
    name: number
    created_at: number
    updated_at: number
    accountable_type: number
    accountable_id: number
    balance: number
    currency: number
    is_active: number
    classification: number
    import_id: number
    plaid_account_id: number
    scheduled_for_deletion: number
    last_synced_at: number
    cash_balance: number
    locked_attributes: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    balance?: true
    cash_balance?: true
  }

  export type AccountsSumAggregateInputType = {
    balance?: true
    cash_balance?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    subtype?: true
    family_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    accountable_type?: true
    accountable_id?: true
    balance?: true
    currency?: true
    is_active?: true
    classification?: true
    import_id?: true
    plaid_account_id?: true
    scheduled_for_deletion?: true
    last_synced_at?: true
    cash_balance?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    subtype?: true
    family_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    accountable_type?: true
    accountable_id?: true
    balance?: true
    currency?: true
    is_active?: true
    classification?: true
    import_id?: true
    plaid_account_id?: true
    scheduled_for_deletion?: true
    last_synced_at?: true
    cash_balance?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    subtype?: true
    family_id?: true
    name?: true
    created_at?: true
    updated_at?: true
    accountable_type?: true
    accountable_id?: true
    balance?: true
    currency?: true
    is_active?: true
    classification?: true
    import_id?: true
    plaid_account_id?: true
    scheduled_for_deletion?: true
    last_synced_at?: true
    cash_balance?: true
    locked_attributes?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: string
    subtype: string | null
    family_id: string
    name: string | null
    created_at: Date
    updated_at: Date
    accountable_type: string | null
    accountable_id: string | null
    balance: Decimal | null
    currency: string | null
    is_active: boolean
    classification: string | null
    import_id: string | null
    plaid_account_id: string | null
    scheduled_for_deletion: boolean | null
    last_synced_at: Date | null
    cash_balance: Decimal | null
    locked_attributes: JsonValue | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtype?: boolean
    family_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    accountable_type?: boolean
    accountable_id?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    classification?: boolean
    import_id?: boolean
    plaid_account_id?: boolean
    scheduled_for_deletion?: boolean
    last_synced_at?: boolean
    cash_balance?: boolean
    locked_attributes?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
    balances?: boolean | accounts$balancesArgs<ExtArgs>
    entries?: boolean | accounts$entriesArgs<ExtArgs>
    holdings?: boolean | accounts$holdingsArgs<ExtArgs>
    _count?: boolean | AccountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtype?: boolean
    family_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    accountable_type?: boolean
    accountable_id?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    classification?: boolean
    import_id?: boolean
    plaid_account_id?: boolean
    scheduled_for_deletion?: boolean
    last_synced_at?: boolean
    cash_balance?: boolean
    locked_attributes?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtype?: boolean
    family_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    accountable_type?: boolean
    accountable_id?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    classification?: boolean
    import_id?: boolean
    plaid_account_id?: boolean
    scheduled_for_deletion?: boolean
    last_synced_at?: boolean
    cash_balance?: boolean
    locked_attributes?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>

  export type accountsSelectScalar = {
    id?: boolean
    subtype?: boolean
    family_id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    accountable_type?: boolean
    accountable_id?: boolean
    balance?: boolean
    currency?: boolean
    is_active?: boolean
    classification?: boolean
    import_id?: boolean
    plaid_account_id?: boolean
    scheduled_for_deletion?: boolean
    last_synced_at?: boolean
    cash_balance?: boolean
    locked_attributes?: boolean
  }

  export type accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subtype" | "family_id" | "name" | "created_at" | "updated_at" | "accountable_type" | "accountable_id" | "balance" | "currency" | "is_active" | "classification" | "import_id" | "plaid_account_id" | "scheduled_for_deletion" | "last_synced_at" | "cash_balance" | "locked_attributes", ExtArgs["result"]["accounts"]>
  export type accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
    balances?: boolean | accounts$balancesArgs<ExtArgs>
    entries?: boolean | accounts$entriesArgs<ExtArgs>
    holdings?: boolean | accounts$holdingsArgs<ExtArgs>
    _count?: boolean | AccountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
  }
  export type accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    imports?: boolean | accounts$importsArgs<ExtArgs>
    plaid_accounts?: boolean | accounts$plaid_accountsArgs<ExtArgs>
  }

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {
      families: Prisma.$familiesPayload<ExtArgs>
      imports: Prisma.$importsPayload<ExtArgs> | null
      plaid_accounts: Prisma.$plaid_accountsPayload<ExtArgs> | null
      balances: Prisma.$balancesPayload<ExtArgs>[]
      entries: Prisma.$entriesPayload<ExtArgs>[]
      holdings: Prisma.$holdingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subtype: string | null
      family_id: string
      name: string | null
      created_at: Date
      updated_at: Date
      accountable_type: string | null
      accountable_id: string | null
      balance: Prisma.Decimal | null
      currency: string | null
      is_active: boolean
      classification: string | null
      import_id: string | null
      plaid_account_id: string | null
      scheduled_for_deletion: boolean | null
      last_synced_at: Date | null
      cash_balance: Prisma.Decimal | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {accountsCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {accountsUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountsWithIdOnly = await prisma.accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    imports<T extends accounts$importsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$importsArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plaid_accounts<T extends accounts$plaid_accountsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$plaid_accountsArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    balances<T extends accounts$balancesArgs<ExtArgs> = {}>(args?: Subset<T, accounts$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries<T extends accounts$entriesArgs<ExtArgs> = {}>(args?: Subset<T, accounts$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holdings<T extends accounts$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, accounts$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'String'>
    readonly subtype: FieldRef<"accounts", 'String'>
    readonly family_id: FieldRef<"accounts", 'String'>
    readonly name: FieldRef<"accounts", 'String'>
    readonly created_at: FieldRef<"accounts", 'DateTime'>
    readonly updated_at: FieldRef<"accounts", 'DateTime'>
    readonly accountable_type: FieldRef<"accounts", 'String'>
    readonly accountable_id: FieldRef<"accounts", 'String'>
    readonly balance: FieldRef<"accounts", 'Decimal'>
    readonly currency: FieldRef<"accounts", 'String'>
    readonly is_active: FieldRef<"accounts", 'Boolean'>
    readonly classification: FieldRef<"accounts", 'String'>
    readonly import_id: FieldRef<"accounts", 'String'>
    readonly plaid_account_id: FieldRef<"accounts", 'String'>
    readonly scheduled_for_deletion: FieldRef<"accounts", 'Boolean'>
    readonly last_synced_at: FieldRef<"accounts", 'DateTime'>
    readonly cash_balance: FieldRef<"accounts", 'Decimal'>
    readonly locked_attributes: FieldRef<"accounts", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts createManyAndReturn
   */
  export type accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts updateManyAndReturn
   */
  export type accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * accounts.imports
   */
  export type accounts$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    where?: importsWhereInput
  }

  /**
   * accounts.plaid_accounts
   */
  export type accounts$plaid_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    where?: plaid_accountsWhereInput
  }

  /**
   * accounts.balances
   */
  export type accounts$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    where?: balancesWhereInput
    orderBy?: balancesOrderByWithRelationInput | balancesOrderByWithRelationInput[]
    cursor?: balancesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * accounts.entries
   */
  export type accounts$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    where?: entriesWhereInput
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    cursor?: entriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntriesScalarFieldEnum | EntriesScalarFieldEnum[]
  }

  /**
   * accounts.holdings
   */
  export type accounts$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    where?: holdingsWhereInput
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    cursor?: holdingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldingsScalarFieldEnum | HoldingsScalarFieldEnum[]
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
  }


  /**
   * Model active_storage_attachments
   */

  export type AggregateActive_storage_attachments = {
    _count: Active_storage_attachmentsCountAggregateOutputType | null
    _min: Active_storage_attachmentsMinAggregateOutputType | null
    _max: Active_storage_attachmentsMaxAggregateOutputType | null
  }

  export type Active_storage_attachmentsMinAggregateOutputType = {
    id: string | null
    name: string | null
    record_type: string | null
    record_id: string | null
    blob_id: string | null
    created_at: Date | null
  }

  export type Active_storage_attachmentsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    record_type: string | null
    record_id: string | null
    blob_id: string | null
    created_at: Date | null
  }

  export type Active_storage_attachmentsCountAggregateOutputType = {
    id: number
    name: number
    record_type: number
    record_id: number
    blob_id: number
    created_at: number
    _all: number
  }


  export type Active_storage_attachmentsMinAggregateInputType = {
    id?: true
    name?: true
    record_type?: true
    record_id?: true
    blob_id?: true
    created_at?: true
  }

  export type Active_storage_attachmentsMaxAggregateInputType = {
    id?: true
    name?: true
    record_type?: true
    record_id?: true
    blob_id?: true
    created_at?: true
  }

  export type Active_storage_attachmentsCountAggregateInputType = {
    id?: true
    name?: true
    record_type?: true
    record_id?: true
    blob_id?: true
    created_at?: true
    _all?: true
  }

  export type Active_storage_attachmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_attachments to aggregate.
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_attachments to fetch.
     */
    orderBy?: active_storage_attachmentsOrderByWithRelationInput | active_storage_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: active_storage_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned active_storage_attachments
    **/
    _count?: true | Active_storage_attachmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Active_storage_attachmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Active_storage_attachmentsMaxAggregateInputType
  }

  export type GetActive_storage_attachmentsAggregateType<T extends Active_storage_attachmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateActive_storage_attachments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActive_storage_attachments[P]>
      : GetScalarType<T[P], AggregateActive_storage_attachments[P]>
  }




  export type active_storage_attachmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_storage_attachmentsWhereInput
    orderBy?: active_storage_attachmentsOrderByWithAggregationInput | active_storage_attachmentsOrderByWithAggregationInput[]
    by: Active_storage_attachmentsScalarFieldEnum[] | Active_storage_attachmentsScalarFieldEnum
    having?: active_storage_attachmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Active_storage_attachmentsCountAggregateInputType | true
    _min?: Active_storage_attachmentsMinAggregateInputType
    _max?: Active_storage_attachmentsMaxAggregateInputType
  }

  export type Active_storage_attachmentsGroupByOutputType = {
    id: string
    name: string
    record_type: string
    record_id: string
    blob_id: string
    created_at: Date
    _count: Active_storage_attachmentsCountAggregateOutputType | null
    _min: Active_storage_attachmentsMinAggregateOutputType | null
    _max: Active_storage_attachmentsMaxAggregateOutputType | null
  }

  type GetActive_storage_attachmentsGroupByPayload<T extends active_storage_attachmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Active_storage_attachmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Active_storage_attachmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Active_storage_attachmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Active_storage_attachmentsGroupByOutputType[P]>
        }
      >
    >


  export type active_storage_attachmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    record_type?: boolean
    record_id?: boolean
    blob_id?: boolean
    created_at?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_attachments"]>

  export type active_storage_attachmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    record_type?: boolean
    record_id?: boolean
    blob_id?: boolean
    created_at?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_attachments"]>

  export type active_storage_attachmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    record_type?: boolean
    record_id?: boolean
    blob_id?: boolean
    created_at?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_attachments"]>

  export type active_storage_attachmentsSelectScalar = {
    id?: boolean
    name?: boolean
    record_type?: boolean
    record_id?: boolean
    blob_id?: boolean
    created_at?: boolean
  }

  export type active_storage_attachmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "record_type" | "record_id" | "blob_id" | "created_at", ExtArgs["result"]["active_storage_attachments"]>
  export type active_storage_attachmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }
  export type active_storage_attachmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }
  export type active_storage_attachmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }

  export type $active_storage_attachmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "active_storage_attachments"
    objects: {
      active_storage_blobs: Prisma.$active_storage_blobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      record_type: string
      record_id: string
      blob_id: string
      created_at: Date
    }, ExtArgs["result"]["active_storage_attachments"]>
    composites: {}
  }

  type active_storage_attachmentsGetPayload<S extends boolean | null | undefined | active_storage_attachmentsDefaultArgs> = $Result.GetResult<Prisma.$active_storage_attachmentsPayload, S>

  type active_storage_attachmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<active_storage_attachmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Active_storage_attachmentsCountAggregateInputType | true
    }

  export interface active_storage_attachmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['active_storage_attachments'], meta: { name: 'active_storage_attachments' } }
    /**
     * Find zero or one Active_storage_attachments that matches the filter.
     * @param {active_storage_attachmentsFindUniqueArgs} args - Arguments to find a Active_storage_attachments
     * @example
     * // Get one Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends active_storage_attachmentsFindUniqueArgs>(args: SelectSubset<T, active_storage_attachmentsFindUniqueArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Active_storage_attachments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {active_storage_attachmentsFindUniqueOrThrowArgs} args - Arguments to find a Active_storage_attachments
     * @example
     * // Get one Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends active_storage_attachmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, active_storage_attachmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsFindFirstArgs} args - Arguments to find a Active_storage_attachments
     * @example
     * // Get one Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends active_storage_attachmentsFindFirstArgs>(args?: SelectSubset<T, active_storage_attachmentsFindFirstArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_attachments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsFindFirstOrThrowArgs} args - Arguments to find a Active_storage_attachments
     * @example
     * // Get one Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends active_storage_attachmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, active_storage_attachmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Active_storage_attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findMany()
     * 
     * // Get first 10 Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const active_storage_attachmentsWithIdOnly = await prisma.active_storage_attachments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends active_storage_attachmentsFindManyArgs>(args?: SelectSubset<T, active_storage_attachmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Active_storage_attachments.
     * @param {active_storage_attachmentsCreateArgs} args - Arguments to create a Active_storage_attachments.
     * @example
     * // Create one Active_storage_attachments
     * const Active_storage_attachments = await prisma.active_storage_attachments.create({
     *   data: {
     *     // ... data to create a Active_storage_attachments
     *   }
     * })
     * 
     */
    create<T extends active_storage_attachmentsCreateArgs>(args: SelectSubset<T, active_storage_attachmentsCreateArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Active_storage_attachments.
     * @param {active_storage_attachmentsCreateManyArgs} args - Arguments to create many Active_storage_attachments.
     * @example
     * // Create many Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends active_storage_attachmentsCreateManyArgs>(args?: SelectSubset<T, active_storage_attachmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Active_storage_attachments and returns the data saved in the database.
     * @param {active_storage_attachmentsCreateManyAndReturnArgs} args - Arguments to create many Active_storage_attachments.
     * @example
     * // Create many Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Active_storage_attachments and only return the `id`
     * const active_storage_attachmentsWithIdOnly = await prisma.active_storage_attachments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends active_storage_attachmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, active_storage_attachmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Active_storage_attachments.
     * @param {active_storage_attachmentsDeleteArgs} args - Arguments to delete one Active_storage_attachments.
     * @example
     * // Delete one Active_storage_attachments
     * const Active_storage_attachments = await prisma.active_storage_attachments.delete({
     *   where: {
     *     // ... filter to delete one Active_storage_attachments
     *   }
     * })
     * 
     */
    delete<T extends active_storage_attachmentsDeleteArgs>(args: SelectSubset<T, active_storage_attachmentsDeleteArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Active_storage_attachments.
     * @param {active_storage_attachmentsUpdateArgs} args - Arguments to update one Active_storage_attachments.
     * @example
     * // Update one Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends active_storage_attachmentsUpdateArgs>(args: SelectSubset<T, active_storage_attachmentsUpdateArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Active_storage_attachments.
     * @param {active_storage_attachmentsDeleteManyArgs} args - Arguments to filter Active_storage_attachments to delete.
     * @example
     * // Delete a few Active_storage_attachments
     * const { count } = await prisma.active_storage_attachments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends active_storage_attachmentsDeleteManyArgs>(args?: SelectSubset<T, active_storage_attachmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends active_storage_attachmentsUpdateManyArgs>(args: SelectSubset<T, active_storage_attachmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_attachments and returns the data updated in the database.
     * @param {active_storage_attachmentsUpdateManyAndReturnArgs} args - Arguments to update many Active_storage_attachments.
     * @example
     * // Update many Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Active_storage_attachments and only return the `id`
     * const active_storage_attachmentsWithIdOnly = await prisma.active_storage_attachments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends active_storage_attachmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, active_storage_attachmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Active_storage_attachments.
     * @param {active_storage_attachmentsUpsertArgs} args - Arguments to update or create a Active_storage_attachments.
     * @example
     * // Update or create a Active_storage_attachments
     * const active_storage_attachments = await prisma.active_storage_attachments.upsert({
     *   create: {
     *     // ... data to create a Active_storage_attachments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Active_storage_attachments we want to update
     *   }
     * })
     */
    upsert<T extends active_storage_attachmentsUpsertArgs>(args: SelectSubset<T, active_storage_attachmentsUpsertArgs<ExtArgs>>): Prisma__active_storage_attachmentsClient<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Active_storage_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsCountArgs} args - Arguments to filter Active_storage_attachments to count.
     * @example
     * // Count the number of Active_storage_attachments
     * const count = await prisma.active_storage_attachments.count({
     *   where: {
     *     // ... the filter for the Active_storage_attachments we want to count
     *   }
     * })
    **/
    count<T extends active_storage_attachmentsCountArgs>(
      args?: Subset<T, active_storage_attachmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Active_storage_attachmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Active_storage_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Active_storage_attachmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Active_storage_attachmentsAggregateArgs>(args: Subset<T, Active_storage_attachmentsAggregateArgs>): Prisma.PrismaPromise<GetActive_storage_attachmentsAggregateType<T>>

    /**
     * Group by Active_storage_attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_attachmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends active_storage_attachmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: active_storage_attachmentsGroupByArgs['orderBy'] }
        : { orderBy?: active_storage_attachmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, active_storage_attachmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActive_storage_attachmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the active_storage_attachments model
   */
  readonly fields: active_storage_attachmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for active_storage_attachments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__active_storage_attachmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_storage_blobs<T extends active_storage_blobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, active_storage_blobsDefaultArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the active_storage_attachments model
   */
  interface active_storage_attachmentsFieldRefs {
    readonly id: FieldRef<"active_storage_attachments", 'String'>
    readonly name: FieldRef<"active_storage_attachments", 'String'>
    readonly record_type: FieldRef<"active_storage_attachments", 'String'>
    readonly record_id: FieldRef<"active_storage_attachments", 'String'>
    readonly blob_id: FieldRef<"active_storage_attachments", 'String'>
    readonly created_at: FieldRef<"active_storage_attachments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * active_storage_attachments findUnique
   */
  export type active_storage_attachmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_attachments to fetch.
     */
    where: active_storage_attachmentsWhereUniqueInput
  }

  /**
   * active_storage_attachments findUniqueOrThrow
   */
  export type active_storage_attachmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_attachments to fetch.
     */
    where: active_storage_attachmentsWhereUniqueInput
  }

  /**
   * active_storage_attachments findFirst
   */
  export type active_storage_attachmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_attachments to fetch.
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_attachments to fetch.
     */
    orderBy?: active_storage_attachmentsOrderByWithRelationInput | active_storage_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_attachments.
     */
    cursor?: active_storage_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_attachments.
     */
    distinct?: Active_storage_attachmentsScalarFieldEnum | Active_storage_attachmentsScalarFieldEnum[]
  }

  /**
   * active_storage_attachments findFirstOrThrow
   */
  export type active_storage_attachmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_attachments to fetch.
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_attachments to fetch.
     */
    orderBy?: active_storage_attachmentsOrderByWithRelationInput | active_storage_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_attachments.
     */
    cursor?: active_storage_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_attachments.
     */
    distinct?: Active_storage_attachmentsScalarFieldEnum | Active_storage_attachmentsScalarFieldEnum[]
  }

  /**
   * active_storage_attachments findMany
   */
  export type active_storage_attachmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_attachments to fetch.
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_attachments to fetch.
     */
    orderBy?: active_storage_attachmentsOrderByWithRelationInput | active_storage_attachmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing active_storage_attachments.
     */
    cursor?: active_storage_attachmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_attachments.
     */
    skip?: number
    distinct?: Active_storage_attachmentsScalarFieldEnum | Active_storage_attachmentsScalarFieldEnum[]
  }

  /**
   * active_storage_attachments create
   */
  export type active_storage_attachmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a active_storage_attachments.
     */
    data: XOR<active_storage_attachmentsCreateInput, active_storage_attachmentsUncheckedCreateInput>
  }

  /**
   * active_storage_attachments createMany
   */
  export type active_storage_attachmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many active_storage_attachments.
     */
    data: active_storage_attachmentsCreateManyInput | active_storage_attachmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * active_storage_attachments createManyAndReturn
   */
  export type active_storage_attachmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * The data used to create many active_storage_attachments.
     */
    data: active_storage_attachmentsCreateManyInput | active_storage_attachmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * active_storage_attachments update
   */
  export type active_storage_attachmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a active_storage_attachments.
     */
    data: XOR<active_storage_attachmentsUpdateInput, active_storage_attachmentsUncheckedUpdateInput>
    /**
     * Choose, which active_storage_attachments to update.
     */
    where: active_storage_attachmentsWhereUniqueInput
  }

  /**
   * active_storage_attachments updateMany
   */
  export type active_storage_attachmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update active_storage_attachments.
     */
    data: XOR<active_storage_attachmentsUpdateManyMutationInput, active_storage_attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_attachments to update
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * Limit how many active_storage_attachments to update.
     */
    limit?: number
  }

  /**
   * active_storage_attachments updateManyAndReturn
   */
  export type active_storage_attachmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * The data used to update active_storage_attachments.
     */
    data: XOR<active_storage_attachmentsUpdateManyMutationInput, active_storage_attachmentsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_attachments to update
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * Limit how many active_storage_attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * active_storage_attachments upsert
   */
  export type active_storage_attachmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the active_storage_attachments to update in case it exists.
     */
    where: active_storage_attachmentsWhereUniqueInput
    /**
     * In case the active_storage_attachments found by the `where` argument doesn't exist, create a new active_storage_attachments with this data.
     */
    create: XOR<active_storage_attachmentsCreateInput, active_storage_attachmentsUncheckedCreateInput>
    /**
     * In case the active_storage_attachments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<active_storage_attachmentsUpdateInput, active_storage_attachmentsUncheckedUpdateInput>
  }

  /**
   * active_storage_attachments delete
   */
  export type active_storage_attachmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    /**
     * Filter which active_storage_attachments to delete.
     */
    where: active_storage_attachmentsWhereUniqueInput
  }

  /**
   * active_storage_attachments deleteMany
   */
  export type active_storage_attachmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_attachments to delete
     */
    where?: active_storage_attachmentsWhereInput
    /**
     * Limit how many active_storage_attachments to delete.
     */
    limit?: number
  }

  /**
   * active_storage_attachments without action
   */
  export type active_storage_attachmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
  }


  /**
   * Model active_storage_blobs
   */

  export type AggregateActive_storage_blobs = {
    _count: Active_storage_blobsCountAggregateOutputType | null
    _avg: Active_storage_blobsAvgAggregateOutputType | null
    _sum: Active_storage_blobsSumAggregateOutputType | null
    _min: Active_storage_blobsMinAggregateOutputType | null
    _max: Active_storage_blobsMaxAggregateOutputType | null
  }

  export type Active_storage_blobsAvgAggregateOutputType = {
    byte_size: number | null
  }

  export type Active_storage_blobsSumAggregateOutputType = {
    byte_size: bigint | null
  }

  export type Active_storage_blobsMinAggregateOutputType = {
    id: string | null
    key: string | null
    filename: string | null
    content_type: string | null
    metadata: string | null
    service_name: string | null
    byte_size: bigint | null
    checksum: string | null
    created_at: Date | null
  }

  export type Active_storage_blobsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    filename: string | null
    content_type: string | null
    metadata: string | null
    service_name: string | null
    byte_size: bigint | null
    checksum: string | null
    created_at: Date | null
  }

  export type Active_storage_blobsCountAggregateOutputType = {
    id: number
    key: number
    filename: number
    content_type: number
    metadata: number
    service_name: number
    byte_size: number
    checksum: number
    created_at: number
    _all: number
  }


  export type Active_storage_blobsAvgAggregateInputType = {
    byte_size?: true
  }

  export type Active_storage_blobsSumAggregateInputType = {
    byte_size?: true
  }

  export type Active_storage_blobsMinAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    content_type?: true
    metadata?: true
    service_name?: true
    byte_size?: true
    checksum?: true
    created_at?: true
  }

  export type Active_storage_blobsMaxAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    content_type?: true
    metadata?: true
    service_name?: true
    byte_size?: true
    checksum?: true
    created_at?: true
  }

  export type Active_storage_blobsCountAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    content_type?: true
    metadata?: true
    service_name?: true
    byte_size?: true
    checksum?: true
    created_at?: true
    _all?: true
  }

  export type Active_storage_blobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_blobs to aggregate.
     */
    where?: active_storage_blobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_blobs to fetch.
     */
    orderBy?: active_storage_blobsOrderByWithRelationInput | active_storage_blobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: active_storage_blobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned active_storage_blobs
    **/
    _count?: true | Active_storage_blobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Active_storage_blobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Active_storage_blobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Active_storage_blobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Active_storage_blobsMaxAggregateInputType
  }

  export type GetActive_storage_blobsAggregateType<T extends Active_storage_blobsAggregateArgs> = {
        [P in keyof T & keyof AggregateActive_storage_blobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActive_storage_blobs[P]>
      : GetScalarType<T[P], AggregateActive_storage_blobs[P]>
  }




  export type active_storage_blobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_storage_blobsWhereInput
    orderBy?: active_storage_blobsOrderByWithAggregationInput | active_storage_blobsOrderByWithAggregationInput[]
    by: Active_storage_blobsScalarFieldEnum[] | Active_storage_blobsScalarFieldEnum
    having?: active_storage_blobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Active_storage_blobsCountAggregateInputType | true
    _avg?: Active_storage_blobsAvgAggregateInputType
    _sum?: Active_storage_blobsSumAggregateInputType
    _min?: Active_storage_blobsMinAggregateInputType
    _max?: Active_storage_blobsMaxAggregateInputType
  }

  export type Active_storage_blobsGroupByOutputType = {
    id: string
    key: string
    filename: string
    content_type: string | null
    metadata: string | null
    service_name: string
    byte_size: bigint
    checksum: string | null
    created_at: Date
    _count: Active_storage_blobsCountAggregateOutputType | null
    _avg: Active_storage_blobsAvgAggregateOutputType | null
    _sum: Active_storage_blobsSumAggregateOutputType | null
    _min: Active_storage_blobsMinAggregateOutputType | null
    _max: Active_storage_blobsMaxAggregateOutputType | null
  }

  type GetActive_storage_blobsGroupByPayload<T extends active_storage_blobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Active_storage_blobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Active_storage_blobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Active_storage_blobsGroupByOutputType[P]>
            : GetScalarType<T[P], Active_storage_blobsGroupByOutputType[P]>
        }
      >
    >


  export type active_storage_blobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    content_type?: boolean
    metadata?: boolean
    service_name?: boolean
    byte_size?: boolean
    checksum?: boolean
    created_at?: boolean
    active_storage_attachments?: boolean | active_storage_blobs$active_storage_attachmentsArgs<ExtArgs>
    active_storage_variant_records?: boolean | active_storage_blobs$active_storage_variant_recordsArgs<ExtArgs>
    _count?: boolean | Active_storage_blobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_blobs"]>

  export type active_storage_blobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    content_type?: boolean
    metadata?: boolean
    service_name?: boolean
    byte_size?: boolean
    checksum?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["active_storage_blobs"]>

  export type active_storage_blobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    content_type?: boolean
    metadata?: boolean
    service_name?: boolean
    byte_size?: boolean
    checksum?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["active_storage_blobs"]>

  export type active_storage_blobsSelectScalar = {
    id?: boolean
    key?: boolean
    filename?: boolean
    content_type?: boolean
    metadata?: boolean
    service_name?: boolean
    byte_size?: boolean
    checksum?: boolean
    created_at?: boolean
  }

  export type active_storage_blobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "filename" | "content_type" | "metadata" | "service_name" | "byte_size" | "checksum" | "created_at", ExtArgs["result"]["active_storage_blobs"]>
  export type active_storage_blobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_attachments?: boolean | active_storage_blobs$active_storage_attachmentsArgs<ExtArgs>
    active_storage_variant_records?: boolean | active_storage_blobs$active_storage_variant_recordsArgs<ExtArgs>
    _count?: boolean | Active_storage_blobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type active_storage_blobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type active_storage_blobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $active_storage_blobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "active_storage_blobs"
    objects: {
      active_storage_attachments: Prisma.$active_storage_attachmentsPayload<ExtArgs>[]
      active_storage_variant_records: Prisma.$active_storage_variant_recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      filename: string
      content_type: string | null
      metadata: string | null
      service_name: string
      byte_size: bigint
      checksum: string | null
      created_at: Date
    }, ExtArgs["result"]["active_storage_blobs"]>
    composites: {}
  }

  type active_storage_blobsGetPayload<S extends boolean | null | undefined | active_storage_blobsDefaultArgs> = $Result.GetResult<Prisma.$active_storage_blobsPayload, S>

  type active_storage_blobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<active_storage_blobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Active_storage_blobsCountAggregateInputType | true
    }

  export interface active_storage_blobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['active_storage_blobs'], meta: { name: 'active_storage_blobs' } }
    /**
     * Find zero or one Active_storage_blobs that matches the filter.
     * @param {active_storage_blobsFindUniqueArgs} args - Arguments to find a Active_storage_blobs
     * @example
     * // Get one Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends active_storage_blobsFindUniqueArgs>(args: SelectSubset<T, active_storage_blobsFindUniqueArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Active_storage_blobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {active_storage_blobsFindUniqueOrThrowArgs} args - Arguments to find a Active_storage_blobs
     * @example
     * // Get one Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends active_storage_blobsFindUniqueOrThrowArgs>(args: SelectSubset<T, active_storage_blobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_blobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsFindFirstArgs} args - Arguments to find a Active_storage_blobs
     * @example
     * // Get one Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends active_storage_blobsFindFirstArgs>(args?: SelectSubset<T, active_storage_blobsFindFirstArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_blobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsFindFirstOrThrowArgs} args - Arguments to find a Active_storage_blobs
     * @example
     * // Get one Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends active_storage_blobsFindFirstOrThrowArgs>(args?: SelectSubset<T, active_storage_blobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Active_storage_blobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findMany()
     * 
     * // Get first 10 Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const active_storage_blobsWithIdOnly = await prisma.active_storage_blobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends active_storage_blobsFindManyArgs>(args?: SelectSubset<T, active_storage_blobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Active_storage_blobs.
     * @param {active_storage_blobsCreateArgs} args - Arguments to create a Active_storage_blobs.
     * @example
     * // Create one Active_storage_blobs
     * const Active_storage_blobs = await prisma.active_storage_blobs.create({
     *   data: {
     *     // ... data to create a Active_storage_blobs
     *   }
     * })
     * 
     */
    create<T extends active_storage_blobsCreateArgs>(args: SelectSubset<T, active_storage_blobsCreateArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Active_storage_blobs.
     * @param {active_storage_blobsCreateManyArgs} args - Arguments to create many Active_storage_blobs.
     * @example
     * // Create many Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends active_storage_blobsCreateManyArgs>(args?: SelectSubset<T, active_storage_blobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Active_storage_blobs and returns the data saved in the database.
     * @param {active_storage_blobsCreateManyAndReturnArgs} args - Arguments to create many Active_storage_blobs.
     * @example
     * // Create many Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Active_storage_blobs and only return the `id`
     * const active_storage_blobsWithIdOnly = await prisma.active_storage_blobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends active_storage_blobsCreateManyAndReturnArgs>(args?: SelectSubset<T, active_storage_blobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Active_storage_blobs.
     * @param {active_storage_blobsDeleteArgs} args - Arguments to delete one Active_storage_blobs.
     * @example
     * // Delete one Active_storage_blobs
     * const Active_storage_blobs = await prisma.active_storage_blobs.delete({
     *   where: {
     *     // ... filter to delete one Active_storage_blobs
     *   }
     * })
     * 
     */
    delete<T extends active_storage_blobsDeleteArgs>(args: SelectSubset<T, active_storage_blobsDeleteArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Active_storage_blobs.
     * @param {active_storage_blobsUpdateArgs} args - Arguments to update one Active_storage_blobs.
     * @example
     * // Update one Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends active_storage_blobsUpdateArgs>(args: SelectSubset<T, active_storage_blobsUpdateArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Active_storage_blobs.
     * @param {active_storage_blobsDeleteManyArgs} args - Arguments to filter Active_storage_blobs to delete.
     * @example
     * // Delete a few Active_storage_blobs
     * const { count } = await prisma.active_storage_blobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends active_storage_blobsDeleteManyArgs>(args?: SelectSubset<T, active_storage_blobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends active_storage_blobsUpdateManyArgs>(args: SelectSubset<T, active_storage_blobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_blobs and returns the data updated in the database.
     * @param {active_storage_blobsUpdateManyAndReturnArgs} args - Arguments to update many Active_storage_blobs.
     * @example
     * // Update many Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Active_storage_blobs and only return the `id`
     * const active_storage_blobsWithIdOnly = await prisma.active_storage_blobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends active_storage_blobsUpdateManyAndReturnArgs>(args: SelectSubset<T, active_storage_blobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Active_storage_blobs.
     * @param {active_storage_blobsUpsertArgs} args - Arguments to update or create a Active_storage_blobs.
     * @example
     * // Update or create a Active_storage_blobs
     * const active_storage_blobs = await prisma.active_storage_blobs.upsert({
     *   create: {
     *     // ... data to create a Active_storage_blobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Active_storage_blobs we want to update
     *   }
     * })
     */
    upsert<T extends active_storage_blobsUpsertArgs>(args: SelectSubset<T, active_storage_blobsUpsertArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Active_storage_blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsCountArgs} args - Arguments to filter Active_storage_blobs to count.
     * @example
     * // Count the number of Active_storage_blobs
     * const count = await prisma.active_storage_blobs.count({
     *   where: {
     *     // ... the filter for the Active_storage_blobs we want to count
     *   }
     * })
    **/
    count<T extends active_storage_blobsCountArgs>(
      args?: Subset<T, active_storage_blobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Active_storage_blobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Active_storage_blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Active_storage_blobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Active_storage_blobsAggregateArgs>(args: Subset<T, Active_storage_blobsAggregateArgs>): Prisma.PrismaPromise<GetActive_storage_blobsAggregateType<T>>

    /**
     * Group by Active_storage_blobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_blobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends active_storage_blobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: active_storage_blobsGroupByArgs['orderBy'] }
        : { orderBy?: active_storage_blobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, active_storage_blobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActive_storage_blobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the active_storage_blobs model
   */
  readonly fields: active_storage_blobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for active_storage_blobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__active_storage_blobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_storage_attachments<T extends active_storage_blobs$active_storage_attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, active_storage_blobs$active_storage_attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_attachmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    active_storage_variant_records<T extends active_storage_blobs$active_storage_variant_recordsArgs<ExtArgs> = {}>(args?: Subset<T, active_storage_blobs$active_storage_variant_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the active_storage_blobs model
   */
  interface active_storage_blobsFieldRefs {
    readonly id: FieldRef<"active_storage_blobs", 'String'>
    readonly key: FieldRef<"active_storage_blobs", 'String'>
    readonly filename: FieldRef<"active_storage_blobs", 'String'>
    readonly content_type: FieldRef<"active_storage_blobs", 'String'>
    readonly metadata: FieldRef<"active_storage_blobs", 'String'>
    readonly service_name: FieldRef<"active_storage_blobs", 'String'>
    readonly byte_size: FieldRef<"active_storage_blobs", 'BigInt'>
    readonly checksum: FieldRef<"active_storage_blobs", 'String'>
    readonly created_at: FieldRef<"active_storage_blobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * active_storage_blobs findUnique
   */
  export type active_storage_blobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_blobs to fetch.
     */
    where: active_storage_blobsWhereUniqueInput
  }

  /**
   * active_storage_blobs findUniqueOrThrow
   */
  export type active_storage_blobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_blobs to fetch.
     */
    where: active_storage_blobsWhereUniqueInput
  }

  /**
   * active_storage_blobs findFirst
   */
  export type active_storage_blobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_blobs to fetch.
     */
    where?: active_storage_blobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_blobs to fetch.
     */
    orderBy?: active_storage_blobsOrderByWithRelationInput | active_storage_blobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_blobs.
     */
    cursor?: active_storage_blobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_blobs.
     */
    distinct?: Active_storage_blobsScalarFieldEnum | Active_storage_blobsScalarFieldEnum[]
  }

  /**
   * active_storage_blobs findFirstOrThrow
   */
  export type active_storage_blobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_blobs to fetch.
     */
    where?: active_storage_blobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_blobs to fetch.
     */
    orderBy?: active_storage_blobsOrderByWithRelationInput | active_storage_blobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_blobs.
     */
    cursor?: active_storage_blobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_blobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_blobs.
     */
    distinct?: Active_storage_blobsScalarFieldEnum | Active_storage_blobsScalarFieldEnum[]
  }

  /**
   * active_storage_blobs findMany
   */
  export type active_storage_blobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_blobs to fetch.
     */
    where?: active_storage_blobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_blobs to fetch.
     */
    orderBy?: active_storage_blobsOrderByWithRelationInput | active_storage_blobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing active_storage_blobs.
     */
    cursor?: active_storage_blobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_blobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_blobs.
     */
    skip?: number
    distinct?: Active_storage_blobsScalarFieldEnum | Active_storage_blobsScalarFieldEnum[]
  }

  /**
   * active_storage_blobs create
   */
  export type active_storage_blobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * The data needed to create a active_storage_blobs.
     */
    data: XOR<active_storage_blobsCreateInput, active_storage_blobsUncheckedCreateInput>
  }

  /**
   * active_storage_blobs createMany
   */
  export type active_storage_blobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many active_storage_blobs.
     */
    data: active_storage_blobsCreateManyInput | active_storage_blobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * active_storage_blobs createManyAndReturn
   */
  export type active_storage_blobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * The data used to create many active_storage_blobs.
     */
    data: active_storage_blobsCreateManyInput | active_storage_blobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * active_storage_blobs update
   */
  export type active_storage_blobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * The data needed to update a active_storage_blobs.
     */
    data: XOR<active_storage_blobsUpdateInput, active_storage_blobsUncheckedUpdateInput>
    /**
     * Choose, which active_storage_blobs to update.
     */
    where: active_storage_blobsWhereUniqueInput
  }

  /**
   * active_storage_blobs updateMany
   */
  export type active_storage_blobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update active_storage_blobs.
     */
    data: XOR<active_storage_blobsUpdateManyMutationInput, active_storage_blobsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_blobs to update
     */
    where?: active_storage_blobsWhereInput
    /**
     * Limit how many active_storage_blobs to update.
     */
    limit?: number
  }

  /**
   * active_storage_blobs updateManyAndReturn
   */
  export type active_storage_blobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * The data used to update active_storage_blobs.
     */
    data: XOR<active_storage_blobsUpdateManyMutationInput, active_storage_blobsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_blobs to update
     */
    where?: active_storage_blobsWhereInput
    /**
     * Limit how many active_storage_blobs to update.
     */
    limit?: number
  }

  /**
   * active_storage_blobs upsert
   */
  export type active_storage_blobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * The filter to search for the active_storage_blobs to update in case it exists.
     */
    where: active_storage_blobsWhereUniqueInput
    /**
     * In case the active_storage_blobs found by the `where` argument doesn't exist, create a new active_storage_blobs with this data.
     */
    create: XOR<active_storage_blobsCreateInput, active_storage_blobsUncheckedCreateInput>
    /**
     * In case the active_storage_blobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<active_storage_blobsUpdateInput, active_storage_blobsUncheckedUpdateInput>
  }

  /**
   * active_storage_blobs delete
   */
  export type active_storage_blobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
    /**
     * Filter which active_storage_blobs to delete.
     */
    where: active_storage_blobsWhereUniqueInput
  }

  /**
   * active_storage_blobs deleteMany
   */
  export type active_storage_blobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_blobs to delete
     */
    where?: active_storage_blobsWhereInput
    /**
     * Limit how many active_storage_blobs to delete.
     */
    limit?: number
  }

  /**
   * active_storage_blobs.active_storage_attachments
   */
  export type active_storage_blobs$active_storage_attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_attachments
     */
    select?: active_storage_attachmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_attachments
     */
    omit?: active_storage_attachmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_attachmentsInclude<ExtArgs> | null
    where?: active_storage_attachmentsWhereInput
    orderBy?: active_storage_attachmentsOrderByWithRelationInput | active_storage_attachmentsOrderByWithRelationInput[]
    cursor?: active_storage_attachmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Active_storage_attachmentsScalarFieldEnum | Active_storage_attachmentsScalarFieldEnum[]
  }

  /**
   * active_storage_blobs.active_storage_variant_records
   */
  export type active_storage_blobs$active_storage_variant_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    where?: active_storage_variant_recordsWhereInput
    orderBy?: active_storage_variant_recordsOrderByWithRelationInput | active_storage_variant_recordsOrderByWithRelationInput[]
    cursor?: active_storage_variant_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Active_storage_variant_recordsScalarFieldEnum | Active_storage_variant_recordsScalarFieldEnum[]
  }

  /**
   * active_storage_blobs without action
   */
  export type active_storage_blobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_blobs
     */
    select?: active_storage_blobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_blobs
     */
    omit?: active_storage_blobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_blobsInclude<ExtArgs> | null
  }


  /**
   * Model active_storage_variant_records
   */

  export type AggregateActive_storage_variant_records = {
    _count: Active_storage_variant_recordsCountAggregateOutputType | null
    _min: Active_storage_variant_recordsMinAggregateOutputType | null
    _max: Active_storage_variant_recordsMaxAggregateOutputType | null
  }

  export type Active_storage_variant_recordsMinAggregateOutputType = {
    id: string | null
    blob_id: string | null
    variation_digest: string | null
  }

  export type Active_storage_variant_recordsMaxAggregateOutputType = {
    id: string | null
    blob_id: string | null
    variation_digest: string | null
  }

  export type Active_storage_variant_recordsCountAggregateOutputType = {
    id: number
    blob_id: number
    variation_digest: number
    _all: number
  }


  export type Active_storage_variant_recordsMinAggregateInputType = {
    id?: true
    blob_id?: true
    variation_digest?: true
  }

  export type Active_storage_variant_recordsMaxAggregateInputType = {
    id?: true
    blob_id?: true
    variation_digest?: true
  }

  export type Active_storage_variant_recordsCountAggregateInputType = {
    id?: true
    blob_id?: true
    variation_digest?: true
    _all?: true
  }

  export type Active_storage_variant_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_variant_records to aggregate.
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_variant_records to fetch.
     */
    orderBy?: active_storage_variant_recordsOrderByWithRelationInput | active_storage_variant_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: active_storage_variant_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_variant_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_variant_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned active_storage_variant_records
    **/
    _count?: true | Active_storage_variant_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Active_storage_variant_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Active_storage_variant_recordsMaxAggregateInputType
  }

  export type GetActive_storage_variant_recordsAggregateType<T extends Active_storage_variant_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateActive_storage_variant_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActive_storage_variant_records[P]>
      : GetScalarType<T[P], AggregateActive_storage_variant_records[P]>
  }




  export type active_storage_variant_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: active_storage_variant_recordsWhereInput
    orderBy?: active_storage_variant_recordsOrderByWithAggregationInput | active_storage_variant_recordsOrderByWithAggregationInput[]
    by: Active_storage_variant_recordsScalarFieldEnum[] | Active_storage_variant_recordsScalarFieldEnum
    having?: active_storage_variant_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Active_storage_variant_recordsCountAggregateInputType | true
    _min?: Active_storage_variant_recordsMinAggregateInputType
    _max?: Active_storage_variant_recordsMaxAggregateInputType
  }

  export type Active_storage_variant_recordsGroupByOutputType = {
    id: string
    blob_id: string
    variation_digest: string
    _count: Active_storage_variant_recordsCountAggregateOutputType | null
    _min: Active_storage_variant_recordsMinAggregateOutputType | null
    _max: Active_storage_variant_recordsMaxAggregateOutputType | null
  }

  type GetActive_storage_variant_recordsGroupByPayload<T extends active_storage_variant_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Active_storage_variant_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Active_storage_variant_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Active_storage_variant_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Active_storage_variant_recordsGroupByOutputType[P]>
        }
      >
    >


  export type active_storage_variant_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blob_id?: boolean
    variation_digest?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_variant_records"]>

  export type active_storage_variant_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blob_id?: boolean
    variation_digest?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_variant_records"]>

  export type active_storage_variant_recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blob_id?: boolean
    variation_digest?: boolean
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["active_storage_variant_records"]>

  export type active_storage_variant_recordsSelectScalar = {
    id?: boolean
    blob_id?: boolean
    variation_digest?: boolean
  }

  export type active_storage_variant_recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blob_id" | "variation_digest", ExtArgs["result"]["active_storage_variant_records"]>
  export type active_storage_variant_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }
  export type active_storage_variant_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }
  export type active_storage_variant_recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    active_storage_blobs?: boolean | active_storage_blobsDefaultArgs<ExtArgs>
  }

  export type $active_storage_variant_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "active_storage_variant_records"
    objects: {
      active_storage_blobs: Prisma.$active_storage_blobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blob_id: string
      variation_digest: string
    }, ExtArgs["result"]["active_storage_variant_records"]>
    composites: {}
  }

  type active_storage_variant_recordsGetPayload<S extends boolean | null | undefined | active_storage_variant_recordsDefaultArgs> = $Result.GetResult<Prisma.$active_storage_variant_recordsPayload, S>

  type active_storage_variant_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<active_storage_variant_recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Active_storage_variant_recordsCountAggregateInputType | true
    }

  export interface active_storage_variant_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['active_storage_variant_records'], meta: { name: 'active_storage_variant_records' } }
    /**
     * Find zero or one Active_storage_variant_records that matches the filter.
     * @param {active_storage_variant_recordsFindUniqueArgs} args - Arguments to find a Active_storage_variant_records
     * @example
     * // Get one Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends active_storage_variant_recordsFindUniqueArgs>(args: SelectSubset<T, active_storage_variant_recordsFindUniqueArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Active_storage_variant_records that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {active_storage_variant_recordsFindUniqueOrThrowArgs} args - Arguments to find a Active_storage_variant_records
     * @example
     * // Get one Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends active_storage_variant_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, active_storage_variant_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_variant_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsFindFirstArgs} args - Arguments to find a Active_storage_variant_records
     * @example
     * // Get one Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends active_storage_variant_recordsFindFirstArgs>(args?: SelectSubset<T, active_storage_variant_recordsFindFirstArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Active_storage_variant_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsFindFirstOrThrowArgs} args - Arguments to find a Active_storage_variant_records
     * @example
     * // Get one Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends active_storage_variant_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, active_storage_variant_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Active_storage_variant_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findMany()
     * 
     * // Get first 10 Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const active_storage_variant_recordsWithIdOnly = await prisma.active_storage_variant_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends active_storage_variant_recordsFindManyArgs>(args?: SelectSubset<T, active_storage_variant_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Active_storage_variant_records.
     * @param {active_storage_variant_recordsCreateArgs} args - Arguments to create a Active_storage_variant_records.
     * @example
     * // Create one Active_storage_variant_records
     * const Active_storage_variant_records = await prisma.active_storage_variant_records.create({
     *   data: {
     *     // ... data to create a Active_storage_variant_records
     *   }
     * })
     * 
     */
    create<T extends active_storage_variant_recordsCreateArgs>(args: SelectSubset<T, active_storage_variant_recordsCreateArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Active_storage_variant_records.
     * @param {active_storage_variant_recordsCreateManyArgs} args - Arguments to create many Active_storage_variant_records.
     * @example
     * // Create many Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends active_storage_variant_recordsCreateManyArgs>(args?: SelectSubset<T, active_storage_variant_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Active_storage_variant_records and returns the data saved in the database.
     * @param {active_storage_variant_recordsCreateManyAndReturnArgs} args - Arguments to create many Active_storage_variant_records.
     * @example
     * // Create many Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Active_storage_variant_records and only return the `id`
     * const active_storage_variant_recordsWithIdOnly = await prisma.active_storage_variant_records.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends active_storage_variant_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, active_storage_variant_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Active_storage_variant_records.
     * @param {active_storage_variant_recordsDeleteArgs} args - Arguments to delete one Active_storage_variant_records.
     * @example
     * // Delete one Active_storage_variant_records
     * const Active_storage_variant_records = await prisma.active_storage_variant_records.delete({
     *   where: {
     *     // ... filter to delete one Active_storage_variant_records
     *   }
     * })
     * 
     */
    delete<T extends active_storage_variant_recordsDeleteArgs>(args: SelectSubset<T, active_storage_variant_recordsDeleteArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Active_storage_variant_records.
     * @param {active_storage_variant_recordsUpdateArgs} args - Arguments to update one Active_storage_variant_records.
     * @example
     * // Update one Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends active_storage_variant_recordsUpdateArgs>(args: SelectSubset<T, active_storage_variant_recordsUpdateArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Active_storage_variant_records.
     * @param {active_storage_variant_recordsDeleteManyArgs} args - Arguments to filter Active_storage_variant_records to delete.
     * @example
     * // Delete a few Active_storage_variant_records
     * const { count } = await prisma.active_storage_variant_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends active_storage_variant_recordsDeleteManyArgs>(args?: SelectSubset<T, active_storage_variant_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_variant_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends active_storage_variant_recordsUpdateManyArgs>(args: SelectSubset<T, active_storage_variant_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Active_storage_variant_records and returns the data updated in the database.
     * @param {active_storage_variant_recordsUpdateManyAndReturnArgs} args - Arguments to update many Active_storage_variant_records.
     * @example
     * // Update many Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Active_storage_variant_records and only return the `id`
     * const active_storage_variant_recordsWithIdOnly = await prisma.active_storage_variant_records.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends active_storage_variant_recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, active_storage_variant_recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Active_storage_variant_records.
     * @param {active_storage_variant_recordsUpsertArgs} args - Arguments to update or create a Active_storage_variant_records.
     * @example
     * // Update or create a Active_storage_variant_records
     * const active_storage_variant_records = await prisma.active_storage_variant_records.upsert({
     *   create: {
     *     // ... data to create a Active_storage_variant_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Active_storage_variant_records we want to update
     *   }
     * })
     */
    upsert<T extends active_storage_variant_recordsUpsertArgs>(args: SelectSubset<T, active_storage_variant_recordsUpsertArgs<ExtArgs>>): Prisma__active_storage_variant_recordsClient<$Result.GetResult<Prisma.$active_storage_variant_recordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Active_storage_variant_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsCountArgs} args - Arguments to filter Active_storage_variant_records to count.
     * @example
     * // Count the number of Active_storage_variant_records
     * const count = await prisma.active_storage_variant_records.count({
     *   where: {
     *     // ... the filter for the Active_storage_variant_records we want to count
     *   }
     * })
    **/
    count<T extends active_storage_variant_recordsCountArgs>(
      args?: Subset<T, active_storage_variant_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Active_storage_variant_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Active_storage_variant_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Active_storage_variant_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Active_storage_variant_recordsAggregateArgs>(args: Subset<T, Active_storage_variant_recordsAggregateArgs>): Prisma.PrismaPromise<GetActive_storage_variant_recordsAggregateType<T>>

    /**
     * Group by Active_storage_variant_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {active_storage_variant_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends active_storage_variant_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: active_storage_variant_recordsGroupByArgs['orderBy'] }
        : { orderBy?: active_storage_variant_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, active_storage_variant_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActive_storage_variant_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the active_storage_variant_records model
   */
  readonly fields: active_storage_variant_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for active_storage_variant_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__active_storage_variant_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    active_storage_blobs<T extends active_storage_blobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, active_storage_blobsDefaultArgs<ExtArgs>>): Prisma__active_storage_blobsClient<$Result.GetResult<Prisma.$active_storage_blobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the active_storage_variant_records model
   */
  interface active_storage_variant_recordsFieldRefs {
    readonly id: FieldRef<"active_storage_variant_records", 'String'>
    readonly blob_id: FieldRef<"active_storage_variant_records", 'String'>
    readonly variation_digest: FieldRef<"active_storage_variant_records", 'String'>
  }
    

  // Custom InputTypes
  /**
   * active_storage_variant_records findUnique
   */
  export type active_storage_variant_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_variant_records to fetch.
     */
    where: active_storage_variant_recordsWhereUniqueInput
  }

  /**
   * active_storage_variant_records findUniqueOrThrow
   */
  export type active_storage_variant_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_variant_records to fetch.
     */
    where: active_storage_variant_recordsWhereUniqueInput
  }

  /**
   * active_storage_variant_records findFirst
   */
  export type active_storage_variant_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_variant_records to fetch.
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_variant_records to fetch.
     */
    orderBy?: active_storage_variant_recordsOrderByWithRelationInput | active_storage_variant_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_variant_records.
     */
    cursor?: active_storage_variant_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_variant_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_variant_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_variant_records.
     */
    distinct?: Active_storage_variant_recordsScalarFieldEnum | Active_storage_variant_recordsScalarFieldEnum[]
  }

  /**
   * active_storage_variant_records findFirstOrThrow
   */
  export type active_storage_variant_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_variant_records to fetch.
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_variant_records to fetch.
     */
    orderBy?: active_storage_variant_recordsOrderByWithRelationInput | active_storage_variant_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for active_storage_variant_records.
     */
    cursor?: active_storage_variant_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_variant_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_variant_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of active_storage_variant_records.
     */
    distinct?: Active_storage_variant_recordsScalarFieldEnum | Active_storage_variant_recordsScalarFieldEnum[]
  }

  /**
   * active_storage_variant_records findMany
   */
  export type active_storage_variant_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter, which active_storage_variant_records to fetch.
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of active_storage_variant_records to fetch.
     */
    orderBy?: active_storage_variant_recordsOrderByWithRelationInput | active_storage_variant_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing active_storage_variant_records.
     */
    cursor?: active_storage_variant_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` active_storage_variant_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` active_storage_variant_records.
     */
    skip?: number
    distinct?: Active_storage_variant_recordsScalarFieldEnum | Active_storage_variant_recordsScalarFieldEnum[]
  }

  /**
   * active_storage_variant_records create
   */
  export type active_storage_variant_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a active_storage_variant_records.
     */
    data: XOR<active_storage_variant_recordsCreateInput, active_storage_variant_recordsUncheckedCreateInput>
  }

  /**
   * active_storage_variant_records createMany
   */
  export type active_storage_variant_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many active_storage_variant_records.
     */
    data: active_storage_variant_recordsCreateManyInput | active_storage_variant_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * active_storage_variant_records createManyAndReturn
   */
  export type active_storage_variant_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * The data used to create many active_storage_variant_records.
     */
    data: active_storage_variant_recordsCreateManyInput | active_storage_variant_recordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * active_storage_variant_records update
   */
  export type active_storage_variant_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a active_storage_variant_records.
     */
    data: XOR<active_storage_variant_recordsUpdateInput, active_storage_variant_recordsUncheckedUpdateInput>
    /**
     * Choose, which active_storage_variant_records to update.
     */
    where: active_storage_variant_recordsWhereUniqueInput
  }

  /**
   * active_storage_variant_records updateMany
   */
  export type active_storage_variant_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update active_storage_variant_records.
     */
    data: XOR<active_storage_variant_recordsUpdateManyMutationInput, active_storage_variant_recordsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_variant_records to update
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * Limit how many active_storage_variant_records to update.
     */
    limit?: number
  }

  /**
   * active_storage_variant_records updateManyAndReturn
   */
  export type active_storage_variant_recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * The data used to update active_storage_variant_records.
     */
    data: XOR<active_storage_variant_recordsUpdateManyMutationInput, active_storage_variant_recordsUncheckedUpdateManyInput>
    /**
     * Filter which active_storage_variant_records to update
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * Limit how many active_storage_variant_records to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * active_storage_variant_records upsert
   */
  export type active_storage_variant_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the active_storage_variant_records to update in case it exists.
     */
    where: active_storage_variant_recordsWhereUniqueInput
    /**
     * In case the active_storage_variant_records found by the `where` argument doesn't exist, create a new active_storage_variant_records with this data.
     */
    create: XOR<active_storage_variant_recordsCreateInput, active_storage_variant_recordsUncheckedCreateInput>
    /**
     * In case the active_storage_variant_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<active_storage_variant_recordsUpdateInput, active_storage_variant_recordsUncheckedUpdateInput>
  }

  /**
   * active_storage_variant_records delete
   */
  export type active_storage_variant_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
    /**
     * Filter which active_storage_variant_records to delete.
     */
    where: active_storage_variant_recordsWhereUniqueInput
  }

  /**
   * active_storage_variant_records deleteMany
   */
  export type active_storage_variant_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which active_storage_variant_records to delete
     */
    where?: active_storage_variant_recordsWhereInput
    /**
     * Limit how many active_storage_variant_records to delete.
     */
    limit?: number
  }

  /**
   * active_storage_variant_records without action
   */
  export type active_storage_variant_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the active_storage_variant_records
     */
    select?: active_storage_variant_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the active_storage_variant_records
     */
    omit?: active_storage_variant_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: active_storage_variant_recordsInclude<ExtArgs> | null
  }


  /**
   * Model addresses
   */

  export type AggregateAddresses = {
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  export type AddressesAvgAggregateOutputType = {
    postal_code: number | null
  }

  export type AddressesSumAggregateOutputType = {
    postal_code: number | null
  }

  export type AddressesMinAggregateOutputType = {
    id: string | null
    addressable_type: string | null
    addressable_id: string | null
    line1: string | null
    line2: string | null
    county: string | null
    locality: string | null
    region: string | null
    country: string | null
    postal_code: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AddressesMaxAggregateOutputType = {
    id: string | null
    addressable_type: string | null
    addressable_id: string | null
    line1: string | null
    line2: string | null
    county: string | null
    locality: string | null
    region: string | null
    country: string | null
    postal_code: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AddressesCountAggregateOutputType = {
    id: number
    addressable_type: number
    addressable_id: number
    line1: number
    line2: number
    county: number
    locality: number
    region: number
    country: number
    postal_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AddressesAvgAggregateInputType = {
    postal_code?: true
  }

  export type AddressesSumAggregateInputType = {
    postal_code?: true
  }

  export type AddressesMinAggregateInputType = {
    id?: true
    addressable_type?: true
    addressable_id?: true
    line1?: true
    line2?: true
    county?: true
    locality?: true
    region?: true
    country?: true
    postal_code?: true
    created_at?: true
    updated_at?: true
  }

  export type AddressesMaxAggregateInputType = {
    id?: true
    addressable_type?: true
    addressable_id?: true
    line1?: true
    line2?: true
    county?: true
    locality?: true
    region?: true
    country?: true
    postal_code?: true
    created_at?: true
    updated_at?: true
  }

  export type AddressesCountAggregateInputType = {
    id?: true
    addressable_type?: true
    addressable_id?: true
    line1?: true
    line2?: true
    county?: true
    locality?: true
    region?: true
    country?: true
    postal_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AddressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which addresses to aggregate.
     */
    where?: addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressesOrderByWithRelationInput | addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned addresses
    **/
    _count?: true | AddressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressesMaxAggregateInputType
  }

  export type GetAddressesAggregateType<T extends AddressesAggregateArgs> = {
        [P in keyof T & keyof AggregateAddresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddresses[P]>
      : GetScalarType<T[P], AggregateAddresses[P]>
  }




  export type addressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressesWhereInput
    orderBy?: addressesOrderByWithAggregationInput | addressesOrderByWithAggregationInput[]
    by: AddressesScalarFieldEnum[] | AddressesScalarFieldEnum
    having?: addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressesCountAggregateInputType | true
    _avg?: AddressesAvgAggregateInputType
    _sum?: AddressesSumAggregateInputType
    _min?: AddressesMinAggregateInputType
    _max?: AddressesMaxAggregateInputType
  }

  export type AddressesGroupByOutputType = {
    id: string
    addressable_type: string | null
    addressable_id: string | null
    line1: string | null
    line2: string | null
    county: string | null
    locality: string | null
    region: string | null
    country: string | null
    postal_code: number | null
    created_at: Date
    updated_at: Date
    _count: AddressesCountAggregateOutputType | null
    _avg: AddressesAvgAggregateOutputType | null
    _sum: AddressesSumAggregateOutputType | null
    _min: AddressesMinAggregateOutputType | null
    _max: AddressesMaxAggregateOutputType | null
  }

  type GetAddressesGroupByPayload<T extends addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressesGroupByOutputType[P]>
            : GetScalarType<T[P], AddressesGroupByOutputType[P]>
        }
      >
    >


  export type addressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressable_type?: boolean
    addressable_id?: boolean
    line1?: boolean
    line2?: boolean
    county?: boolean
    locality?: boolean
    region?: boolean
    country?: boolean
    postal_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["addresses"]>

  export type addressesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressable_type?: boolean
    addressable_id?: boolean
    line1?: boolean
    line2?: boolean
    county?: boolean
    locality?: boolean
    region?: boolean
    country?: boolean
    postal_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["addresses"]>

  export type addressesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    addressable_type?: boolean
    addressable_id?: boolean
    line1?: boolean
    line2?: boolean
    county?: boolean
    locality?: boolean
    region?: boolean
    country?: boolean
    postal_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["addresses"]>

  export type addressesSelectScalar = {
    id?: boolean
    addressable_type?: boolean
    addressable_id?: boolean
    line1?: boolean
    line2?: boolean
    county?: boolean
    locality?: boolean
    region?: boolean
    country?: boolean
    postal_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type addressesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "addressable_type" | "addressable_id" | "line1" | "line2" | "county" | "locality" | "region" | "country" | "postal_code" | "created_at" | "updated_at", ExtArgs["result"]["addresses"]>

  export type $addressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "addresses"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      addressable_type: string | null
      addressable_id: string | null
      line1: string | null
      line2: string | null
      county: string | null
      locality: string | null
      region: string | null
      country: string | null
      postal_code: number | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["addresses"]>
    composites: {}
  }

  type addressesGetPayload<S extends boolean | null | undefined | addressesDefaultArgs> = $Result.GetResult<Prisma.$addressesPayload, S>

  type addressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<addressesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressesCountAggregateInputType | true
    }

  export interface addressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['addresses'], meta: { name: 'addresses' } }
    /**
     * Find zero or one Addresses that matches the filter.
     * @param {addressesFindUniqueArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends addressesFindUniqueArgs>(args: SelectSubset<T, addressesFindUniqueArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Addresses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {addressesFindUniqueOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends addressesFindUniqueOrThrowArgs>(args: SelectSubset<T, addressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesFindFirstArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends addressesFindFirstArgs>(args?: SelectSubset<T, addressesFindFirstArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesFindFirstOrThrowArgs} args - Arguments to find a Addresses
     * @example
     * // Get one Addresses
     * const addresses = await prisma.addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends addressesFindFirstOrThrowArgs>(args?: SelectSubset<T, addressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.addresses.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressesWithIdOnly = await prisma.addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends addressesFindManyArgs>(args?: SelectSubset<T, addressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Addresses.
     * @param {addressesCreateArgs} args - Arguments to create a Addresses.
     * @example
     * // Create one Addresses
     * const Addresses = await prisma.addresses.create({
     *   data: {
     *     // ... data to create a Addresses
     *   }
     * })
     * 
     */
    create<T extends addressesCreateArgs>(args: SelectSubset<T, addressesCreateArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {addressesCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const addresses = await prisma.addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends addressesCreateManyArgs>(args?: SelectSubset<T, addressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {addressesCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const addresses = await prisma.addresses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressesWithIdOnly = await prisma.addresses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends addressesCreateManyAndReturnArgs>(args?: SelectSubset<T, addressesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Addresses.
     * @param {addressesDeleteArgs} args - Arguments to delete one Addresses.
     * @example
     * // Delete one Addresses
     * const Addresses = await prisma.addresses.delete({
     *   where: {
     *     // ... filter to delete one Addresses
     *   }
     * })
     * 
     */
    delete<T extends addressesDeleteArgs>(args: SelectSubset<T, addressesDeleteArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Addresses.
     * @param {addressesUpdateArgs} args - Arguments to update one Addresses.
     * @example
     * // Update one Addresses
     * const addresses = await prisma.addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends addressesUpdateArgs>(args: SelectSubset<T, addressesUpdateArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {addressesDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends addressesDeleteManyArgs>(args?: SelectSubset<T, addressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends addressesUpdateManyArgs>(args: SelectSubset<T, addressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {addressesUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const addresses = await prisma.addresses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressesWithIdOnly = await prisma.addresses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends addressesUpdateManyAndReturnArgs>(args: SelectSubset<T, addressesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Addresses.
     * @param {addressesUpsertArgs} args - Arguments to update or create a Addresses.
     * @example
     * // Update or create a Addresses
     * const addresses = await prisma.addresses.upsert({
     *   create: {
     *     // ... data to create a Addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addresses we want to update
     *   }
     * })
     */
    upsert<T extends addressesUpsertArgs>(args: SelectSubset<T, addressesUpsertArgs<ExtArgs>>): Prisma__addressesClient<$Result.GetResult<Prisma.$addressesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.addresses.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends addressesCountArgs>(
      args?: Subset<T, addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressesAggregateArgs>(args: Subset<T, AddressesAggregateArgs>): Prisma.PrismaPromise<GetAddressesAggregateType<T>>

    /**
     * Group by Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: addressesGroupByArgs['orderBy'] }
        : { orderBy?: addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the addresses model
   */
  readonly fields: addressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__addressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the addresses model
   */
  interface addressesFieldRefs {
    readonly id: FieldRef<"addresses", 'String'>
    readonly addressable_type: FieldRef<"addresses", 'String'>
    readonly addressable_id: FieldRef<"addresses", 'String'>
    readonly line1: FieldRef<"addresses", 'String'>
    readonly line2: FieldRef<"addresses", 'String'>
    readonly county: FieldRef<"addresses", 'String'>
    readonly locality: FieldRef<"addresses", 'String'>
    readonly region: FieldRef<"addresses", 'String'>
    readonly country: FieldRef<"addresses", 'String'>
    readonly postal_code: FieldRef<"addresses", 'Int'>
    readonly created_at: FieldRef<"addresses", 'DateTime'>
    readonly updated_at: FieldRef<"addresses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * addresses findUnique
   */
  export type addressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where: addressesWhereUniqueInput
  }

  /**
   * addresses findUniqueOrThrow
   */
  export type addressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where: addressesWhereUniqueInput
  }

  /**
   * addresses findFirst
   */
  export type addressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressesOrderByWithRelationInput | addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * addresses findFirstOrThrow
   */
  export type addressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressesOrderByWithRelationInput | addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * addresses findMany
   */
  export type addressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressesOrderByWithRelationInput | addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing addresses.
     */
    cursor?: addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    distinct?: AddressesScalarFieldEnum | AddressesScalarFieldEnum[]
  }

  /**
   * addresses create
   */
  export type addressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * The data needed to create a addresses.
     */
    data: XOR<addressesCreateInput, addressesUncheckedCreateInput>
  }

  /**
   * addresses createMany
   */
  export type addressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many addresses.
     */
    data: addressesCreateManyInput | addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * addresses createManyAndReturn
   */
  export type addressesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * The data used to create many addresses.
     */
    data: addressesCreateManyInput | addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * addresses update
   */
  export type addressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * The data needed to update a addresses.
     */
    data: XOR<addressesUpdateInput, addressesUncheckedUpdateInput>
    /**
     * Choose, which addresses to update.
     */
    where: addressesWhereUniqueInput
  }

  /**
   * addresses updateMany
   */
  export type addressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update addresses.
     */
    data: XOR<addressesUpdateManyMutationInput, addressesUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressesWhereInput
    /**
     * Limit how many addresses to update.
     */
    limit?: number
  }

  /**
   * addresses updateManyAndReturn
   */
  export type addressesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * The data used to update addresses.
     */
    data: XOR<addressesUpdateManyMutationInput, addressesUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressesWhereInput
    /**
     * Limit how many addresses to update.
     */
    limit?: number
  }

  /**
   * addresses upsert
   */
  export type addressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * The filter to search for the addresses to update in case it exists.
     */
    where: addressesWhereUniqueInput
    /**
     * In case the addresses found by the `where` argument doesn't exist, create a new addresses with this data.
     */
    create: XOR<addressesCreateInput, addressesUncheckedCreateInput>
    /**
     * In case the addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<addressesUpdateInput, addressesUncheckedUpdateInput>
  }

  /**
   * addresses delete
   */
  export type addressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
    /**
     * Filter which addresses to delete.
     */
    where: addressesWhereUniqueInput
  }

  /**
   * addresses deleteMany
   */
  export type addressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which addresses to delete
     */
    where?: addressesWhereInput
    /**
     * Limit how many addresses to delete.
     */
    limit?: number
  }

  /**
   * addresses without action
   */
  export type addressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the addresses
     */
    select?: addressesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the addresses
     */
    omit?: addressesOmit<ExtArgs> | null
  }


  /**
   * Model ar_internal_metadata
   */

  export type AggregateAr_internal_metadata = {
    _count: Ar_internal_metadataCountAggregateOutputType | null
    _min: Ar_internal_metadataMinAggregateOutputType | null
    _max: Ar_internal_metadataMaxAggregateOutputType | null
  }

  export type Ar_internal_metadataMinAggregateOutputType = {
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ar_internal_metadataMaxAggregateOutputType = {
    key: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Ar_internal_metadataCountAggregateOutputType = {
    key: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Ar_internal_metadataMinAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Ar_internal_metadataMaxAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Ar_internal_metadataCountAggregateInputType = {
    key?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Ar_internal_metadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ar_internal_metadata to aggregate.
     */
    where?: ar_internal_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ar_internal_metadata to fetch.
     */
    orderBy?: ar_internal_metadataOrderByWithRelationInput | ar_internal_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ar_internal_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ar_internal_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ar_internal_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ar_internal_metadata
    **/
    _count?: true | Ar_internal_metadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ar_internal_metadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ar_internal_metadataMaxAggregateInputType
  }

  export type GetAr_internal_metadataAggregateType<T extends Ar_internal_metadataAggregateArgs> = {
        [P in keyof T & keyof AggregateAr_internal_metadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAr_internal_metadata[P]>
      : GetScalarType<T[P], AggregateAr_internal_metadata[P]>
  }




  export type ar_internal_metadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ar_internal_metadataWhereInput
    orderBy?: ar_internal_metadataOrderByWithAggregationInput | ar_internal_metadataOrderByWithAggregationInput[]
    by: Ar_internal_metadataScalarFieldEnum[] | Ar_internal_metadataScalarFieldEnum
    having?: ar_internal_metadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ar_internal_metadataCountAggregateInputType | true
    _min?: Ar_internal_metadataMinAggregateInputType
    _max?: Ar_internal_metadataMaxAggregateInputType
  }

  export type Ar_internal_metadataGroupByOutputType = {
    key: string
    value: string | null
    created_at: Date
    updated_at: Date
    _count: Ar_internal_metadataCountAggregateOutputType | null
    _min: Ar_internal_metadataMinAggregateOutputType | null
    _max: Ar_internal_metadataMaxAggregateOutputType | null
  }

  type GetAr_internal_metadataGroupByPayload<T extends ar_internal_metadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ar_internal_metadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ar_internal_metadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ar_internal_metadataGroupByOutputType[P]>
            : GetScalarType<T[P], Ar_internal_metadataGroupByOutputType[P]>
        }
      >
    >


  export type ar_internal_metadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ar_internal_metadata"]>

  export type ar_internal_metadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ar_internal_metadata"]>

  export type ar_internal_metadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["ar_internal_metadata"]>

  export type ar_internal_metadataSelectScalar = {
    key?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ar_internal_metadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "created_at" | "updated_at", ExtArgs["result"]["ar_internal_metadata"]>

  export type $ar_internal_metadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ar_internal_metadata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["ar_internal_metadata"]>
    composites: {}
  }

  type ar_internal_metadataGetPayload<S extends boolean | null | undefined | ar_internal_metadataDefaultArgs> = $Result.GetResult<Prisma.$ar_internal_metadataPayload, S>

  type ar_internal_metadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ar_internal_metadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ar_internal_metadataCountAggregateInputType | true
    }

  export interface ar_internal_metadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ar_internal_metadata'], meta: { name: 'ar_internal_metadata' } }
    /**
     * Find zero or one Ar_internal_metadata that matches the filter.
     * @param {ar_internal_metadataFindUniqueArgs} args - Arguments to find a Ar_internal_metadata
     * @example
     * // Get one Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ar_internal_metadataFindUniqueArgs>(args: SelectSubset<T, ar_internal_metadataFindUniqueArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ar_internal_metadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ar_internal_metadataFindUniqueOrThrowArgs} args - Arguments to find a Ar_internal_metadata
     * @example
     * // Get one Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ar_internal_metadataFindUniqueOrThrowArgs>(args: SelectSubset<T, ar_internal_metadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ar_internal_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataFindFirstArgs} args - Arguments to find a Ar_internal_metadata
     * @example
     * // Get one Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ar_internal_metadataFindFirstArgs>(args?: SelectSubset<T, ar_internal_metadataFindFirstArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ar_internal_metadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataFindFirstOrThrowArgs} args - Arguments to find a Ar_internal_metadata
     * @example
     * // Get one Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ar_internal_metadataFindFirstOrThrowArgs>(args?: SelectSubset<T, ar_internal_metadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ar_internal_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findMany()
     * 
     * // Get first 10 Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const ar_internal_metadataWithKeyOnly = await prisma.ar_internal_metadata.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends ar_internal_metadataFindManyArgs>(args?: SelectSubset<T, ar_internal_metadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ar_internal_metadata.
     * @param {ar_internal_metadataCreateArgs} args - Arguments to create a Ar_internal_metadata.
     * @example
     * // Create one Ar_internal_metadata
     * const Ar_internal_metadata = await prisma.ar_internal_metadata.create({
     *   data: {
     *     // ... data to create a Ar_internal_metadata
     *   }
     * })
     * 
     */
    create<T extends ar_internal_metadataCreateArgs>(args: SelectSubset<T, ar_internal_metadataCreateArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ar_internal_metadata.
     * @param {ar_internal_metadataCreateManyArgs} args - Arguments to create many Ar_internal_metadata.
     * @example
     * // Create many Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ar_internal_metadataCreateManyArgs>(args?: SelectSubset<T, ar_internal_metadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ar_internal_metadata and returns the data saved in the database.
     * @param {ar_internal_metadataCreateManyAndReturnArgs} args - Arguments to create many Ar_internal_metadata.
     * @example
     * // Create many Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ar_internal_metadata and only return the `key`
     * const ar_internal_metadataWithKeyOnly = await prisma.ar_internal_metadata.createManyAndReturn({
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ar_internal_metadataCreateManyAndReturnArgs>(args?: SelectSubset<T, ar_internal_metadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ar_internal_metadata.
     * @param {ar_internal_metadataDeleteArgs} args - Arguments to delete one Ar_internal_metadata.
     * @example
     * // Delete one Ar_internal_metadata
     * const Ar_internal_metadata = await prisma.ar_internal_metadata.delete({
     *   where: {
     *     // ... filter to delete one Ar_internal_metadata
     *   }
     * })
     * 
     */
    delete<T extends ar_internal_metadataDeleteArgs>(args: SelectSubset<T, ar_internal_metadataDeleteArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ar_internal_metadata.
     * @param {ar_internal_metadataUpdateArgs} args - Arguments to update one Ar_internal_metadata.
     * @example
     * // Update one Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ar_internal_metadataUpdateArgs>(args: SelectSubset<T, ar_internal_metadataUpdateArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ar_internal_metadata.
     * @param {ar_internal_metadataDeleteManyArgs} args - Arguments to filter Ar_internal_metadata to delete.
     * @example
     * // Delete a few Ar_internal_metadata
     * const { count } = await prisma.ar_internal_metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ar_internal_metadataDeleteManyArgs>(args?: SelectSubset<T, ar_internal_metadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ar_internal_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ar_internal_metadataUpdateManyArgs>(args: SelectSubset<T, ar_internal_metadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ar_internal_metadata and returns the data updated in the database.
     * @param {ar_internal_metadataUpdateManyAndReturnArgs} args - Arguments to update many Ar_internal_metadata.
     * @example
     * // Update many Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ar_internal_metadata and only return the `key`
     * const ar_internal_metadataWithKeyOnly = await prisma.ar_internal_metadata.updateManyAndReturn({
     *   select: { key: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ar_internal_metadataUpdateManyAndReturnArgs>(args: SelectSubset<T, ar_internal_metadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ar_internal_metadata.
     * @param {ar_internal_metadataUpsertArgs} args - Arguments to update or create a Ar_internal_metadata.
     * @example
     * // Update or create a Ar_internal_metadata
     * const ar_internal_metadata = await prisma.ar_internal_metadata.upsert({
     *   create: {
     *     // ... data to create a Ar_internal_metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ar_internal_metadata we want to update
     *   }
     * })
     */
    upsert<T extends ar_internal_metadataUpsertArgs>(args: SelectSubset<T, ar_internal_metadataUpsertArgs<ExtArgs>>): Prisma__ar_internal_metadataClient<$Result.GetResult<Prisma.$ar_internal_metadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ar_internal_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataCountArgs} args - Arguments to filter Ar_internal_metadata to count.
     * @example
     * // Count the number of Ar_internal_metadata
     * const count = await prisma.ar_internal_metadata.count({
     *   where: {
     *     // ... the filter for the Ar_internal_metadata we want to count
     *   }
     * })
    **/
    count<T extends ar_internal_metadataCountArgs>(
      args?: Subset<T, ar_internal_metadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ar_internal_metadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ar_internal_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ar_internal_metadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ar_internal_metadataAggregateArgs>(args: Subset<T, Ar_internal_metadataAggregateArgs>): Prisma.PrismaPromise<GetAr_internal_metadataAggregateType<T>>

    /**
     * Group by Ar_internal_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ar_internal_metadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ar_internal_metadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ar_internal_metadataGroupByArgs['orderBy'] }
        : { orderBy?: ar_internal_metadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ar_internal_metadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAr_internal_metadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ar_internal_metadata model
   */
  readonly fields: ar_internal_metadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ar_internal_metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ar_internal_metadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ar_internal_metadata model
   */
  interface ar_internal_metadataFieldRefs {
    readonly key: FieldRef<"ar_internal_metadata", 'String'>
    readonly value: FieldRef<"ar_internal_metadata", 'String'>
    readonly created_at: FieldRef<"ar_internal_metadata", 'DateTime'>
    readonly updated_at: FieldRef<"ar_internal_metadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ar_internal_metadata findUnique
   */
  export type ar_internal_metadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter, which ar_internal_metadata to fetch.
     */
    where: ar_internal_metadataWhereUniqueInput
  }

  /**
   * ar_internal_metadata findUniqueOrThrow
   */
  export type ar_internal_metadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter, which ar_internal_metadata to fetch.
     */
    where: ar_internal_metadataWhereUniqueInput
  }

  /**
   * ar_internal_metadata findFirst
   */
  export type ar_internal_metadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter, which ar_internal_metadata to fetch.
     */
    where?: ar_internal_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ar_internal_metadata to fetch.
     */
    orderBy?: ar_internal_metadataOrderByWithRelationInput | ar_internal_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ar_internal_metadata.
     */
    cursor?: ar_internal_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ar_internal_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ar_internal_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ar_internal_metadata.
     */
    distinct?: Ar_internal_metadataScalarFieldEnum | Ar_internal_metadataScalarFieldEnum[]
  }

  /**
   * ar_internal_metadata findFirstOrThrow
   */
  export type ar_internal_metadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter, which ar_internal_metadata to fetch.
     */
    where?: ar_internal_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ar_internal_metadata to fetch.
     */
    orderBy?: ar_internal_metadataOrderByWithRelationInput | ar_internal_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ar_internal_metadata.
     */
    cursor?: ar_internal_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ar_internal_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ar_internal_metadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ar_internal_metadata.
     */
    distinct?: Ar_internal_metadataScalarFieldEnum | Ar_internal_metadataScalarFieldEnum[]
  }

  /**
   * ar_internal_metadata findMany
   */
  export type ar_internal_metadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter, which ar_internal_metadata to fetch.
     */
    where?: ar_internal_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ar_internal_metadata to fetch.
     */
    orderBy?: ar_internal_metadataOrderByWithRelationInput | ar_internal_metadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ar_internal_metadata.
     */
    cursor?: ar_internal_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ar_internal_metadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ar_internal_metadata.
     */
    skip?: number
    distinct?: Ar_internal_metadataScalarFieldEnum | Ar_internal_metadataScalarFieldEnum[]
  }

  /**
   * ar_internal_metadata create
   */
  export type ar_internal_metadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * The data needed to create a ar_internal_metadata.
     */
    data: XOR<ar_internal_metadataCreateInput, ar_internal_metadataUncheckedCreateInput>
  }

  /**
   * ar_internal_metadata createMany
   */
  export type ar_internal_metadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ar_internal_metadata.
     */
    data: ar_internal_metadataCreateManyInput | ar_internal_metadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ar_internal_metadata createManyAndReturn
   */
  export type ar_internal_metadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * The data used to create many ar_internal_metadata.
     */
    data: ar_internal_metadataCreateManyInput | ar_internal_metadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ar_internal_metadata update
   */
  export type ar_internal_metadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * The data needed to update a ar_internal_metadata.
     */
    data: XOR<ar_internal_metadataUpdateInput, ar_internal_metadataUncheckedUpdateInput>
    /**
     * Choose, which ar_internal_metadata to update.
     */
    where: ar_internal_metadataWhereUniqueInput
  }

  /**
   * ar_internal_metadata updateMany
   */
  export type ar_internal_metadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ar_internal_metadata.
     */
    data: XOR<ar_internal_metadataUpdateManyMutationInput, ar_internal_metadataUncheckedUpdateManyInput>
    /**
     * Filter which ar_internal_metadata to update
     */
    where?: ar_internal_metadataWhereInput
    /**
     * Limit how many ar_internal_metadata to update.
     */
    limit?: number
  }

  /**
   * ar_internal_metadata updateManyAndReturn
   */
  export type ar_internal_metadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * The data used to update ar_internal_metadata.
     */
    data: XOR<ar_internal_metadataUpdateManyMutationInput, ar_internal_metadataUncheckedUpdateManyInput>
    /**
     * Filter which ar_internal_metadata to update
     */
    where?: ar_internal_metadataWhereInput
    /**
     * Limit how many ar_internal_metadata to update.
     */
    limit?: number
  }

  /**
   * ar_internal_metadata upsert
   */
  export type ar_internal_metadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * The filter to search for the ar_internal_metadata to update in case it exists.
     */
    where: ar_internal_metadataWhereUniqueInput
    /**
     * In case the ar_internal_metadata found by the `where` argument doesn't exist, create a new ar_internal_metadata with this data.
     */
    create: XOR<ar_internal_metadataCreateInput, ar_internal_metadataUncheckedCreateInput>
    /**
     * In case the ar_internal_metadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ar_internal_metadataUpdateInput, ar_internal_metadataUncheckedUpdateInput>
  }

  /**
   * ar_internal_metadata delete
   */
  export type ar_internal_metadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
    /**
     * Filter which ar_internal_metadata to delete.
     */
    where: ar_internal_metadataWhereUniqueInput
  }

  /**
   * ar_internal_metadata deleteMany
   */
  export type ar_internal_metadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ar_internal_metadata to delete
     */
    where?: ar_internal_metadataWhereInput
    /**
     * Limit how many ar_internal_metadata to delete.
     */
    limit?: number
  }

  /**
   * ar_internal_metadata without action
   */
  export type ar_internal_metadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ar_internal_metadata
     */
    select?: ar_internal_metadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ar_internal_metadata
     */
    omit?: ar_internal_metadataOmit<ExtArgs> | null
  }


  /**
   * Model balances
   */

  export type AggregateBalances = {
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  export type BalancesAvgAggregateOutputType = {
    balance: Decimal | null
    cash_balance: Decimal | null
  }

  export type BalancesSumAggregateOutputType = {
    balance: Decimal | null
    cash_balance: Decimal | null
  }

  export type BalancesMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    date: Date | null
    balance: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    cash_balance: Decimal | null
  }

  export type BalancesMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    date: Date | null
    balance: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    cash_balance: Decimal | null
  }

  export type BalancesCountAggregateOutputType = {
    id: number
    account_id: number
    date: number
    balance: number
    currency: number
    created_at: number
    updated_at: number
    cash_balance: number
    _all: number
  }


  export type BalancesAvgAggregateInputType = {
    balance?: true
    cash_balance?: true
  }

  export type BalancesSumAggregateInputType = {
    balance?: true
    cash_balance?: true
  }

  export type BalancesMinAggregateInputType = {
    id?: true
    account_id?: true
    date?: true
    balance?: true
    currency?: true
    created_at?: true
    updated_at?: true
    cash_balance?: true
  }

  export type BalancesMaxAggregateInputType = {
    id?: true
    account_id?: true
    date?: true
    balance?: true
    currency?: true
    created_at?: true
    updated_at?: true
    cash_balance?: true
  }

  export type BalancesCountAggregateInputType = {
    id?: true
    account_id?: true
    date?: true
    balance?: true
    currency?: true
    created_at?: true
    updated_at?: true
    cash_balance?: true
    _all?: true
  }

  export type BalancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balances to aggregate.
     */
    where?: balancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balances to fetch.
     */
    orderBy?: balancesOrderByWithRelationInput | balancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: balancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned balances
    **/
    _count?: true | BalancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BalancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BalancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BalancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BalancesMaxAggregateInputType
  }

  export type GetBalancesAggregateType<T extends BalancesAggregateArgs> = {
        [P in keyof T & keyof AggregateBalances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBalances[P]>
      : GetScalarType<T[P], AggregateBalances[P]>
  }




  export type balancesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: balancesWhereInput
    orderBy?: balancesOrderByWithAggregationInput | balancesOrderByWithAggregationInput[]
    by: BalancesScalarFieldEnum[] | BalancesScalarFieldEnum
    having?: balancesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BalancesCountAggregateInputType | true
    _avg?: BalancesAvgAggregateInputType
    _sum?: BalancesSumAggregateInputType
    _min?: BalancesMinAggregateInputType
    _max?: BalancesMaxAggregateInputType
  }

  export type BalancesGroupByOutputType = {
    id: string
    account_id: string
    date: Date
    balance: Decimal
    currency: string
    created_at: Date
    updated_at: Date
    cash_balance: Decimal | null
    _count: BalancesCountAggregateOutputType | null
    _avg: BalancesAvgAggregateOutputType | null
    _sum: BalancesSumAggregateOutputType | null
    _min: BalancesMinAggregateOutputType | null
    _max: BalancesMaxAggregateOutputType | null
  }

  type GetBalancesGroupByPayload<T extends balancesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BalancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BalancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BalancesGroupByOutputType[P]>
            : GetScalarType<T[P], BalancesGroupByOutputType[P]>
        }
      >
    >


  export type balancesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    date?: boolean
    balance?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    cash_balance?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balances"]>

  export type balancesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    date?: boolean
    balance?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    cash_balance?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balances"]>

  export type balancesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    date?: boolean
    balance?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    cash_balance?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["balances"]>

  export type balancesSelectScalar = {
    id?: boolean
    account_id?: boolean
    date?: boolean
    balance?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    cash_balance?: boolean
  }

  export type balancesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "date" | "balance" | "currency" | "created_at" | "updated_at" | "cash_balance", ExtArgs["result"]["balances"]>
  export type balancesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type balancesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type balancesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $balancesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "balances"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      date: Date
      balance: Prisma.Decimal
      currency: string
      created_at: Date
      updated_at: Date
      cash_balance: Prisma.Decimal | null
    }, ExtArgs["result"]["balances"]>
    composites: {}
  }

  type balancesGetPayload<S extends boolean | null | undefined | balancesDefaultArgs> = $Result.GetResult<Prisma.$balancesPayload, S>

  type balancesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<balancesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BalancesCountAggregateInputType | true
    }

  export interface balancesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['balances'], meta: { name: 'balances' } }
    /**
     * Find zero or one Balances that matches the filter.
     * @param {balancesFindUniqueArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends balancesFindUniqueArgs>(args: SelectSubset<T, balancesFindUniqueArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Balances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {balancesFindUniqueOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends balancesFindUniqueOrThrowArgs>(args: SelectSubset<T, balancesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesFindFirstArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends balancesFindFirstArgs>(args?: SelectSubset<T, balancesFindFirstArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Balances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesFindFirstOrThrowArgs} args - Arguments to find a Balances
     * @example
     * // Get one Balances
     * const balances = await prisma.balances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends balancesFindFirstOrThrowArgs>(args?: SelectSubset<T, balancesFindFirstOrThrowArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Balances
     * const balances = await prisma.balances.findMany()
     * 
     * // Get first 10 Balances
     * const balances = await prisma.balances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const balancesWithIdOnly = await prisma.balances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends balancesFindManyArgs>(args?: SelectSubset<T, balancesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Balances.
     * @param {balancesCreateArgs} args - Arguments to create a Balances.
     * @example
     * // Create one Balances
     * const Balances = await prisma.balances.create({
     *   data: {
     *     // ... data to create a Balances
     *   }
     * })
     * 
     */
    create<T extends balancesCreateArgs>(args: SelectSubset<T, balancesCreateArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Balances.
     * @param {balancesCreateManyArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balances = await prisma.balances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends balancesCreateManyArgs>(args?: SelectSubset<T, balancesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Balances and returns the data saved in the database.
     * @param {balancesCreateManyAndReturnArgs} args - Arguments to create many Balances.
     * @example
     * // Create many Balances
     * const balances = await prisma.balances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Balances and only return the `id`
     * const balancesWithIdOnly = await prisma.balances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends balancesCreateManyAndReturnArgs>(args?: SelectSubset<T, balancesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Balances.
     * @param {balancesDeleteArgs} args - Arguments to delete one Balances.
     * @example
     * // Delete one Balances
     * const Balances = await prisma.balances.delete({
     *   where: {
     *     // ... filter to delete one Balances
     *   }
     * })
     * 
     */
    delete<T extends balancesDeleteArgs>(args: SelectSubset<T, balancesDeleteArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Balances.
     * @param {balancesUpdateArgs} args - Arguments to update one Balances.
     * @example
     * // Update one Balances
     * const balances = await prisma.balances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends balancesUpdateArgs>(args: SelectSubset<T, balancesUpdateArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Balances.
     * @param {balancesDeleteManyArgs} args - Arguments to filter Balances to delete.
     * @example
     * // Delete a few Balances
     * const { count } = await prisma.balances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends balancesDeleteManyArgs>(args?: SelectSubset<T, balancesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Balances
     * const balances = await prisma.balances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends balancesUpdateManyArgs>(args: SelectSubset<T, balancesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Balances and returns the data updated in the database.
     * @param {balancesUpdateManyAndReturnArgs} args - Arguments to update many Balances.
     * @example
     * // Update many Balances
     * const balances = await prisma.balances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Balances and only return the `id`
     * const balancesWithIdOnly = await prisma.balances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends balancesUpdateManyAndReturnArgs>(args: SelectSubset<T, balancesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Balances.
     * @param {balancesUpsertArgs} args - Arguments to update or create a Balances.
     * @example
     * // Update or create a Balances
     * const balances = await prisma.balances.upsert({
     *   create: {
     *     // ... data to create a Balances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Balances we want to update
     *   }
     * })
     */
    upsert<T extends balancesUpsertArgs>(args: SelectSubset<T, balancesUpsertArgs<ExtArgs>>): Prisma__balancesClient<$Result.GetResult<Prisma.$balancesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesCountArgs} args - Arguments to filter Balances to count.
     * @example
     * // Count the number of Balances
     * const count = await prisma.balances.count({
     *   where: {
     *     // ... the filter for the Balances we want to count
     *   }
     * })
    **/
    count<T extends balancesCountArgs>(
      args?: Subset<T, balancesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BalancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BalancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BalancesAggregateArgs>(args: Subset<T, BalancesAggregateArgs>): Prisma.PrismaPromise<GetBalancesAggregateType<T>>

    /**
     * Group by Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {balancesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends balancesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: balancesGroupByArgs['orderBy'] }
        : { orderBy?: balancesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, balancesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBalancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the balances model
   */
  readonly fields: balancesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for balances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__balancesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the balances model
   */
  interface balancesFieldRefs {
    readonly id: FieldRef<"balances", 'String'>
    readonly account_id: FieldRef<"balances", 'String'>
    readonly date: FieldRef<"balances", 'DateTime'>
    readonly balance: FieldRef<"balances", 'Decimal'>
    readonly currency: FieldRef<"balances", 'String'>
    readonly created_at: FieldRef<"balances", 'DateTime'>
    readonly updated_at: FieldRef<"balances", 'DateTime'>
    readonly cash_balance: FieldRef<"balances", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * balances findUnique
   */
  export type balancesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter, which balances to fetch.
     */
    where: balancesWhereUniqueInput
  }

  /**
   * balances findUniqueOrThrow
   */
  export type balancesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter, which balances to fetch.
     */
    where: balancesWhereUniqueInput
  }

  /**
   * balances findFirst
   */
  export type balancesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter, which balances to fetch.
     */
    where?: balancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balances to fetch.
     */
    orderBy?: balancesOrderByWithRelationInput | balancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balances.
     */
    cursor?: balancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * balances findFirstOrThrow
   */
  export type balancesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter, which balances to fetch.
     */
    where?: balancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balances to fetch.
     */
    orderBy?: balancesOrderByWithRelationInput | balancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for balances.
     */
    cursor?: balancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of balances.
     */
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * balances findMany
   */
  export type balancesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter, which balances to fetch.
     */
    where?: balancesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of balances to fetch.
     */
    orderBy?: balancesOrderByWithRelationInput | balancesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing balances.
     */
    cursor?: balancesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` balances.
     */
    skip?: number
    distinct?: BalancesScalarFieldEnum | BalancesScalarFieldEnum[]
  }

  /**
   * balances create
   */
  export type balancesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * The data needed to create a balances.
     */
    data: XOR<balancesCreateInput, balancesUncheckedCreateInput>
  }

  /**
   * balances createMany
   */
  export type balancesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many balances.
     */
    data: balancesCreateManyInput | balancesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * balances createManyAndReturn
   */
  export type balancesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * The data used to create many balances.
     */
    data: balancesCreateManyInput | balancesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * balances update
   */
  export type balancesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * The data needed to update a balances.
     */
    data: XOR<balancesUpdateInput, balancesUncheckedUpdateInput>
    /**
     * Choose, which balances to update.
     */
    where: balancesWhereUniqueInput
  }

  /**
   * balances updateMany
   */
  export type balancesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update balances.
     */
    data: XOR<balancesUpdateManyMutationInput, balancesUncheckedUpdateManyInput>
    /**
     * Filter which balances to update
     */
    where?: balancesWhereInput
    /**
     * Limit how many balances to update.
     */
    limit?: number
  }

  /**
   * balances updateManyAndReturn
   */
  export type balancesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * The data used to update balances.
     */
    data: XOR<balancesUpdateManyMutationInput, balancesUncheckedUpdateManyInput>
    /**
     * Filter which balances to update
     */
    where?: balancesWhereInput
    /**
     * Limit how many balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * balances upsert
   */
  export type balancesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * The filter to search for the balances to update in case it exists.
     */
    where: balancesWhereUniqueInput
    /**
     * In case the balances found by the `where` argument doesn't exist, create a new balances with this data.
     */
    create: XOR<balancesCreateInput, balancesUncheckedCreateInput>
    /**
     * In case the balances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<balancesUpdateInput, balancesUncheckedUpdateInput>
  }

  /**
   * balances delete
   */
  export type balancesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
    /**
     * Filter which balances to delete.
     */
    where: balancesWhereUniqueInput
  }

  /**
   * balances deleteMany
   */
  export type balancesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which balances to delete
     */
    where?: balancesWhereInput
    /**
     * Limit how many balances to delete.
     */
    limit?: number
  }

  /**
   * balances without action
   */
  export type balancesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the balances
     */
    select?: balancesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the balances
     */
    omit?: balancesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: balancesInclude<ExtArgs> | null
  }


  /**
   * Model budget_categories
   */

  export type AggregateBudget_categories = {
    _count: Budget_categoriesCountAggregateOutputType | null
    _avg: Budget_categoriesAvgAggregateOutputType | null
    _sum: Budget_categoriesSumAggregateOutputType | null
    _min: Budget_categoriesMinAggregateOutputType | null
    _max: Budget_categoriesMaxAggregateOutputType | null
  }

  export type Budget_categoriesAvgAggregateOutputType = {
    budgeted_spending: Decimal | null
  }

  export type Budget_categoriesSumAggregateOutputType = {
    budgeted_spending: Decimal | null
  }

  export type Budget_categoriesMinAggregateOutputType = {
    id: string | null
    budget_id: string | null
    category_id: string | null
    budgeted_spending: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Budget_categoriesMaxAggregateOutputType = {
    id: string | null
    budget_id: string | null
    category_id: string | null
    budgeted_spending: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Budget_categoriesCountAggregateOutputType = {
    id: number
    budget_id: number
    category_id: number
    budgeted_spending: number
    currency: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Budget_categoriesAvgAggregateInputType = {
    budgeted_spending?: true
  }

  export type Budget_categoriesSumAggregateInputType = {
    budgeted_spending?: true
  }

  export type Budget_categoriesMinAggregateInputType = {
    id?: true
    budget_id?: true
    category_id?: true
    budgeted_spending?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type Budget_categoriesMaxAggregateInputType = {
    id?: true
    budget_id?: true
    category_id?: true
    budgeted_spending?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type Budget_categoriesCountAggregateInputType = {
    id?: true
    budget_id?: true
    category_id?: true
    budgeted_spending?: true
    currency?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Budget_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_categories to aggregate.
     */
    where?: budget_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_categories to fetch.
     */
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budget_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budget_categories
    **/
    _count?: true | Budget_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Budget_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Budget_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Budget_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Budget_categoriesMaxAggregateInputType
  }

  export type GetBudget_categoriesAggregateType<T extends Budget_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget_categories[P]>
      : GetScalarType<T[P], AggregateBudget_categories[P]>
  }




  export type budget_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budget_categoriesWhereInput
    orderBy?: budget_categoriesOrderByWithAggregationInput | budget_categoriesOrderByWithAggregationInput[]
    by: Budget_categoriesScalarFieldEnum[] | Budget_categoriesScalarFieldEnum
    having?: budget_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Budget_categoriesCountAggregateInputType | true
    _avg?: Budget_categoriesAvgAggregateInputType
    _sum?: Budget_categoriesSumAggregateInputType
    _min?: Budget_categoriesMinAggregateInputType
    _max?: Budget_categoriesMaxAggregateInputType
  }

  export type Budget_categoriesGroupByOutputType = {
    id: string
    budget_id: string
    category_id: string
    budgeted_spending: Decimal
    currency: string
    created_at: Date
    updated_at: Date
    _count: Budget_categoriesCountAggregateOutputType | null
    _avg: Budget_categoriesAvgAggregateOutputType | null
    _sum: Budget_categoriesSumAggregateOutputType | null
    _min: Budget_categoriesMinAggregateOutputType | null
    _max: Budget_categoriesMaxAggregateOutputType | null
  }

  type GetBudget_categoriesGroupByPayload<T extends budget_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Budget_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Budget_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Budget_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Budget_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type budget_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_id?: boolean
    category_id?: boolean
    budgeted_spending?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_categories"]>

  export type budget_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_id?: boolean
    category_id?: boolean
    budgeted_spending?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_categories"]>

  export type budget_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    budget_id?: boolean
    category_id?: boolean
    budgeted_spending?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget_categories"]>

  export type budget_categoriesSelectScalar = {
    id?: boolean
    budget_id?: boolean
    category_id?: boolean
    budgeted_spending?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type budget_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "budget_id" | "category_id" | "budgeted_spending" | "currency" | "created_at" | "updated_at", ExtArgs["result"]["budget_categories"]>
  export type budget_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }
  export type budget_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }
  export type budget_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    budgets?: boolean | budgetsDefaultArgs<ExtArgs>
  }

  export type $budget_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budget_categories"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>
      budgets: Prisma.$budgetsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      budget_id: string
      category_id: string
      budgeted_spending: Prisma.Decimal
      currency: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["budget_categories"]>
    composites: {}
  }

  type budget_categoriesGetPayload<S extends boolean | null | undefined | budget_categoriesDefaultArgs> = $Result.GetResult<Prisma.$budget_categoriesPayload, S>

  type budget_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budget_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Budget_categoriesCountAggregateInputType | true
    }

  export interface budget_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budget_categories'], meta: { name: 'budget_categories' } }
    /**
     * Find zero or one Budget_categories that matches the filter.
     * @param {budget_categoriesFindUniqueArgs} args - Arguments to find a Budget_categories
     * @example
     * // Get one Budget_categories
     * const budget_categories = await prisma.budget_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budget_categoriesFindUniqueArgs>(args: SelectSubset<T, budget_categoriesFindUniqueArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budget_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budget_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Budget_categories
     * @example
     * // Get one Budget_categories
     * const budget_categories = await prisma.budget_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budget_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, budget_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesFindFirstArgs} args - Arguments to find a Budget_categories
     * @example
     * // Get one Budget_categories
     * const budget_categories = await prisma.budget_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budget_categoriesFindFirstArgs>(args?: SelectSubset<T, budget_categoriesFindFirstArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budget_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesFindFirstOrThrowArgs} args - Arguments to find a Budget_categories
     * @example
     * // Get one Budget_categories
     * const budget_categories = await prisma.budget_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budget_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, budget_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budget_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budget_categories
     * const budget_categories = await prisma.budget_categories.findMany()
     * 
     * // Get first 10 Budget_categories
     * const budget_categories = await prisma.budget_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budget_categoriesWithIdOnly = await prisma.budget_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budget_categoriesFindManyArgs>(args?: SelectSubset<T, budget_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budget_categories.
     * @param {budget_categoriesCreateArgs} args - Arguments to create a Budget_categories.
     * @example
     * // Create one Budget_categories
     * const Budget_categories = await prisma.budget_categories.create({
     *   data: {
     *     // ... data to create a Budget_categories
     *   }
     * })
     * 
     */
    create<T extends budget_categoriesCreateArgs>(args: SelectSubset<T, budget_categoriesCreateArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budget_categories.
     * @param {budget_categoriesCreateManyArgs} args - Arguments to create many Budget_categories.
     * @example
     * // Create many Budget_categories
     * const budget_categories = await prisma.budget_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budget_categoriesCreateManyArgs>(args?: SelectSubset<T, budget_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budget_categories and returns the data saved in the database.
     * @param {budget_categoriesCreateManyAndReturnArgs} args - Arguments to create many Budget_categories.
     * @example
     * // Create many Budget_categories
     * const budget_categories = await prisma.budget_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budget_categories and only return the `id`
     * const budget_categoriesWithIdOnly = await prisma.budget_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends budget_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, budget_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budget_categories.
     * @param {budget_categoriesDeleteArgs} args - Arguments to delete one Budget_categories.
     * @example
     * // Delete one Budget_categories
     * const Budget_categories = await prisma.budget_categories.delete({
     *   where: {
     *     // ... filter to delete one Budget_categories
     *   }
     * })
     * 
     */
    delete<T extends budget_categoriesDeleteArgs>(args: SelectSubset<T, budget_categoriesDeleteArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budget_categories.
     * @param {budget_categoriesUpdateArgs} args - Arguments to update one Budget_categories.
     * @example
     * // Update one Budget_categories
     * const budget_categories = await prisma.budget_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budget_categoriesUpdateArgs>(args: SelectSubset<T, budget_categoriesUpdateArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budget_categories.
     * @param {budget_categoriesDeleteManyArgs} args - Arguments to filter Budget_categories to delete.
     * @example
     * // Delete a few Budget_categories
     * const { count } = await prisma.budget_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budget_categoriesDeleteManyArgs>(args?: SelectSubset<T, budget_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budget_categories
     * const budget_categories = await prisma.budget_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budget_categoriesUpdateManyArgs>(args: SelectSubset<T, budget_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budget_categories and returns the data updated in the database.
     * @param {budget_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Budget_categories.
     * @example
     * // Update many Budget_categories
     * const budget_categories = await prisma.budget_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budget_categories and only return the `id`
     * const budget_categoriesWithIdOnly = await prisma.budget_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends budget_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, budget_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budget_categories.
     * @param {budget_categoriesUpsertArgs} args - Arguments to update or create a Budget_categories.
     * @example
     * // Update or create a Budget_categories
     * const budget_categories = await prisma.budget_categories.upsert({
     *   create: {
     *     // ... data to create a Budget_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget_categories we want to update
     *   }
     * })
     */
    upsert<T extends budget_categoriesUpsertArgs>(args: SelectSubset<T, budget_categoriesUpsertArgs<ExtArgs>>): Prisma__budget_categoriesClient<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budget_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesCountArgs} args - Arguments to filter Budget_categories to count.
     * @example
     * // Count the number of Budget_categories
     * const count = await prisma.budget_categories.count({
     *   where: {
     *     // ... the filter for the Budget_categories we want to count
     *   }
     * })
    **/
    count<T extends budget_categoriesCountArgs>(
      args?: Subset<T, budget_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Budget_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Budget_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Budget_categoriesAggregateArgs>(args: Subset<T, Budget_categoriesAggregateArgs>): Prisma.PrismaPromise<GetBudget_categoriesAggregateType<T>>

    /**
     * Group by Budget_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budget_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budget_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budget_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: budget_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budget_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudget_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budget_categories model
   */
  readonly fields: budget_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budget_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budget_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    budgets<T extends budgetsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, budgetsDefaultArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budget_categories model
   */
  interface budget_categoriesFieldRefs {
    readonly id: FieldRef<"budget_categories", 'String'>
    readonly budget_id: FieldRef<"budget_categories", 'String'>
    readonly category_id: FieldRef<"budget_categories", 'String'>
    readonly budgeted_spending: FieldRef<"budget_categories", 'Decimal'>
    readonly currency: FieldRef<"budget_categories", 'String'>
    readonly created_at: FieldRef<"budget_categories", 'DateTime'>
    readonly updated_at: FieldRef<"budget_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budget_categories findUnique
   */
  export type budget_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which budget_categories to fetch.
     */
    where: budget_categoriesWhereUniqueInput
  }

  /**
   * budget_categories findUniqueOrThrow
   */
  export type budget_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which budget_categories to fetch.
     */
    where: budget_categoriesWhereUniqueInput
  }

  /**
   * budget_categories findFirst
   */
  export type budget_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which budget_categories to fetch.
     */
    where?: budget_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_categories to fetch.
     */
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_categories.
     */
    cursor?: budget_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_categories.
     */
    distinct?: Budget_categoriesScalarFieldEnum | Budget_categoriesScalarFieldEnum[]
  }

  /**
   * budget_categories findFirstOrThrow
   */
  export type budget_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which budget_categories to fetch.
     */
    where?: budget_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_categories to fetch.
     */
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budget_categories.
     */
    cursor?: budget_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budget_categories.
     */
    distinct?: Budget_categoriesScalarFieldEnum | Budget_categoriesScalarFieldEnum[]
  }

  /**
   * budget_categories findMany
   */
  export type budget_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which budget_categories to fetch.
     */
    where?: budget_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budget_categories to fetch.
     */
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budget_categories.
     */
    cursor?: budget_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budget_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budget_categories.
     */
    skip?: number
    distinct?: Budget_categoriesScalarFieldEnum | Budget_categoriesScalarFieldEnum[]
  }

  /**
   * budget_categories create
   */
  export type budget_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a budget_categories.
     */
    data: XOR<budget_categoriesCreateInput, budget_categoriesUncheckedCreateInput>
  }

  /**
   * budget_categories createMany
   */
  export type budget_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budget_categories.
     */
    data: budget_categoriesCreateManyInput | budget_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budget_categories createManyAndReturn
   */
  export type budget_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many budget_categories.
     */
    data: budget_categoriesCreateManyInput | budget_categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * budget_categories update
   */
  export type budget_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a budget_categories.
     */
    data: XOR<budget_categoriesUpdateInput, budget_categoriesUncheckedUpdateInput>
    /**
     * Choose, which budget_categories to update.
     */
    where: budget_categoriesWhereUniqueInput
  }

  /**
   * budget_categories updateMany
   */
  export type budget_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budget_categories.
     */
    data: XOR<budget_categoriesUpdateManyMutationInput, budget_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which budget_categories to update
     */
    where?: budget_categoriesWhereInput
    /**
     * Limit how many budget_categories to update.
     */
    limit?: number
  }

  /**
   * budget_categories updateManyAndReturn
   */
  export type budget_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update budget_categories.
     */
    data: XOR<budget_categoriesUpdateManyMutationInput, budget_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which budget_categories to update
     */
    where?: budget_categoriesWhereInput
    /**
     * Limit how many budget_categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * budget_categories upsert
   */
  export type budget_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the budget_categories to update in case it exists.
     */
    where: budget_categoriesWhereUniqueInput
    /**
     * In case the budget_categories found by the `where` argument doesn't exist, create a new budget_categories with this data.
     */
    create: XOR<budget_categoriesCreateInput, budget_categoriesUncheckedCreateInput>
    /**
     * In case the budget_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budget_categoriesUpdateInput, budget_categoriesUncheckedUpdateInput>
  }

  /**
   * budget_categories delete
   */
  export type budget_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    /**
     * Filter which budget_categories to delete.
     */
    where: budget_categoriesWhereUniqueInput
  }

  /**
   * budget_categories deleteMany
   */
  export type budget_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budget_categories to delete
     */
    where?: budget_categoriesWhereInput
    /**
     * Limit how many budget_categories to delete.
     */
    limit?: number
  }

  /**
   * budget_categories without action
   */
  export type budget_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model budgets
   */

  export type AggregateBudgets = {
    _count: BudgetsCountAggregateOutputType | null
    _avg: BudgetsAvgAggregateOutputType | null
    _sum: BudgetsSumAggregateOutputType | null
    _min: BudgetsMinAggregateOutputType | null
    _max: BudgetsMaxAggregateOutputType | null
  }

  export type BudgetsAvgAggregateOutputType = {
    budgeted_spending: Decimal | null
    expected_income: Decimal | null
  }

  export type BudgetsSumAggregateOutputType = {
    budgeted_spending: Decimal | null
    expected_income: Decimal | null
  }

  export type BudgetsMinAggregateOutputType = {
    id: string | null
    family_id: string | null
    start_date: Date | null
    end_date: Date | null
    budgeted_spending: Decimal | null
    expected_income: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BudgetsMaxAggregateOutputType = {
    id: string | null
    family_id: string | null
    start_date: Date | null
    end_date: Date | null
    budgeted_spending: Decimal | null
    expected_income: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BudgetsCountAggregateOutputType = {
    id: number
    family_id: number
    start_date: number
    end_date: number
    budgeted_spending: number
    expected_income: number
    currency: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BudgetsAvgAggregateInputType = {
    budgeted_spending?: true
    expected_income?: true
  }

  export type BudgetsSumAggregateInputType = {
    budgeted_spending?: true
    expected_income?: true
  }

  export type BudgetsMinAggregateInputType = {
    id?: true
    family_id?: true
    start_date?: true
    end_date?: true
    budgeted_spending?: true
    expected_income?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type BudgetsMaxAggregateInputType = {
    id?: true
    family_id?: true
    start_date?: true
    end_date?: true
    budgeted_spending?: true
    expected_income?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type BudgetsCountAggregateInputType = {
    id?: true
    family_id?: true
    start_date?: true
    end_date?: true
    budgeted_spending?: true
    expected_income?: true
    currency?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BudgetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budgets to aggregate.
     */
    where?: budgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budgets to fetch.
     */
    orderBy?: budgetsOrderByWithRelationInput | budgetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: budgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned budgets
    **/
    _count?: true | BudgetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetsMaxAggregateInputType
  }

  export type GetBudgetsAggregateType<T extends BudgetsAggregateArgs> = {
        [P in keyof T & keyof AggregateBudgets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudgets[P]>
      : GetScalarType<T[P], AggregateBudgets[P]>
  }




  export type budgetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: budgetsWhereInput
    orderBy?: budgetsOrderByWithAggregationInput | budgetsOrderByWithAggregationInput[]
    by: BudgetsScalarFieldEnum[] | BudgetsScalarFieldEnum
    having?: budgetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetsCountAggregateInputType | true
    _avg?: BudgetsAvgAggregateInputType
    _sum?: BudgetsSumAggregateInputType
    _min?: BudgetsMinAggregateInputType
    _max?: BudgetsMaxAggregateInputType
  }

  export type BudgetsGroupByOutputType = {
    id: string
    family_id: string
    start_date: Date
    end_date: Date
    budgeted_spending: Decimal | null
    expected_income: Decimal | null
    currency: string
    created_at: Date
    updated_at: Date
    _count: BudgetsCountAggregateOutputType | null
    _avg: BudgetsAvgAggregateOutputType | null
    _sum: BudgetsSumAggregateOutputType | null
    _min: BudgetsMinAggregateOutputType | null
    _max: BudgetsMaxAggregateOutputType | null
  }

  type GetBudgetsGroupByPayload<T extends budgetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetsGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetsGroupByOutputType[P]>
        }
      >
    >


  export type budgetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    start_date?: boolean
    end_date?: boolean
    budgeted_spending?: boolean
    expected_income?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    budget_categories?: boolean | budgets$budget_categoriesArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | BudgetsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgets"]>

  export type budgetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    start_date?: boolean
    end_date?: boolean
    budgeted_spending?: boolean
    expected_income?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgets"]>

  export type budgetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    start_date?: boolean
    end_date?: boolean
    budgeted_spending?: boolean
    expected_income?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budgets"]>

  export type budgetsSelectScalar = {
    id?: boolean
    family_id?: boolean
    start_date?: boolean
    end_date?: boolean
    budgeted_spending?: boolean
    expected_income?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type budgetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "family_id" | "start_date" | "end_date" | "budgeted_spending" | "expected_income" | "currency" | "created_at" | "updated_at", ExtArgs["result"]["budgets"]>
  export type budgetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_categories?: boolean | budgets$budget_categoriesArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | BudgetsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type budgetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type budgetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $budgetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "budgets"
    objects: {
      budget_categories: Prisma.$budget_categoriesPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      family_id: string
      start_date: Date
      end_date: Date
      budgeted_spending: Prisma.Decimal | null
      expected_income: Prisma.Decimal | null
      currency: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["budgets"]>
    composites: {}
  }

  type budgetsGetPayload<S extends boolean | null | undefined | budgetsDefaultArgs> = $Result.GetResult<Prisma.$budgetsPayload, S>

  type budgetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<budgetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetsCountAggregateInputType | true
    }

  export interface budgetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['budgets'], meta: { name: 'budgets' } }
    /**
     * Find zero or one Budgets that matches the filter.
     * @param {budgetsFindUniqueArgs} args - Arguments to find a Budgets
     * @example
     * // Get one Budgets
     * const budgets = await prisma.budgets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends budgetsFindUniqueArgs>(args: SelectSubset<T, budgetsFindUniqueArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Budgets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {budgetsFindUniqueOrThrowArgs} args - Arguments to find a Budgets
     * @example
     * // Get one Budgets
     * const budgets = await prisma.budgets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends budgetsFindUniqueOrThrowArgs>(args: SelectSubset<T, budgetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsFindFirstArgs} args - Arguments to find a Budgets
     * @example
     * // Get one Budgets
     * const budgets = await prisma.budgets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends budgetsFindFirstArgs>(args?: SelectSubset<T, budgetsFindFirstArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Budgets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsFindFirstOrThrowArgs} args - Arguments to find a Budgets
     * @example
     * // Get one Budgets
     * const budgets = await prisma.budgets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends budgetsFindFirstOrThrowArgs>(args?: SelectSubset<T, budgetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budgets.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budgets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetsWithIdOnly = await prisma.budgets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends budgetsFindManyArgs>(args?: SelectSubset<T, budgetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Budgets.
     * @param {budgetsCreateArgs} args - Arguments to create a Budgets.
     * @example
     * // Create one Budgets
     * const Budgets = await prisma.budgets.create({
     *   data: {
     *     // ... data to create a Budgets
     *   }
     * })
     * 
     */
    create<T extends budgetsCreateArgs>(args: SelectSubset<T, budgetsCreateArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Budgets.
     * @param {budgetsCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budgets = await prisma.budgets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends budgetsCreateManyArgs>(args?: SelectSubset<T, budgetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {budgetsCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budgets = await prisma.budgets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetsWithIdOnly = await prisma.budgets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends budgetsCreateManyAndReturnArgs>(args?: SelectSubset<T, budgetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Budgets.
     * @param {budgetsDeleteArgs} args - Arguments to delete one Budgets.
     * @example
     * // Delete one Budgets
     * const Budgets = await prisma.budgets.delete({
     *   where: {
     *     // ... filter to delete one Budgets
     *   }
     * })
     * 
     */
    delete<T extends budgetsDeleteArgs>(args: SelectSubset<T, budgetsDeleteArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Budgets.
     * @param {budgetsUpdateArgs} args - Arguments to update one Budgets.
     * @example
     * // Update one Budgets
     * const budgets = await prisma.budgets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends budgetsUpdateArgs>(args: SelectSubset<T, budgetsUpdateArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Budgets.
     * @param {budgetsDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budgets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends budgetsDeleteManyArgs>(args?: SelectSubset<T, budgetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budgets = await prisma.budgets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends budgetsUpdateManyArgs>(args: SelectSubset<T, budgetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {budgetsUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budgets = await prisma.budgets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetsWithIdOnly = await prisma.budgets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends budgetsUpdateManyAndReturnArgs>(args: SelectSubset<T, budgetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Budgets.
     * @param {budgetsUpsertArgs} args - Arguments to update or create a Budgets.
     * @example
     * // Update or create a Budgets
     * const budgets = await prisma.budgets.upsert({
     *   create: {
     *     // ... data to create a Budgets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budgets we want to update
     *   }
     * })
     */
    upsert<T extends budgetsUpsertArgs>(args: SelectSubset<T, budgetsUpsertArgs<ExtArgs>>): Prisma__budgetsClient<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budgets.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends budgetsCountArgs>(
      args?: Subset<T, budgetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetsAggregateArgs>(args: Subset<T, BudgetsAggregateArgs>): Prisma.PrismaPromise<GetBudgetsAggregateType<T>>

    /**
     * Group by Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {budgetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends budgetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: budgetsGroupByArgs['orderBy'] }
        : { orderBy?: budgetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, budgetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the budgets model
   */
  readonly fields: budgetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for budgets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__budgetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_categories<T extends budgets$budget_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, budgets$budget_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the budgets model
   */
  interface budgetsFieldRefs {
    readonly id: FieldRef<"budgets", 'String'>
    readonly family_id: FieldRef<"budgets", 'String'>
    readonly start_date: FieldRef<"budgets", 'DateTime'>
    readonly end_date: FieldRef<"budgets", 'DateTime'>
    readonly budgeted_spending: FieldRef<"budgets", 'Decimal'>
    readonly expected_income: FieldRef<"budgets", 'Decimal'>
    readonly currency: FieldRef<"budgets", 'String'>
    readonly created_at: FieldRef<"budgets", 'DateTime'>
    readonly updated_at: FieldRef<"budgets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * budgets findUnique
   */
  export type budgetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter, which budgets to fetch.
     */
    where: budgetsWhereUniqueInput
  }

  /**
   * budgets findUniqueOrThrow
   */
  export type budgetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter, which budgets to fetch.
     */
    where: budgetsWhereUniqueInput
  }

  /**
   * budgets findFirst
   */
  export type budgetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter, which budgets to fetch.
     */
    where?: budgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budgets to fetch.
     */
    orderBy?: budgetsOrderByWithRelationInput | budgetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budgets.
     */
    cursor?: budgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budgets.
     */
    distinct?: BudgetsScalarFieldEnum | BudgetsScalarFieldEnum[]
  }

  /**
   * budgets findFirstOrThrow
   */
  export type budgetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter, which budgets to fetch.
     */
    where?: budgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budgets to fetch.
     */
    orderBy?: budgetsOrderByWithRelationInput | budgetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for budgets.
     */
    cursor?: budgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of budgets.
     */
    distinct?: BudgetsScalarFieldEnum | BudgetsScalarFieldEnum[]
  }

  /**
   * budgets findMany
   */
  export type budgetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter, which budgets to fetch.
     */
    where?: budgetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of budgets to fetch.
     */
    orderBy?: budgetsOrderByWithRelationInput | budgetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing budgets.
     */
    cursor?: budgetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` budgets.
     */
    skip?: number
    distinct?: BudgetsScalarFieldEnum | BudgetsScalarFieldEnum[]
  }

  /**
   * budgets create
   */
  export type budgetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * The data needed to create a budgets.
     */
    data: XOR<budgetsCreateInput, budgetsUncheckedCreateInput>
  }

  /**
   * budgets createMany
   */
  export type budgetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many budgets.
     */
    data: budgetsCreateManyInput | budgetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * budgets createManyAndReturn
   */
  export type budgetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * The data used to create many budgets.
     */
    data: budgetsCreateManyInput | budgetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * budgets update
   */
  export type budgetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * The data needed to update a budgets.
     */
    data: XOR<budgetsUpdateInput, budgetsUncheckedUpdateInput>
    /**
     * Choose, which budgets to update.
     */
    where: budgetsWhereUniqueInput
  }

  /**
   * budgets updateMany
   */
  export type budgetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update budgets.
     */
    data: XOR<budgetsUpdateManyMutationInput, budgetsUncheckedUpdateManyInput>
    /**
     * Filter which budgets to update
     */
    where?: budgetsWhereInput
    /**
     * Limit how many budgets to update.
     */
    limit?: number
  }

  /**
   * budgets updateManyAndReturn
   */
  export type budgetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * The data used to update budgets.
     */
    data: XOR<budgetsUpdateManyMutationInput, budgetsUncheckedUpdateManyInput>
    /**
     * Filter which budgets to update
     */
    where?: budgetsWhereInput
    /**
     * Limit how many budgets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * budgets upsert
   */
  export type budgetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * The filter to search for the budgets to update in case it exists.
     */
    where: budgetsWhereUniqueInput
    /**
     * In case the budgets found by the `where` argument doesn't exist, create a new budgets with this data.
     */
    create: XOR<budgetsCreateInput, budgetsUncheckedCreateInput>
    /**
     * In case the budgets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<budgetsUpdateInput, budgetsUncheckedUpdateInput>
  }

  /**
   * budgets delete
   */
  export type budgetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    /**
     * Filter which budgets to delete.
     */
    where: budgetsWhereUniqueInput
  }

  /**
   * budgets deleteMany
   */
  export type budgetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which budgets to delete
     */
    where?: budgetsWhereInput
    /**
     * Limit how many budgets to delete.
     */
    limit?: number
  }

  /**
   * budgets.budget_categories
   */
  export type budgets$budget_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    where?: budget_categoriesWhereInput
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    cursor?: budget_categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_categoriesScalarFieldEnum | Budget_categoriesScalarFieldEnum[]
  }

  /**
   * budgets without action
   */
  export type budgetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
    parent_id: string | null
    classification: string | null
    lucide_icon: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
    parent_id: string | null
    classification: string | null
    lucide_icon: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    color: number
    family_id: number
    created_at: number
    updated_at: number
    parent_id: number
    classification: number
    lucide_icon: number
    _all: number
  }


  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    parent_id?: true
    classification?: true
    lucide_icon?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    parent_id?: true
    classification?: true
    lucide_icon?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    parent_id?: true
    classification?: true
    lucide_icon?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: string
    name: string
    color: string
    family_id: string
    created_at: Date
    updated_at: Date
    parent_id: string | null
    classification: string
    lucide_icon: string
    _count: CategoriesCountAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent_id?: boolean
    classification?: boolean
    lucide_icon?: boolean
    budget_categories?: boolean | categories$budget_categoriesArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    transactions?: boolean | categories$transactionsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent_id?: boolean
    classification?: boolean
    lucide_icon?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent_id?: boolean
    classification?: boolean
    lucide_icon?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    parent_id?: boolean
    classification?: boolean
    lucide_icon?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "family_id" | "created_at" | "updated_at" | "parent_id" | "classification" | "lucide_icon", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    budget_categories?: boolean | categories$budget_categoriesArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    transactions?: boolean | categories$transactionsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      budget_categories: Prisma.$budget_categoriesPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      family_id: string
      created_at: Date
      updated_at: Date
      parent_id: string | null
      classification: string
      lucide_icon: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    budget_categories<T extends categories$budget_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, categories$budget_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budget_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends categories$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, categories$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'String'>
    readonly name: FieldRef<"categories", 'String'>
    readonly color: FieldRef<"categories", 'String'>
    readonly family_id: FieldRef<"categories", 'String'>
    readonly created_at: FieldRef<"categories", 'DateTime'>
    readonly updated_at: FieldRef<"categories", 'DateTime'>
    readonly parent_id: FieldRef<"categories", 'String'>
    readonly classification: FieldRef<"categories", 'String'>
    readonly lucide_icon: FieldRef<"categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.budget_categories
   */
  export type categories$budget_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budget_categories
     */
    select?: budget_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budget_categories
     */
    omit?: budget_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budget_categoriesInclude<ExtArgs> | null
    where?: budget_categoriesWhereInput
    orderBy?: budget_categoriesOrderByWithRelationInput | budget_categoriesOrderByWithRelationInput[]
    cursor?: budget_categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Budget_categoriesScalarFieldEnum | Budget_categoriesScalarFieldEnum[]
  }

  /**
   * categories.transactions
   */
  export type categories$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model chats
   */

  export type AggregateChats = {
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  export type ChatsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    instructions: string | null
    latest_assistant_response_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    instructions: string | null
    latest_assistant_response_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    instructions: number
    error: number
    latest_assistant_response_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChatsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    instructions?: true
    latest_assistant_response_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    instructions?: true
    latest_assistant_response_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    instructions?: true
    error?: true
    latest_assistant_response_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to aggregate.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatsMaxAggregateInputType
  }

  export type GetChatsAggregateType<T extends ChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChats[P]>
      : GetScalarType<T[P], AggregateChats[P]>
  }




  export type chatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatsWhereInput
    orderBy?: chatsOrderByWithAggregationInput | chatsOrderByWithAggregationInput[]
    by: ChatsScalarFieldEnum[] | ChatsScalarFieldEnum
    having?: chatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatsCountAggregateInputType | true
    _min?: ChatsMinAggregateInputType
    _max?: ChatsMaxAggregateInputType
  }

  export type ChatsGroupByOutputType = {
    id: string
    user_id: string
    title: string
    instructions: string | null
    error: JsonValue | null
    latest_assistant_response_id: string | null
    created_at: Date
    updated_at: Date
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  type GetChatsGroupByPayload<T extends chatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatsGroupByOutputType[P]>
        }
      >
    >


  export type chatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    instructions?: boolean
    error?: boolean
    latest_assistant_response_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    users_users_last_viewed_chat_idTochats?: boolean | chats$users_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    instructions?: boolean
    error?: boolean
    latest_assistant_response_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    instructions?: boolean
    error?: boolean
    latest_assistant_response_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    instructions?: boolean
    error?: boolean
    latest_assistant_response_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "instructions" | "error" | "latest_assistant_response_id" | "created_at" | "updated_at", ExtArgs["result"]["chats"]>
  export type chatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    users_users_last_viewed_chat_idTochats?: boolean | chats$users_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type chatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_chats_user_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $chatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chats"
    objects: {
      users_chats_user_idTousers: Prisma.$usersPayload<ExtArgs>
      messages: Prisma.$messagesPayload<ExtArgs>[]
      users_users_last_viewed_chat_idTochats: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      title: string
      instructions: string | null
      error: Prisma.JsonValue | null
      latest_assistant_response_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chats"]>
    composites: {}
  }

  type chatsGetPayload<S extends boolean | null | undefined | chatsDefaultArgs> = $Result.GetResult<Prisma.$chatsPayload, S>

  type chatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatsCountAggregateInputType | true
    }

  export interface chatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chats'], meta: { name: 'chats' } }
    /**
     * Find zero or one Chats that matches the filter.
     * @param {chatsFindUniqueArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatsFindUniqueArgs>(args: SelectSubset<T, chatsFindUniqueArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatsFindUniqueOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatsFindFirstArgs>(args?: SelectSubset<T, chatsFindFirstArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chats.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatsWithIdOnly = await prisma.chats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatsFindManyArgs>(args?: SelectSubset<T, chatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chats.
     * @param {chatsCreateArgs} args - Arguments to create a Chats.
     * @example
     * // Create one Chats
     * const Chats = await prisma.chats.create({
     *   data: {
     *     // ... data to create a Chats
     *   }
     * })
     * 
     */
    create<T extends chatsCreateArgs>(args: SelectSubset<T, chatsCreateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {chatsCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatsCreateManyArgs>(args?: SelectSubset<T, chatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {chatsCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chats.
     * @param {chatsDeleteArgs} args - Arguments to delete one Chats.
     * @example
     * // Delete one Chats
     * const Chats = await prisma.chats.delete({
     *   where: {
     *     // ... filter to delete one Chats
     *   }
     * })
     * 
     */
    delete<T extends chatsDeleteArgs>(args: SelectSubset<T, chatsDeleteArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chats.
     * @param {chatsUpdateArgs} args - Arguments to update one Chats.
     * @example
     * // Update one Chats
     * const chats = await prisma.chats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatsUpdateArgs>(args: SelectSubset<T, chatsUpdateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {chatsDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatsDeleteManyArgs>(args?: SelectSubset<T, chatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatsUpdateManyArgs>(args: SelectSubset<T, chatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {chatsUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chats.
     * @param {chatsUpsertArgs} args - Arguments to update or create a Chats.
     * @example
     * // Update or create a Chats
     * const chats = await prisma.chats.upsert({
     *   create: {
     *     // ... data to create a Chats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chats we want to update
     *   }
     * })
     */
    upsert<T extends chatsUpsertArgs>(args: SelectSubset<T, chatsUpsertArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chats.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatsCountArgs>(
      args?: Subset<T, chatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatsAggregateArgs>(args: Subset<T, ChatsAggregateArgs>): Prisma.PrismaPromise<GetChatsAggregateType<T>>

    /**
     * Group by Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatsGroupByArgs['orderBy'] }
        : { orderBy?: chatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chats model
   */
  readonly fields: chatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_chats_user_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends chats$messagesArgs<ExtArgs> = {}>(args?: Subset<T, chats$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_users_last_viewed_chat_idTochats<T extends chats$users_users_last_viewed_chat_idTochatsArgs<ExtArgs> = {}>(args?: Subset<T, chats$users_users_last_viewed_chat_idTochatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chats model
   */
  interface chatsFieldRefs {
    readonly id: FieldRef<"chats", 'String'>
    readonly user_id: FieldRef<"chats", 'String'>
    readonly title: FieldRef<"chats", 'String'>
    readonly instructions: FieldRef<"chats", 'String'>
    readonly error: FieldRef<"chats", 'Json'>
    readonly latest_assistant_response_id: FieldRef<"chats", 'String'>
    readonly created_at: FieldRef<"chats", 'DateTime'>
    readonly updated_at: FieldRef<"chats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chats findUnique
   */
  export type chatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findUniqueOrThrow
   */
  export type chatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findFirst
   */
  export type chatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findFirstOrThrow
   */
  export type chatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findMany
   */
  export type chatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats create
   */
  export type chatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to create a chats.
     */
    data: XOR<chatsCreateInput, chatsUncheckedCreateInput>
  }

  /**
   * chats createMany
   */
  export type chatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats createManyAndReturn
   */
  export type chatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chats update
   */
  export type chatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to update a chats.
     */
    data: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
    /**
     * Choose, which chats to update.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats updateMany
   */
  export type chatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
  }

  /**
   * chats updateManyAndReturn
   */
  export type chatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chats upsert
   */
  export type chatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The filter to search for the chats to update in case it exists.
     */
    where: chatsWhereUniqueInput
    /**
     * In case the chats found by the `where` argument doesn't exist, create a new chats with this data.
     */
    create: XOR<chatsCreateInput, chatsUncheckedCreateInput>
    /**
     * In case the chats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
  }

  /**
   * chats delete
   */
  export type chatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter which chats to delete.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats deleteMany
   */
  export type chatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to delete.
     */
    limit?: number
  }

  /**
   * chats.messages
   */
  export type chats$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * chats.users_users_last_viewed_chat_idTochats
   */
  export type chats$users_users_last_viewed_chat_idTochatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * chats without action
   */
  export type chatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
  }


  /**
   * Model credit_cards
   */

  export type AggregateCredit_cards = {
    _count: Credit_cardsCountAggregateOutputType | null
    _avg: Credit_cardsAvgAggregateOutputType | null
    _sum: Credit_cardsSumAggregateOutputType | null
    _min: Credit_cardsMinAggregateOutputType | null
    _max: Credit_cardsMaxAggregateOutputType | null
  }

  export type Credit_cardsAvgAggregateOutputType = {
    available_credit: Decimal | null
    minimum_payment: Decimal | null
    apr: Decimal | null
    annual_fee: Decimal | null
  }

  export type Credit_cardsSumAggregateOutputType = {
    available_credit: Decimal | null
    minimum_payment: Decimal | null
    apr: Decimal | null
    annual_fee: Decimal | null
  }

  export type Credit_cardsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    available_credit: Decimal | null
    minimum_payment: Decimal | null
    apr: Decimal | null
    expiration_date: Date | null
    annual_fee: Decimal | null
  }

  export type Credit_cardsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    available_credit: Decimal | null
    minimum_payment: Decimal | null
    apr: Decimal | null
    expiration_date: Date | null
    annual_fee: Decimal | null
  }

  export type Credit_cardsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    available_credit: number
    minimum_payment: number
    apr: number
    expiration_date: number
    annual_fee: number
    locked_attributes: number
    _all: number
  }


  export type Credit_cardsAvgAggregateInputType = {
    available_credit?: true
    minimum_payment?: true
    apr?: true
    annual_fee?: true
  }

  export type Credit_cardsSumAggregateInputType = {
    available_credit?: true
    minimum_payment?: true
    apr?: true
    annual_fee?: true
  }

  export type Credit_cardsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    available_credit?: true
    minimum_payment?: true
    apr?: true
    expiration_date?: true
    annual_fee?: true
  }

  export type Credit_cardsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    available_credit?: true
    minimum_payment?: true
    apr?: true
    expiration_date?: true
    annual_fee?: true
  }

  export type Credit_cardsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    available_credit?: true
    minimum_payment?: true
    apr?: true
    expiration_date?: true
    annual_fee?: true
    locked_attributes?: true
    _all?: true
  }

  export type Credit_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_cards to aggregate.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credit_cards
    **/
    _count?: true | Credit_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Credit_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Credit_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Credit_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Credit_cardsMaxAggregateInputType
  }

  export type GetCredit_cardsAggregateType<T extends Credit_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit_cards[P]>
      : GetScalarType<T[P], AggregateCredit_cards[P]>
  }




  export type credit_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: credit_cardsWhereInput
    orderBy?: credit_cardsOrderByWithAggregationInput | credit_cardsOrderByWithAggregationInput[]
    by: Credit_cardsScalarFieldEnum[] | Credit_cardsScalarFieldEnum
    having?: credit_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Credit_cardsCountAggregateInputType | true
    _avg?: Credit_cardsAvgAggregateInputType
    _sum?: Credit_cardsSumAggregateInputType
    _min?: Credit_cardsMinAggregateInputType
    _max?: Credit_cardsMaxAggregateInputType
  }

  export type Credit_cardsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    available_credit: Decimal | null
    minimum_payment: Decimal | null
    apr: Decimal | null
    expiration_date: Date | null
    annual_fee: Decimal | null
    locked_attributes: JsonValue | null
    _count: Credit_cardsCountAggregateOutputType | null
    _avg: Credit_cardsAvgAggregateOutputType | null
    _sum: Credit_cardsSumAggregateOutputType | null
    _min: Credit_cardsMinAggregateOutputType | null
    _max: Credit_cardsMaxAggregateOutputType | null
  }

  type GetCredit_cardsGroupByPayload<T extends credit_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Credit_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Credit_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Credit_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Credit_cardsGroupByOutputType[P]>
        }
      >
    >


  export type credit_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_credit?: boolean
    minimum_payment?: boolean
    apr?: boolean
    expiration_date?: boolean
    annual_fee?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["credit_cards"]>

  export type credit_cardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_credit?: boolean
    minimum_payment?: boolean
    apr?: boolean
    expiration_date?: boolean
    annual_fee?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["credit_cards"]>

  export type credit_cardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_credit?: boolean
    minimum_payment?: boolean
    apr?: boolean
    expiration_date?: boolean
    annual_fee?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["credit_cards"]>

  export type credit_cardsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_credit?: boolean
    minimum_payment?: boolean
    apr?: boolean
    expiration_date?: boolean
    annual_fee?: boolean
    locked_attributes?: boolean
  }

  export type credit_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "available_credit" | "minimum_payment" | "apr" | "expiration_date" | "annual_fee" | "locked_attributes", ExtArgs["result"]["credit_cards"]>

  export type $credit_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credit_cards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      available_credit: Prisma.Decimal | null
      minimum_payment: Prisma.Decimal | null
      apr: Prisma.Decimal | null
      expiration_date: Date | null
      annual_fee: Prisma.Decimal | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["credit_cards"]>
    composites: {}
  }

  type credit_cardsGetPayload<S extends boolean | null | undefined | credit_cardsDefaultArgs> = $Result.GetResult<Prisma.$credit_cardsPayload, S>

  type credit_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<credit_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Credit_cardsCountAggregateInputType | true
    }

  export interface credit_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credit_cards'], meta: { name: 'credit_cards' } }
    /**
     * Find zero or one Credit_cards that matches the filter.
     * @param {credit_cardsFindUniqueArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends credit_cardsFindUniqueArgs>(args: SelectSubset<T, credit_cardsFindUniqueArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credit_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {credit_cardsFindUniqueOrThrowArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends credit_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, credit_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindFirstArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends credit_cardsFindFirstArgs>(args?: SelectSubset<T, credit_cardsFindFirstArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credit_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindFirstOrThrowArgs} args - Arguments to find a Credit_cards
     * @example
     * // Get one Credit_cards
     * const credit_cards = await prisma.credit_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends credit_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, credit_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credit_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credit_cards
     * const credit_cards = await prisma.credit_cards.findMany()
     * 
     * // Get first 10 Credit_cards
     * const credit_cards = await prisma.credit_cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credit_cardsWithIdOnly = await prisma.credit_cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends credit_cardsFindManyArgs>(args?: SelectSubset<T, credit_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credit_cards.
     * @param {credit_cardsCreateArgs} args - Arguments to create a Credit_cards.
     * @example
     * // Create one Credit_cards
     * const Credit_cards = await prisma.credit_cards.create({
     *   data: {
     *     // ... data to create a Credit_cards
     *   }
     * })
     * 
     */
    create<T extends credit_cardsCreateArgs>(args: SelectSubset<T, credit_cardsCreateArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credit_cards.
     * @param {credit_cardsCreateManyArgs} args - Arguments to create many Credit_cards.
     * @example
     * // Create many Credit_cards
     * const credit_cards = await prisma.credit_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends credit_cardsCreateManyArgs>(args?: SelectSubset<T, credit_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credit_cards and returns the data saved in the database.
     * @param {credit_cardsCreateManyAndReturnArgs} args - Arguments to create many Credit_cards.
     * @example
     * // Create many Credit_cards
     * const credit_cards = await prisma.credit_cards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credit_cards and only return the `id`
     * const credit_cardsWithIdOnly = await prisma.credit_cards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends credit_cardsCreateManyAndReturnArgs>(args?: SelectSubset<T, credit_cardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credit_cards.
     * @param {credit_cardsDeleteArgs} args - Arguments to delete one Credit_cards.
     * @example
     * // Delete one Credit_cards
     * const Credit_cards = await prisma.credit_cards.delete({
     *   where: {
     *     // ... filter to delete one Credit_cards
     *   }
     * })
     * 
     */
    delete<T extends credit_cardsDeleteArgs>(args: SelectSubset<T, credit_cardsDeleteArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credit_cards.
     * @param {credit_cardsUpdateArgs} args - Arguments to update one Credit_cards.
     * @example
     * // Update one Credit_cards
     * const credit_cards = await prisma.credit_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends credit_cardsUpdateArgs>(args: SelectSubset<T, credit_cardsUpdateArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credit_cards.
     * @param {credit_cardsDeleteManyArgs} args - Arguments to filter Credit_cards to delete.
     * @example
     * // Delete a few Credit_cards
     * const { count } = await prisma.credit_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends credit_cardsDeleteManyArgs>(args?: SelectSubset<T, credit_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credit_cards
     * const credit_cards = await prisma.credit_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends credit_cardsUpdateManyArgs>(args: SelectSubset<T, credit_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credit_cards and returns the data updated in the database.
     * @param {credit_cardsUpdateManyAndReturnArgs} args - Arguments to update many Credit_cards.
     * @example
     * // Update many Credit_cards
     * const credit_cards = await prisma.credit_cards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credit_cards and only return the `id`
     * const credit_cardsWithIdOnly = await prisma.credit_cards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends credit_cardsUpdateManyAndReturnArgs>(args: SelectSubset<T, credit_cardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credit_cards.
     * @param {credit_cardsUpsertArgs} args - Arguments to update or create a Credit_cards.
     * @example
     * // Update or create a Credit_cards
     * const credit_cards = await prisma.credit_cards.upsert({
     *   create: {
     *     // ... data to create a Credit_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit_cards we want to update
     *   }
     * })
     */
    upsert<T extends credit_cardsUpsertArgs>(args: SelectSubset<T, credit_cardsUpsertArgs<ExtArgs>>): Prisma__credit_cardsClient<$Result.GetResult<Prisma.$credit_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsCountArgs} args - Arguments to filter Credit_cards to count.
     * @example
     * // Count the number of Credit_cards
     * const count = await prisma.credit_cards.count({
     *   where: {
     *     // ... the filter for the Credit_cards we want to count
     *   }
     * })
    **/
    count<T extends credit_cardsCountArgs>(
      args?: Subset<T, credit_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Credit_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Credit_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Credit_cardsAggregateArgs>(args: Subset<T, Credit_cardsAggregateArgs>): Prisma.PrismaPromise<GetCredit_cardsAggregateType<T>>

    /**
     * Group by Credit_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credit_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends credit_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: credit_cardsGroupByArgs['orderBy'] }
        : { orderBy?: credit_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, credit_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredit_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credit_cards model
   */
  readonly fields: credit_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credit_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__credit_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credit_cards model
   */
  interface credit_cardsFieldRefs {
    readonly id: FieldRef<"credit_cards", 'String'>
    readonly created_at: FieldRef<"credit_cards", 'DateTime'>
    readonly updated_at: FieldRef<"credit_cards", 'DateTime'>
    readonly available_credit: FieldRef<"credit_cards", 'Decimal'>
    readonly minimum_payment: FieldRef<"credit_cards", 'Decimal'>
    readonly apr: FieldRef<"credit_cards", 'Decimal'>
    readonly expiration_date: FieldRef<"credit_cards", 'DateTime'>
    readonly annual_fee: FieldRef<"credit_cards", 'Decimal'>
    readonly locked_attributes: FieldRef<"credit_cards", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * credit_cards findUnique
   */
  export type credit_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards findUniqueOrThrow
   */
  export type credit_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards findFirst
   */
  export type credit_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_cards.
     */
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards findFirstOrThrow
   */
  export type credit_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credit_cards.
     */
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards findMany
   */
  export type credit_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter, which credit_cards to fetch.
     */
    where?: credit_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credit_cards to fetch.
     */
    orderBy?: credit_cardsOrderByWithRelationInput | credit_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credit_cards.
     */
    cursor?: credit_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credit_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credit_cards.
     */
    skip?: number
    distinct?: Credit_cardsScalarFieldEnum | Credit_cardsScalarFieldEnum[]
  }

  /**
   * credit_cards create
   */
  export type credit_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * The data needed to create a credit_cards.
     */
    data: XOR<credit_cardsCreateInput, credit_cardsUncheckedCreateInput>
  }

  /**
   * credit_cards createMany
   */
  export type credit_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credit_cards.
     */
    data: credit_cardsCreateManyInput | credit_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_cards createManyAndReturn
   */
  export type credit_cardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * The data used to create many credit_cards.
     */
    data: credit_cardsCreateManyInput | credit_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credit_cards update
   */
  export type credit_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * The data needed to update a credit_cards.
     */
    data: XOR<credit_cardsUpdateInput, credit_cardsUncheckedUpdateInput>
    /**
     * Choose, which credit_cards to update.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards updateMany
   */
  export type credit_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credit_cards.
     */
    data: XOR<credit_cardsUpdateManyMutationInput, credit_cardsUncheckedUpdateManyInput>
    /**
     * Filter which credit_cards to update
     */
    where?: credit_cardsWhereInput
    /**
     * Limit how many credit_cards to update.
     */
    limit?: number
  }

  /**
   * credit_cards updateManyAndReturn
   */
  export type credit_cardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * The data used to update credit_cards.
     */
    data: XOR<credit_cardsUpdateManyMutationInput, credit_cardsUncheckedUpdateManyInput>
    /**
     * Filter which credit_cards to update
     */
    where?: credit_cardsWhereInput
    /**
     * Limit how many credit_cards to update.
     */
    limit?: number
  }

  /**
   * credit_cards upsert
   */
  export type credit_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * The filter to search for the credit_cards to update in case it exists.
     */
    where: credit_cardsWhereUniqueInput
    /**
     * In case the credit_cards found by the `where` argument doesn't exist, create a new credit_cards with this data.
     */
    create: XOR<credit_cardsCreateInput, credit_cardsUncheckedCreateInput>
    /**
     * In case the credit_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credit_cardsUpdateInput, credit_cardsUncheckedUpdateInput>
  }

  /**
   * credit_cards delete
   */
  export type credit_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
    /**
     * Filter which credit_cards to delete.
     */
    where: credit_cardsWhereUniqueInput
  }

  /**
   * credit_cards deleteMany
   */
  export type credit_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credit_cards to delete
     */
    where?: credit_cardsWhereInput
    /**
     * Limit how many credit_cards to delete.
     */
    limit?: number
  }

  /**
   * credit_cards without action
   */
  export type credit_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credit_cards
     */
    select?: credit_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the credit_cards
     */
    omit?: credit_cardsOmit<ExtArgs> | null
  }


  /**
   * Model cryptos
   */

  export type AggregateCryptos = {
    _count: CryptosCountAggregateOutputType | null
    _min: CryptosMinAggregateOutputType | null
    _max: CryptosMaxAggregateOutputType | null
  }

  export type CryptosMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CryptosMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CryptosCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type CryptosMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type CryptosMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type CryptosCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type CryptosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cryptos to aggregate.
     */
    where?: cryptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cryptos to fetch.
     */
    orderBy?: cryptosOrderByWithRelationInput | cryptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cryptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cryptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cryptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cryptos
    **/
    _count?: true | CryptosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CryptosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CryptosMaxAggregateInputType
  }

  export type GetCryptosAggregateType<T extends CryptosAggregateArgs> = {
        [P in keyof T & keyof AggregateCryptos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCryptos[P]>
      : GetScalarType<T[P], AggregateCryptos[P]>
  }




  export type cryptosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cryptosWhereInput
    orderBy?: cryptosOrderByWithAggregationInput | cryptosOrderByWithAggregationInput[]
    by: CryptosScalarFieldEnum[] | CryptosScalarFieldEnum
    having?: cryptosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CryptosCountAggregateInputType | true
    _min?: CryptosMinAggregateInputType
    _max?: CryptosMaxAggregateInputType
  }

  export type CryptosGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: CryptosCountAggregateOutputType | null
    _min: CryptosMinAggregateOutputType | null
    _max: CryptosMaxAggregateOutputType | null
  }

  type GetCryptosGroupByPayload<T extends cryptosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CryptosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CryptosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CryptosGroupByOutputType[P]>
            : GetScalarType<T[P], CryptosGroupByOutputType[P]>
        }
      >
    >


  export type cryptosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["cryptos"]>

  export type cryptosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["cryptos"]>

  export type cryptosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["cryptos"]>

  export type cryptosSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type cryptosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["cryptos"]>

  export type $cryptosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cryptos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["cryptos"]>
    composites: {}
  }

  type cryptosGetPayload<S extends boolean | null | undefined | cryptosDefaultArgs> = $Result.GetResult<Prisma.$cryptosPayload, S>

  type cryptosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cryptosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CryptosCountAggregateInputType | true
    }

  export interface cryptosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cryptos'], meta: { name: 'cryptos' } }
    /**
     * Find zero or one Cryptos that matches the filter.
     * @param {cryptosFindUniqueArgs} args - Arguments to find a Cryptos
     * @example
     * // Get one Cryptos
     * const cryptos = await prisma.cryptos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cryptosFindUniqueArgs>(args: SelectSubset<T, cryptosFindUniqueArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cryptos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cryptosFindUniqueOrThrowArgs} args - Arguments to find a Cryptos
     * @example
     * // Get one Cryptos
     * const cryptos = await prisma.cryptos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cryptosFindUniqueOrThrowArgs>(args: SelectSubset<T, cryptosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cryptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosFindFirstArgs} args - Arguments to find a Cryptos
     * @example
     * // Get one Cryptos
     * const cryptos = await prisma.cryptos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cryptosFindFirstArgs>(args?: SelectSubset<T, cryptosFindFirstArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cryptos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosFindFirstOrThrowArgs} args - Arguments to find a Cryptos
     * @example
     * // Get one Cryptos
     * const cryptos = await prisma.cryptos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cryptosFindFirstOrThrowArgs>(args?: SelectSubset<T, cryptosFindFirstOrThrowArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cryptos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cryptos
     * const cryptos = await prisma.cryptos.findMany()
     * 
     * // Get first 10 Cryptos
     * const cryptos = await prisma.cryptos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cryptosWithIdOnly = await prisma.cryptos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cryptosFindManyArgs>(args?: SelectSubset<T, cryptosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cryptos.
     * @param {cryptosCreateArgs} args - Arguments to create a Cryptos.
     * @example
     * // Create one Cryptos
     * const Cryptos = await prisma.cryptos.create({
     *   data: {
     *     // ... data to create a Cryptos
     *   }
     * })
     * 
     */
    create<T extends cryptosCreateArgs>(args: SelectSubset<T, cryptosCreateArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cryptos.
     * @param {cryptosCreateManyArgs} args - Arguments to create many Cryptos.
     * @example
     * // Create many Cryptos
     * const cryptos = await prisma.cryptos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cryptosCreateManyArgs>(args?: SelectSubset<T, cryptosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cryptos and returns the data saved in the database.
     * @param {cryptosCreateManyAndReturnArgs} args - Arguments to create many Cryptos.
     * @example
     * // Create many Cryptos
     * const cryptos = await prisma.cryptos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cryptos and only return the `id`
     * const cryptosWithIdOnly = await prisma.cryptos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cryptosCreateManyAndReturnArgs>(args?: SelectSubset<T, cryptosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cryptos.
     * @param {cryptosDeleteArgs} args - Arguments to delete one Cryptos.
     * @example
     * // Delete one Cryptos
     * const Cryptos = await prisma.cryptos.delete({
     *   where: {
     *     // ... filter to delete one Cryptos
     *   }
     * })
     * 
     */
    delete<T extends cryptosDeleteArgs>(args: SelectSubset<T, cryptosDeleteArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cryptos.
     * @param {cryptosUpdateArgs} args - Arguments to update one Cryptos.
     * @example
     * // Update one Cryptos
     * const cryptos = await prisma.cryptos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cryptosUpdateArgs>(args: SelectSubset<T, cryptosUpdateArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cryptos.
     * @param {cryptosDeleteManyArgs} args - Arguments to filter Cryptos to delete.
     * @example
     * // Delete a few Cryptos
     * const { count } = await prisma.cryptos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cryptosDeleteManyArgs>(args?: SelectSubset<T, cryptosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cryptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cryptos
     * const cryptos = await prisma.cryptos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cryptosUpdateManyArgs>(args: SelectSubset<T, cryptosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cryptos and returns the data updated in the database.
     * @param {cryptosUpdateManyAndReturnArgs} args - Arguments to update many Cryptos.
     * @example
     * // Update many Cryptos
     * const cryptos = await prisma.cryptos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cryptos and only return the `id`
     * const cryptosWithIdOnly = await prisma.cryptos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cryptosUpdateManyAndReturnArgs>(args: SelectSubset<T, cryptosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cryptos.
     * @param {cryptosUpsertArgs} args - Arguments to update or create a Cryptos.
     * @example
     * // Update or create a Cryptos
     * const cryptos = await prisma.cryptos.upsert({
     *   create: {
     *     // ... data to create a Cryptos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cryptos we want to update
     *   }
     * })
     */
    upsert<T extends cryptosUpsertArgs>(args: SelectSubset<T, cryptosUpsertArgs<ExtArgs>>): Prisma__cryptosClient<$Result.GetResult<Prisma.$cryptosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cryptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosCountArgs} args - Arguments to filter Cryptos to count.
     * @example
     * // Count the number of Cryptos
     * const count = await prisma.cryptos.count({
     *   where: {
     *     // ... the filter for the Cryptos we want to count
     *   }
     * })
    **/
    count<T extends cryptosCountArgs>(
      args?: Subset<T, cryptosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CryptosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cryptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CryptosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CryptosAggregateArgs>(args: Subset<T, CryptosAggregateArgs>): Prisma.PrismaPromise<GetCryptosAggregateType<T>>

    /**
     * Group by Cryptos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cryptosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cryptosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cryptosGroupByArgs['orderBy'] }
        : { orderBy?: cryptosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cryptosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCryptosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cryptos model
   */
  readonly fields: cryptosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cryptos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cryptosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cryptos model
   */
  interface cryptosFieldRefs {
    readonly id: FieldRef<"cryptos", 'String'>
    readonly created_at: FieldRef<"cryptos", 'DateTime'>
    readonly updated_at: FieldRef<"cryptos", 'DateTime'>
    readonly locked_attributes: FieldRef<"cryptos", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * cryptos findUnique
   */
  export type cryptosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter, which cryptos to fetch.
     */
    where: cryptosWhereUniqueInput
  }

  /**
   * cryptos findUniqueOrThrow
   */
  export type cryptosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter, which cryptos to fetch.
     */
    where: cryptosWhereUniqueInput
  }

  /**
   * cryptos findFirst
   */
  export type cryptosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter, which cryptos to fetch.
     */
    where?: cryptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cryptos to fetch.
     */
    orderBy?: cryptosOrderByWithRelationInput | cryptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cryptos.
     */
    cursor?: cryptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cryptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cryptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cryptos.
     */
    distinct?: CryptosScalarFieldEnum | CryptosScalarFieldEnum[]
  }

  /**
   * cryptos findFirstOrThrow
   */
  export type cryptosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter, which cryptos to fetch.
     */
    where?: cryptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cryptos to fetch.
     */
    orderBy?: cryptosOrderByWithRelationInput | cryptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cryptos.
     */
    cursor?: cryptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cryptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cryptos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cryptos.
     */
    distinct?: CryptosScalarFieldEnum | CryptosScalarFieldEnum[]
  }

  /**
   * cryptos findMany
   */
  export type cryptosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter, which cryptos to fetch.
     */
    where?: cryptosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cryptos to fetch.
     */
    orderBy?: cryptosOrderByWithRelationInput | cryptosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cryptos.
     */
    cursor?: cryptosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cryptos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cryptos.
     */
    skip?: number
    distinct?: CryptosScalarFieldEnum | CryptosScalarFieldEnum[]
  }

  /**
   * cryptos create
   */
  export type cryptosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * The data needed to create a cryptos.
     */
    data: XOR<cryptosCreateInput, cryptosUncheckedCreateInput>
  }

  /**
   * cryptos createMany
   */
  export type cryptosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cryptos.
     */
    data: cryptosCreateManyInput | cryptosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cryptos createManyAndReturn
   */
  export type cryptosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * The data used to create many cryptos.
     */
    data: cryptosCreateManyInput | cryptosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cryptos update
   */
  export type cryptosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * The data needed to update a cryptos.
     */
    data: XOR<cryptosUpdateInput, cryptosUncheckedUpdateInput>
    /**
     * Choose, which cryptos to update.
     */
    where: cryptosWhereUniqueInput
  }

  /**
   * cryptos updateMany
   */
  export type cryptosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cryptos.
     */
    data: XOR<cryptosUpdateManyMutationInput, cryptosUncheckedUpdateManyInput>
    /**
     * Filter which cryptos to update
     */
    where?: cryptosWhereInput
    /**
     * Limit how many cryptos to update.
     */
    limit?: number
  }

  /**
   * cryptos updateManyAndReturn
   */
  export type cryptosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * The data used to update cryptos.
     */
    data: XOR<cryptosUpdateManyMutationInput, cryptosUncheckedUpdateManyInput>
    /**
     * Filter which cryptos to update
     */
    where?: cryptosWhereInput
    /**
     * Limit how many cryptos to update.
     */
    limit?: number
  }

  /**
   * cryptos upsert
   */
  export type cryptosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * The filter to search for the cryptos to update in case it exists.
     */
    where: cryptosWhereUniqueInput
    /**
     * In case the cryptos found by the `where` argument doesn't exist, create a new cryptos with this data.
     */
    create: XOR<cryptosCreateInput, cryptosUncheckedCreateInput>
    /**
     * In case the cryptos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cryptosUpdateInput, cryptosUncheckedUpdateInput>
  }

  /**
   * cryptos delete
   */
  export type cryptosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
    /**
     * Filter which cryptos to delete.
     */
    where: cryptosWhereUniqueInput
  }

  /**
   * cryptos deleteMany
   */
  export type cryptosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cryptos to delete
     */
    where?: cryptosWhereInput
    /**
     * Limit how many cryptos to delete.
     */
    limit?: number
  }

  /**
   * cryptos without action
   */
  export type cryptosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cryptos
     */
    select?: cryptosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cryptos
     */
    omit?: cryptosOmit<ExtArgs> | null
  }


  /**
   * Model data_enrichments
   */

  export type AggregateData_enrichments = {
    _count: Data_enrichmentsCountAggregateOutputType | null
    _min: Data_enrichmentsMinAggregateOutputType | null
    _max: Data_enrichmentsMaxAggregateOutputType | null
  }

  export type Data_enrichmentsMinAggregateOutputType = {
    id: string | null
    enrichable_type: string | null
    enrichable_id: string | null
    source: string | null
    attribute_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Data_enrichmentsMaxAggregateOutputType = {
    id: string | null
    enrichable_type: string | null
    enrichable_id: string | null
    source: string | null
    attribute_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Data_enrichmentsCountAggregateOutputType = {
    id: number
    enrichable_type: number
    enrichable_id: number
    source: number
    attribute_name: number
    value: number
    metadata: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Data_enrichmentsMinAggregateInputType = {
    id?: true
    enrichable_type?: true
    enrichable_id?: true
    source?: true
    attribute_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Data_enrichmentsMaxAggregateInputType = {
    id?: true
    enrichable_type?: true
    enrichable_id?: true
    source?: true
    attribute_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Data_enrichmentsCountAggregateInputType = {
    id?: true
    enrichable_type?: true
    enrichable_id?: true
    source?: true
    attribute_name?: true
    value?: true
    metadata?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Data_enrichmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which data_enrichments to aggregate.
     */
    where?: data_enrichmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data_enrichments to fetch.
     */
    orderBy?: data_enrichmentsOrderByWithRelationInput | data_enrichmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: data_enrichmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data_enrichments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data_enrichments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned data_enrichments
    **/
    _count?: true | Data_enrichmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Data_enrichmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Data_enrichmentsMaxAggregateInputType
  }

  export type GetData_enrichmentsAggregateType<T extends Data_enrichmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateData_enrichments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateData_enrichments[P]>
      : GetScalarType<T[P], AggregateData_enrichments[P]>
  }




  export type data_enrichmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: data_enrichmentsWhereInput
    orderBy?: data_enrichmentsOrderByWithAggregationInput | data_enrichmentsOrderByWithAggregationInput[]
    by: Data_enrichmentsScalarFieldEnum[] | Data_enrichmentsScalarFieldEnum
    having?: data_enrichmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Data_enrichmentsCountAggregateInputType | true
    _min?: Data_enrichmentsMinAggregateInputType
    _max?: Data_enrichmentsMaxAggregateInputType
  }

  export type Data_enrichmentsGroupByOutputType = {
    id: string
    enrichable_type: string
    enrichable_id: string
    source: string | null
    attribute_name: string | null
    value: JsonValue | null
    metadata: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: Data_enrichmentsCountAggregateOutputType | null
    _min: Data_enrichmentsMinAggregateOutputType | null
    _max: Data_enrichmentsMaxAggregateOutputType | null
  }

  type GetData_enrichmentsGroupByPayload<T extends data_enrichmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Data_enrichmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Data_enrichmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Data_enrichmentsGroupByOutputType[P]>
            : GetScalarType<T[P], Data_enrichmentsGroupByOutputType[P]>
        }
      >
    >


  export type data_enrichmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrichable_type?: boolean
    enrichable_id?: boolean
    source?: boolean
    attribute_name?: boolean
    value?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["data_enrichments"]>

  export type data_enrichmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrichable_type?: boolean
    enrichable_id?: boolean
    source?: boolean
    attribute_name?: boolean
    value?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["data_enrichments"]>

  export type data_enrichmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enrichable_type?: boolean
    enrichable_id?: boolean
    source?: boolean
    attribute_name?: boolean
    value?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["data_enrichments"]>

  export type data_enrichmentsSelectScalar = {
    id?: boolean
    enrichable_type?: boolean
    enrichable_id?: boolean
    source?: boolean
    attribute_name?: boolean
    value?: boolean
    metadata?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type data_enrichmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enrichable_type" | "enrichable_id" | "source" | "attribute_name" | "value" | "metadata" | "created_at" | "updated_at", ExtArgs["result"]["data_enrichments"]>

  export type $data_enrichmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "data_enrichments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enrichable_type: string
      enrichable_id: string
      source: string | null
      attribute_name: string | null
      value: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["data_enrichments"]>
    composites: {}
  }

  type data_enrichmentsGetPayload<S extends boolean | null | undefined | data_enrichmentsDefaultArgs> = $Result.GetResult<Prisma.$data_enrichmentsPayload, S>

  type data_enrichmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<data_enrichmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Data_enrichmentsCountAggregateInputType | true
    }

  export interface data_enrichmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['data_enrichments'], meta: { name: 'data_enrichments' } }
    /**
     * Find zero or one Data_enrichments that matches the filter.
     * @param {data_enrichmentsFindUniqueArgs} args - Arguments to find a Data_enrichments
     * @example
     * // Get one Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends data_enrichmentsFindUniqueArgs>(args: SelectSubset<T, data_enrichmentsFindUniqueArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Data_enrichments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {data_enrichmentsFindUniqueOrThrowArgs} args - Arguments to find a Data_enrichments
     * @example
     * // Get one Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends data_enrichmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, data_enrichmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Data_enrichments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsFindFirstArgs} args - Arguments to find a Data_enrichments
     * @example
     * // Get one Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends data_enrichmentsFindFirstArgs>(args?: SelectSubset<T, data_enrichmentsFindFirstArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Data_enrichments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsFindFirstOrThrowArgs} args - Arguments to find a Data_enrichments
     * @example
     * // Get one Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends data_enrichmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, data_enrichmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Data_enrichments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findMany()
     * 
     * // Get first 10 Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const data_enrichmentsWithIdOnly = await prisma.data_enrichments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends data_enrichmentsFindManyArgs>(args?: SelectSubset<T, data_enrichmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Data_enrichments.
     * @param {data_enrichmentsCreateArgs} args - Arguments to create a Data_enrichments.
     * @example
     * // Create one Data_enrichments
     * const Data_enrichments = await prisma.data_enrichments.create({
     *   data: {
     *     // ... data to create a Data_enrichments
     *   }
     * })
     * 
     */
    create<T extends data_enrichmentsCreateArgs>(args: SelectSubset<T, data_enrichmentsCreateArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Data_enrichments.
     * @param {data_enrichmentsCreateManyArgs} args - Arguments to create many Data_enrichments.
     * @example
     * // Create many Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends data_enrichmentsCreateManyArgs>(args?: SelectSubset<T, data_enrichmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Data_enrichments and returns the data saved in the database.
     * @param {data_enrichmentsCreateManyAndReturnArgs} args - Arguments to create many Data_enrichments.
     * @example
     * // Create many Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Data_enrichments and only return the `id`
     * const data_enrichmentsWithIdOnly = await prisma.data_enrichments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends data_enrichmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, data_enrichmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Data_enrichments.
     * @param {data_enrichmentsDeleteArgs} args - Arguments to delete one Data_enrichments.
     * @example
     * // Delete one Data_enrichments
     * const Data_enrichments = await prisma.data_enrichments.delete({
     *   where: {
     *     // ... filter to delete one Data_enrichments
     *   }
     * })
     * 
     */
    delete<T extends data_enrichmentsDeleteArgs>(args: SelectSubset<T, data_enrichmentsDeleteArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Data_enrichments.
     * @param {data_enrichmentsUpdateArgs} args - Arguments to update one Data_enrichments.
     * @example
     * // Update one Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends data_enrichmentsUpdateArgs>(args: SelectSubset<T, data_enrichmentsUpdateArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Data_enrichments.
     * @param {data_enrichmentsDeleteManyArgs} args - Arguments to filter Data_enrichments to delete.
     * @example
     * // Delete a few Data_enrichments
     * const { count } = await prisma.data_enrichments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends data_enrichmentsDeleteManyArgs>(args?: SelectSubset<T, data_enrichmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Data_enrichments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends data_enrichmentsUpdateManyArgs>(args: SelectSubset<T, data_enrichmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Data_enrichments and returns the data updated in the database.
     * @param {data_enrichmentsUpdateManyAndReturnArgs} args - Arguments to update many Data_enrichments.
     * @example
     * // Update many Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Data_enrichments and only return the `id`
     * const data_enrichmentsWithIdOnly = await prisma.data_enrichments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends data_enrichmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, data_enrichmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Data_enrichments.
     * @param {data_enrichmentsUpsertArgs} args - Arguments to update or create a Data_enrichments.
     * @example
     * // Update or create a Data_enrichments
     * const data_enrichments = await prisma.data_enrichments.upsert({
     *   create: {
     *     // ... data to create a Data_enrichments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Data_enrichments we want to update
     *   }
     * })
     */
    upsert<T extends data_enrichmentsUpsertArgs>(args: SelectSubset<T, data_enrichmentsUpsertArgs<ExtArgs>>): Prisma__data_enrichmentsClient<$Result.GetResult<Prisma.$data_enrichmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Data_enrichments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsCountArgs} args - Arguments to filter Data_enrichments to count.
     * @example
     * // Count the number of Data_enrichments
     * const count = await prisma.data_enrichments.count({
     *   where: {
     *     // ... the filter for the Data_enrichments we want to count
     *   }
     * })
    **/
    count<T extends data_enrichmentsCountArgs>(
      args?: Subset<T, data_enrichmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Data_enrichmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Data_enrichments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Data_enrichmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Data_enrichmentsAggregateArgs>(args: Subset<T, Data_enrichmentsAggregateArgs>): Prisma.PrismaPromise<GetData_enrichmentsAggregateType<T>>

    /**
     * Group by Data_enrichments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {data_enrichmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends data_enrichmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: data_enrichmentsGroupByArgs['orderBy'] }
        : { orderBy?: data_enrichmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, data_enrichmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetData_enrichmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the data_enrichments model
   */
  readonly fields: data_enrichmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for data_enrichments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__data_enrichmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the data_enrichments model
   */
  interface data_enrichmentsFieldRefs {
    readonly id: FieldRef<"data_enrichments", 'String'>
    readonly enrichable_type: FieldRef<"data_enrichments", 'String'>
    readonly enrichable_id: FieldRef<"data_enrichments", 'String'>
    readonly source: FieldRef<"data_enrichments", 'String'>
    readonly attribute_name: FieldRef<"data_enrichments", 'String'>
    readonly value: FieldRef<"data_enrichments", 'Json'>
    readonly metadata: FieldRef<"data_enrichments", 'Json'>
    readonly created_at: FieldRef<"data_enrichments", 'DateTime'>
    readonly updated_at: FieldRef<"data_enrichments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * data_enrichments findUnique
   */
  export type data_enrichmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter, which data_enrichments to fetch.
     */
    where: data_enrichmentsWhereUniqueInput
  }

  /**
   * data_enrichments findUniqueOrThrow
   */
  export type data_enrichmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter, which data_enrichments to fetch.
     */
    where: data_enrichmentsWhereUniqueInput
  }

  /**
   * data_enrichments findFirst
   */
  export type data_enrichmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter, which data_enrichments to fetch.
     */
    where?: data_enrichmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data_enrichments to fetch.
     */
    orderBy?: data_enrichmentsOrderByWithRelationInput | data_enrichmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for data_enrichments.
     */
    cursor?: data_enrichmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data_enrichments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data_enrichments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of data_enrichments.
     */
    distinct?: Data_enrichmentsScalarFieldEnum | Data_enrichmentsScalarFieldEnum[]
  }

  /**
   * data_enrichments findFirstOrThrow
   */
  export type data_enrichmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter, which data_enrichments to fetch.
     */
    where?: data_enrichmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data_enrichments to fetch.
     */
    orderBy?: data_enrichmentsOrderByWithRelationInput | data_enrichmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for data_enrichments.
     */
    cursor?: data_enrichmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data_enrichments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data_enrichments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of data_enrichments.
     */
    distinct?: Data_enrichmentsScalarFieldEnum | Data_enrichmentsScalarFieldEnum[]
  }

  /**
   * data_enrichments findMany
   */
  export type data_enrichmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter, which data_enrichments to fetch.
     */
    where?: data_enrichmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of data_enrichments to fetch.
     */
    orderBy?: data_enrichmentsOrderByWithRelationInput | data_enrichmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing data_enrichments.
     */
    cursor?: data_enrichmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` data_enrichments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` data_enrichments.
     */
    skip?: number
    distinct?: Data_enrichmentsScalarFieldEnum | Data_enrichmentsScalarFieldEnum[]
  }

  /**
   * data_enrichments create
   */
  export type data_enrichmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a data_enrichments.
     */
    data: XOR<data_enrichmentsCreateInput, data_enrichmentsUncheckedCreateInput>
  }

  /**
   * data_enrichments createMany
   */
  export type data_enrichmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many data_enrichments.
     */
    data: data_enrichmentsCreateManyInput | data_enrichmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * data_enrichments createManyAndReturn
   */
  export type data_enrichmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * The data used to create many data_enrichments.
     */
    data: data_enrichmentsCreateManyInput | data_enrichmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * data_enrichments update
   */
  export type data_enrichmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a data_enrichments.
     */
    data: XOR<data_enrichmentsUpdateInput, data_enrichmentsUncheckedUpdateInput>
    /**
     * Choose, which data_enrichments to update.
     */
    where: data_enrichmentsWhereUniqueInput
  }

  /**
   * data_enrichments updateMany
   */
  export type data_enrichmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update data_enrichments.
     */
    data: XOR<data_enrichmentsUpdateManyMutationInput, data_enrichmentsUncheckedUpdateManyInput>
    /**
     * Filter which data_enrichments to update
     */
    where?: data_enrichmentsWhereInput
    /**
     * Limit how many data_enrichments to update.
     */
    limit?: number
  }

  /**
   * data_enrichments updateManyAndReturn
   */
  export type data_enrichmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * The data used to update data_enrichments.
     */
    data: XOR<data_enrichmentsUpdateManyMutationInput, data_enrichmentsUncheckedUpdateManyInput>
    /**
     * Filter which data_enrichments to update
     */
    where?: data_enrichmentsWhereInput
    /**
     * Limit how many data_enrichments to update.
     */
    limit?: number
  }

  /**
   * data_enrichments upsert
   */
  export type data_enrichmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the data_enrichments to update in case it exists.
     */
    where: data_enrichmentsWhereUniqueInput
    /**
     * In case the data_enrichments found by the `where` argument doesn't exist, create a new data_enrichments with this data.
     */
    create: XOR<data_enrichmentsCreateInput, data_enrichmentsUncheckedCreateInput>
    /**
     * In case the data_enrichments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<data_enrichmentsUpdateInput, data_enrichmentsUncheckedUpdateInput>
  }

  /**
   * data_enrichments delete
   */
  export type data_enrichmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
    /**
     * Filter which data_enrichments to delete.
     */
    where: data_enrichmentsWhereUniqueInput
  }

  /**
   * data_enrichments deleteMany
   */
  export type data_enrichmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which data_enrichments to delete
     */
    where?: data_enrichmentsWhereInput
    /**
     * Limit how many data_enrichments to delete.
     */
    limit?: number
  }

  /**
   * data_enrichments without action
   */
  export type data_enrichmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the data_enrichments
     */
    select?: data_enrichmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the data_enrichments
     */
    omit?: data_enrichmentsOmit<ExtArgs> | null
  }


  /**
   * Model depositories
   */

  export type AggregateDepositories = {
    _count: DepositoriesCountAggregateOutputType | null
    _min: DepositoriesMinAggregateOutputType | null
    _max: DepositoriesMaxAggregateOutputType | null
  }

  export type DepositoriesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DepositoriesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DepositoriesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type DepositoriesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type DepositoriesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type DepositoriesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type DepositoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which depositories to aggregate.
     */
    where?: depositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositories to fetch.
     */
    orderBy?: depositoriesOrderByWithRelationInput | depositoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: depositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned depositories
    **/
    _count?: true | DepositoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositoriesMaxAggregateInputType
  }

  export type GetDepositoriesAggregateType<T extends DepositoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateDepositories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepositories[P]>
      : GetScalarType<T[P], AggregateDepositories[P]>
  }




  export type depositoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: depositoriesWhereInput
    orderBy?: depositoriesOrderByWithAggregationInput | depositoriesOrderByWithAggregationInput[]
    by: DepositoriesScalarFieldEnum[] | DepositoriesScalarFieldEnum
    having?: depositoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositoriesCountAggregateInputType | true
    _min?: DepositoriesMinAggregateInputType
    _max?: DepositoriesMaxAggregateInputType
  }

  export type DepositoriesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: DepositoriesCountAggregateOutputType | null
    _min: DepositoriesMinAggregateOutputType | null
    _max: DepositoriesMaxAggregateOutputType | null
  }

  type GetDepositoriesGroupByPayload<T extends depositoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositoriesGroupByOutputType[P]>
            : GetScalarType<T[P], DepositoriesGroupByOutputType[P]>
        }
      >
    >


  export type depositoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["depositories"]>

  export type depositoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["depositories"]>

  export type depositoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["depositories"]>

  export type depositoriesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type depositoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["depositories"]>

  export type $depositoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "depositories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["depositories"]>
    composites: {}
  }

  type depositoriesGetPayload<S extends boolean | null | undefined | depositoriesDefaultArgs> = $Result.GetResult<Prisma.$depositoriesPayload, S>

  type depositoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<depositoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositoriesCountAggregateInputType | true
    }

  export interface depositoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['depositories'], meta: { name: 'depositories' } }
    /**
     * Find zero or one Depositories that matches the filter.
     * @param {depositoriesFindUniqueArgs} args - Arguments to find a Depositories
     * @example
     * // Get one Depositories
     * const depositories = await prisma.depositories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends depositoriesFindUniqueArgs>(args: SelectSubset<T, depositoriesFindUniqueArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Depositories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {depositoriesFindUniqueOrThrowArgs} args - Arguments to find a Depositories
     * @example
     * // Get one Depositories
     * const depositories = await prisma.depositories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends depositoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, depositoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesFindFirstArgs} args - Arguments to find a Depositories
     * @example
     * // Get one Depositories
     * const depositories = await prisma.depositories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends depositoriesFindFirstArgs>(args?: SelectSubset<T, depositoriesFindFirstArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Depositories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesFindFirstOrThrowArgs} args - Arguments to find a Depositories
     * @example
     * // Get one Depositories
     * const depositories = await prisma.depositories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends depositoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, depositoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Depositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Depositories
     * const depositories = await prisma.depositories.findMany()
     * 
     * // Get first 10 Depositories
     * const depositories = await prisma.depositories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositoriesWithIdOnly = await prisma.depositories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends depositoriesFindManyArgs>(args?: SelectSubset<T, depositoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Depositories.
     * @param {depositoriesCreateArgs} args - Arguments to create a Depositories.
     * @example
     * // Create one Depositories
     * const Depositories = await prisma.depositories.create({
     *   data: {
     *     // ... data to create a Depositories
     *   }
     * })
     * 
     */
    create<T extends depositoriesCreateArgs>(args: SelectSubset<T, depositoriesCreateArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Depositories.
     * @param {depositoriesCreateManyArgs} args - Arguments to create many Depositories.
     * @example
     * // Create many Depositories
     * const depositories = await prisma.depositories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends depositoriesCreateManyArgs>(args?: SelectSubset<T, depositoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Depositories and returns the data saved in the database.
     * @param {depositoriesCreateManyAndReturnArgs} args - Arguments to create many Depositories.
     * @example
     * // Create many Depositories
     * const depositories = await prisma.depositories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Depositories and only return the `id`
     * const depositoriesWithIdOnly = await prisma.depositories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends depositoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, depositoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Depositories.
     * @param {depositoriesDeleteArgs} args - Arguments to delete one Depositories.
     * @example
     * // Delete one Depositories
     * const Depositories = await prisma.depositories.delete({
     *   where: {
     *     // ... filter to delete one Depositories
     *   }
     * })
     * 
     */
    delete<T extends depositoriesDeleteArgs>(args: SelectSubset<T, depositoriesDeleteArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Depositories.
     * @param {depositoriesUpdateArgs} args - Arguments to update one Depositories.
     * @example
     * // Update one Depositories
     * const depositories = await prisma.depositories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends depositoriesUpdateArgs>(args: SelectSubset<T, depositoriesUpdateArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Depositories.
     * @param {depositoriesDeleteManyArgs} args - Arguments to filter Depositories to delete.
     * @example
     * // Delete a few Depositories
     * const { count } = await prisma.depositories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends depositoriesDeleteManyArgs>(args?: SelectSubset<T, depositoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Depositories
     * const depositories = await prisma.depositories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends depositoriesUpdateManyArgs>(args: SelectSubset<T, depositoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Depositories and returns the data updated in the database.
     * @param {depositoriesUpdateManyAndReturnArgs} args - Arguments to update many Depositories.
     * @example
     * // Update many Depositories
     * const depositories = await prisma.depositories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Depositories and only return the `id`
     * const depositoriesWithIdOnly = await prisma.depositories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends depositoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, depositoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Depositories.
     * @param {depositoriesUpsertArgs} args - Arguments to update or create a Depositories.
     * @example
     * // Update or create a Depositories
     * const depositories = await prisma.depositories.upsert({
     *   create: {
     *     // ... data to create a Depositories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Depositories we want to update
     *   }
     * })
     */
    upsert<T extends depositoriesUpsertArgs>(args: SelectSubset<T, depositoriesUpsertArgs<ExtArgs>>): Prisma__depositoriesClient<$Result.GetResult<Prisma.$depositoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Depositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesCountArgs} args - Arguments to filter Depositories to count.
     * @example
     * // Count the number of Depositories
     * const count = await prisma.depositories.count({
     *   where: {
     *     // ... the filter for the Depositories we want to count
     *   }
     * })
    **/
    count<T extends depositoriesCountArgs>(
      args?: Subset<T, depositoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Depositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositoriesAggregateArgs>(args: Subset<T, DepositoriesAggregateArgs>): Prisma.PrismaPromise<GetDepositoriesAggregateType<T>>

    /**
     * Group by Depositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {depositoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends depositoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: depositoriesGroupByArgs['orderBy'] }
        : { orderBy?: depositoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, depositoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the depositories model
   */
  readonly fields: depositoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for depositories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__depositoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the depositories model
   */
  interface depositoriesFieldRefs {
    readonly id: FieldRef<"depositories", 'String'>
    readonly created_at: FieldRef<"depositories", 'DateTime'>
    readonly updated_at: FieldRef<"depositories", 'DateTime'>
    readonly locked_attributes: FieldRef<"depositories", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * depositories findUnique
   */
  export type depositoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter, which depositories to fetch.
     */
    where: depositoriesWhereUniqueInput
  }

  /**
   * depositories findUniqueOrThrow
   */
  export type depositoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter, which depositories to fetch.
     */
    where: depositoriesWhereUniqueInput
  }

  /**
   * depositories findFirst
   */
  export type depositoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter, which depositories to fetch.
     */
    where?: depositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositories to fetch.
     */
    orderBy?: depositoriesOrderByWithRelationInput | depositoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositories.
     */
    cursor?: depositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositories.
     */
    distinct?: DepositoriesScalarFieldEnum | DepositoriesScalarFieldEnum[]
  }

  /**
   * depositories findFirstOrThrow
   */
  export type depositoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter, which depositories to fetch.
     */
    where?: depositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositories to fetch.
     */
    orderBy?: depositoriesOrderByWithRelationInput | depositoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for depositories.
     */
    cursor?: depositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of depositories.
     */
    distinct?: DepositoriesScalarFieldEnum | DepositoriesScalarFieldEnum[]
  }

  /**
   * depositories findMany
   */
  export type depositoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter, which depositories to fetch.
     */
    where?: depositoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of depositories to fetch.
     */
    orderBy?: depositoriesOrderByWithRelationInput | depositoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing depositories.
     */
    cursor?: depositoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` depositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` depositories.
     */
    skip?: number
    distinct?: DepositoriesScalarFieldEnum | DepositoriesScalarFieldEnum[]
  }

  /**
   * depositories create
   */
  export type depositoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a depositories.
     */
    data: XOR<depositoriesCreateInput, depositoriesUncheckedCreateInput>
  }

  /**
   * depositories createMany
   */
  export type depositoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many depositories.
     */
    data: depositoriesCreateManyInput | depositoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * depositories createManyAndReturn
   */
  export type depositoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * The data used to create many depositories.
     */
    data: depositoriesCreateManyInput | depositoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * depositories update
   */
  export type depositoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a depositories.
     */
    data: XOR<depositoriesUpdateInput, depositoriesUncheckedUpdateInput>
    /**
     * Choose, which depositories to update.
     */
    where: depositoriesWhereUniqueInput
  }

  /**
   * depositories updateMany
   */
  export type depositoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update depositories.
     */
    data: XOR<depositoriesUpdateManyMutationInput, depositoriesUncheckedUpdateManyInput>
    /**
     * Filter which depositories to update
     */
    where?: depositoriesWhereInput
    /**
     * Limit how many depositories to update.
     */
    limit?: number
  }

  /**
   * depositories updateManyAndReturn
   */
  export type depositoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * The data used to update depositories.
     */
    data: XOR<depositoriesUpdateManyMutationInput, depositoriesUncheckedUpdateManyInput>
    /**
     * Filter which depositories to update
     */
    where?: depositoriesWhereInput
    /**
     * Limit how many depositories to update.
     */
    limit?: number
  }

  /**
   * depositories upsert
   */
  export type depositoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the depositories to update in case it exists.
     */
    where: depositoriesWhereUniqueInput
    /**
     * In case the depositories found by the `where` argument doesn't exist, create a new depositories with this data.
     */
    create: XOR<depositoriesCreateInput, depositoriesUncheckedCreateInput>
    /**
     * In case the depositories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<depositoriesUpdateInput, depositoriesUncheckedUpdateInput>
  }

  /**
   * depositories delete
   */
  export type depositoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
    /**
     * Filter which depositories to delete.
     */
    where: depositoriesWhereUniqueInput
  }

  /**
   * depositories deleteMany
   */
  export type depositoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which depositories to delete
     */
    where?: depositoriesWhereInput
    /**
     * Limit how many depositories to delete.
     */
    limit?: number
  }

  /**
   * depositories without action
   */
  export type depositoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the depositories
     */
    select?: depositoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the depositories
     */
    omit?: depositoriesOmit<ExtArgs> | null
  }


  /**
   * Model entries
   */

  export type AggregateEntries = {
    _count: EntriesCountAggregateOutputType | null
    _avg: EntriesAvgAggregateOutputType | null
    _sum: EntriesSumAggregateOutputType | null
    _min: EntriesMinAggregateOutputType | null
    _max: EntriesMaxAggregateOutputType | null
  }

  export type EntriesAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type EntriesSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type EntriesMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    entryable_type: string | null
    entryable_id: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    import_id: string | null
    notes: string | null
    excluded: boolean | null
    plaid_id: string | null
  }

  export type EntriesMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    entryable_type: string | null
    entryable_id: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    import_id: string | null
    notes: string | null
    excluded: boolean | null
    plaid_id: string | null
  }

  export type EntriesCountAggregateOutputType = {
    id: number
    account_id: number
    entryable_type: number
    entryable_id: number
    amount: number
    currency: number
    date: number
    name: number
    created_at: number
    updated_at: number
    import_id: number
    notes: number
    excluded: number
    plaid_id: number
    locked_attributes: number
    _all: number
  }


  export type EntriesAvgAggregateInputType = {
    amount?: true
  }

  export type EntriesSumAggregateInputType = {
    amount?: true
  }

  export type EntriesMinAggregateInputType = {
    id?: true
    account_id?: true
    entryable_type?: true
    entryable_id?: true
    amount?: true
    currency?: true
    date?: true
    name?: true
    created_at?: true
    updated_at?: true
    import_id?: true
    notes?: true
    excluded?: true
    plaid_id?: true
  }

  export type EntriesMaxAggregateInputType = {
    id?: true
    account_id?: true
    entryable_type?: true
    entryable_id?: true
    amount?: true
    currency?: true
    date?: true
    name?: true
    created_at?: true
    updated_at?: true
    import_id?: true
    notes?: true
    excluded?: true
    plaid_id?: true
  }

  export type EntriesCountAggregateInputType = {
    id?: true
    account_id?: true
    entryable_type?: true
    entryable_id?: true
    amount?: true
    currency?: true
    date?: true
    name?: true
    created_at?: true
    updated_at?: true
    import_id?: true
    notes?: true
    excluded?: true
    plaid_id?: true
    locked_attributes?: true
    _all?: true
  }

  export type EntriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entries to aggregate.
     */
    where?: entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entries to fetch.
     */
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entries
    **/
    _count?: true | EntriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntriesMaxAggregateInputType
  }

  export type GetEntriesAggregateType<T extends EntriesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntries[P]>
      : GetScalarType<T[P], AggregateEntries[P]>
  }




  export type entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entriesWhereInput
    orderBy?: entriesOrderByWithAggregationInput | entriesOrderByWithAggregationInput[]
    by: EntriesScalarFieldEnum[] | EntriesScalarFieldEnum
    having?: entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntriesCountAggregateInputType | true
    _avg?: EntriesAvgAggregateInputType
    _sum?: EntriesSumAggregateInputType
    _min?: EntriesMinAggregateInputType
    _max?: EntriesMaxAggregateInputType
  }

  export type EntriesGroupByOutputType = {
    id: string
    account_id: string
    entryable_type: string | null
    entryable_id: string | null
    amount: Decimal | null
    currency: string | null
    date: Date | null
    name: string
    created_at: Date
    updated_at: Date
    import_id: string | null
    notes: string | null
    excluded: boolean | null
    plaid_id: string | null
    locked_attributes: JsonValue | null
    _count: EntriesCountAggregateOutputType | null
    _avg: EntriesAvgAggregateOutputType | null
    _sum: EntriesSumAggregateOutputType | null
    _min: EntriesMinAggregateOutputType | null
    _max: EntriesMaxAggregateOutputType | null
  }

  type GetEntriesGroupByPayload<T extends entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntriesGroupByOutputType[P]>
            : GetScalarType<T[P], EntriesGroupByOutputType[P]>
        }
      >
    >


  export type entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    entryable_type?: boolean
    entryable_id?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_id?: boolean
    notes?: boolean
    excluded?: boolean
    plaid_id?: boolean
    locked_attributes?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }, ExtArgs["result"]["entries"]>

  export type entriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    entryable_type?: boolean
    entryable_id?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_id?: boolean
    notes?: boolean
    excluded?: boolean
    plaid_id?: boolean
    locked_attributes?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }, ExtArgs["result"]["entries"]>

  export type entriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    entryable_type?: boolean
    entryable_id?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_id?: boolean
    notes?: boolean
    excluded?: boolean
    plaid_id?: boolean
    locked_attributes?: boolean
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }, ExtArgs["result"]["entries"]>

  export type entriesSelectScalar = {
    id?: boolean
    account_id?: boolean
    entryable_type?: boolean
    entryable_id?: boolean
    amount?: boolean
    currency?: boolean
    date?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_id?: boolean
    notes?: boolean
    excluded?: boolean
    plaid_id?: boolean
    locked_attributes?: boolean
  }

  export type entriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "entryable_type" | "entryable_id" | "amount" | "currency" | "date" | "name" | "created_at" | "updated_at" | "import_id" | "notes" | "excluded" | "plaid_id" | "locked_attributes", ExtArgs["result"]["entries"]>
  export type entriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }
  export type entriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }
  export type entriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
    imports?: boolean | entries$importsArgs<ExtArgs>
  }

  export type $entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entries"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>
      imports: Prisma.$importsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      entryable_type: string | null
      entryable_id: string | null
      amount: Prisma.Decimal | null
      currency: string | null
      date: Date | null
      name: string
      created_at: Date
      updated_at: Date
      import_id: string | null
      notes: string | null
      excluded: boolean | null
      plaid_id: string | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["entries"]>
    composites: {}
  }

  type entriesGetPayload<S extends boolean | null | undefined | entriesDefaultArgs> = $Result.GetResult<Prisma.$entriesPayload, S>

  type entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<entriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntriesCountAggregateInputType | true
    }

  export interface entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entries'], meta: { name: 'entries' } }
    /**
     * Find zero or one Entries that matches the filter.
     * @param {entriesFindUniqueArgs} args - Arguments to find a Entries
     * @example
     * // Get one Entries
     * const entries = await prisma.entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends entriesFindUniqueArgs>(args: SelectSubset<T, entriesFindUniqueArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entries that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {entriesFindUniqueOrThrowArgs} args - Arguments to find a Entries
     * @example
     * // Get one Entries
     * const entries = await prisma.entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesFindFirstArgs} args - Arguments to find a Entries
     * @example
     * // Get one Entries
     * const entries = await prisma.entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends entriesFindFirstArgs>(args?: SelectSubset<T, entriesFindFirstArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesFindFirstOrThrowArgs} args - Arguments to find a Entries
     * @example
     * // Get one Entries
     * const entries = await prisma.entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entries
     * const entries = await prisma.entries.findMany()
     * 
     * // Get first 10 Entries
     * const entries = await prisma.entries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entriesWithIdOnly = await prisma.entries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends entriesFindManyArgs>(args?: SelectSubset<T, entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entries.
     * @param {entriesCreateArgs} args - Arguments to create a Entries.
     * @example
     * // Create one Entries
     * const Entries = await prisma.entries.create({
     *   data: {
     *     // ... data to create a Entries
     *   }
     * })
     * 
     */
    create<T extends entriesCreateArgs>(args: SelectSubset<T, entriesCreateArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entries.
     * @param {entriesCreateManyArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entries = await prisma.entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends entriesCreateManyArgs>(args?: SelectSubset<T, entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entries and returns the data saved in the database.
     * @param {entriesCreateManyAndReturnArgs} args - Arguments to create many Entries.
     * @example
     * // Create many Entries
     * const entries = await prisma.entries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entries and only return the `id`
     * const entriesWithIdOnly = await prisma.entries.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends entriesCreateManyAndReturnArgs>(args?: SelectSubset<T, entriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Entries.
     * @param {entriesDeleteArgs} args - Arguments to delete one Entries.
     * @example
     * // Delete one Entries
     * const Entries = await prisma.entries.delete({
     *   where: {
     *     // ... filter to delete one Entries
     *   }
     * })
     * 
     */
    delete<T extends entriesDeleteArgs>(args: SelectSubset<T, entriesDeleteArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entries.
     * @param {entriesUpdateArgs} args - Arguments to update one Entries.
     * @example
     * // Update one Entries
     * const entries = await prisma.entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends entriesUpdateArgs>(args: SelectSubset<T, entriesUpdateArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entries.
     * @param {entriesDeleteManyArgs} args - Arguments to filter Entries to delete.
     * @example
     * // Delete a few Entries
     * const { count } = await prisma.entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends entriesDeleteManyArgs>(args?: SelectSubset<T, entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entries
     * const entries = await prisma.entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends entriesUpdateManyArgs>(args: SelectSubset<T, entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entries and returns the data updated in the database.
     * @param {entriesUpdateManyAndReturnArgs} args - Arguments to update many Entries.
     * @example
     * // Update many Entries
     * const entries = await prisma.entries.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Entries and only return the `id`
     * const entriesWithIdOnly = await prisma.entries.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends entriesUpdateManyAndReturnArgs>(args: SelectSubset<T, entriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Entries.
     * @param {entriesUpsertArgs} args - Arguments to update or create a Entries.
     * @example
     * // Update or create a Entries
     * const entries = await prisma.entries.upsert({
     *   create: {
     *     // ... data to create a Entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entries we want to update
     *   }
     * })
     */
    upsert<T extends entriesUpsertArgs>(args: SelectSubset<T, entriesUpsertArgs<ExtArgs>>): Prisma__entriesClient<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesCountArgs} args - Arguments to filter Entries to count.
     * @example
     * // Count the number of Entries
     * const count = await prisma.entries.count({
     *   where: {
     *     // ... the filter for the Entries we want to count
     *   }
     * })
    **/
    count<T extends entriesCountArgs>(
      args?: Subset<T, entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntriesAggregateArgs>(args: Subset<T, EntriesAggregateArgs>): Prisma.PrismaPromise<GetEntriesAggregateType<T>>

    /**
     * Group by Entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entriesGroupByArgs['orderBy'] }
        : { orderBy?: entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entries model
   */
  readonly fields: entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    imports<T extends entries$importsArgs<ExtArgs> = {}>(args?: Subset<T, entries$importsArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the entries model
   */
  interface entriesFieldRefs {
    readonly id: FieldRef<"entries", 'String'>
    readonly account_id: FieldRef<"entries", 'String'>
    readonly entryable_type: FieldRef<"entries", 'String'>
    readonly entryable_id: FieldRef<"entries", 'String'>
    readonly amount: FieldRef<"entries", 'Decimal'>
    readonly currency: FieldRef<"entries", 'String'>
    readonly date: FieldRef<"entries", 'DateTime'>
    readonly name: FieldRef<"entries", 'String'>
    readonly created_at: FieldRef<"entries", 'DateTime'>
    readonly updated_at: FieldRef<"entries", 'DateTime'>
    readonly import_id: FieldRef<"entries", 'String'>
    readonly notes: FieldRef<"entries", 'String'>
    readonly excluded: FieldRef<"entries", 'Boolean'>
    readonly plaid_id: FieldRef<"entries", 'String'>
    readonly locked_attributes: FieldRef<"entries", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * entries findUnique
   */
  export type entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter, which entries to fetch.
     */
    where: entriesWhereUniqueInput
  }

  /**
   * entries findUniqueOrThrow
   */
  export type entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter, which entries to fetch.
     */
    where: entriesWhereUniqueInput
  }

  /**
   * entries findFirst
   */
  export type entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter, which entries to fetch.
     */
    where?: entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entries to fetch.
     */
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entries.
     */
    cursor?: entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entries.
     */
    distinct?: EntriesScalarFieldEnum | EntriesScalarFieldEnum[]
  }

  /**
   * entries findFirstOrThrow
   */
  export type entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter, which entries to fetch.
     */
    where?: entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entries to fetch.
     */
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entries.
     */
    cursor?: entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entries.
     */
    distinct?: EntriesScalarFieldEnum | EntriesScalarFieldEnum[]
  }

  /**
   * entries findMany
   */
  export type entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter, which entries to fetch.
     */
    where?: entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entries to fetch.
     */
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entries.
     */
    cursor?: entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entries.
     */
    skip?: number
    distinct?: EntriesScalarFieldEnum | EntriesScalarFieldEnum[]
  }

  /**
   * entries create
   */
  export type entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * The data needed to create a entries.
     */
    data: XOR<entriesCreateInput, entriesUncheckedCreateInput>
  }

  /**
   * entries createMany
   */
  export type entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entries.
     */
    data: entriesCreateManyInput | entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entries createManyAndReturn
   */
  export type entriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * The data used to create many entries.
     */
    data: entriesCreateManyInput | entriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * entries update
   */
  export type entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * The data needed to update a entries.
     */
    data: XOR<entriesUpdateInput, entriesUncheckedUpdateInput>
    /**
     * Choose, which entries to update.
     */
    where: entriesWhereUniqueInput
  }

  /**
   * entries updateMany
   */
  export type entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entries.
     */
    data: XOR<entriesUpdateManyMutationInput, entriesUncheckedUpdateManyInput>
    /**
     * Filter which entries to update
     */
    where?: entriesWhereInput
    /**
     * Limit how many entries to update.
     */
    limit?: number
  }

  /**
   * entries updateManyAndReturn
   */
  export type entriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * The data used to update entries.
     */
    data: XOR<entriesUpdateManyMutationInput, entriesUncheckedUpdateManyInput>
    /**
     * Filter which entries to update
     */
    where?: entriesWhereInput
    /**
     * Limit how many entries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * entries upsert
   */
  export type entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * The filter to search for the entries to update in case it exists.
     */
    where: entriesWhereUniqueInput
    /**
     * In case the entries found by the `where` argument doesn't exist, create a new entries with this data.
     */
    create: XOR<entriesCreateInput, entriesUncheckedCreateInput>
    /**
     * In case the entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entriesUpdateInput, entriesUncheckedUpdateInput>
  }

  /**
   * entries delete
   */
  export type entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    /**
     * Filter which entries to delete.
     */
    where: entriesWhereUniqueInput
  }

  /**
   * entries deleteMany
   */
  export type entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entries to delete
     */
    where?: entriesWhereInput
    /**
     * Limit how many entries to delete.
     */
    limit?: number
  }

  /**
   * entries.imports
   */
  export type entries$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    where?: importsWhereInput
  }

  /**
   * entries without action
   */
  export type entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
  }


  /**
   * Model exchange_rates
   */

  export type AggregateExchange_rates = {
    _count: Exchange_ratesCountAggregateOutputType | null
    _avg: Exchange_ratesAvgAggregateOutputType | null
    _sum: Exchange_ratesSumAggregateOutputType | null
    _min: Exchange_ratesMinAggregateOutputType | null
    _max: Exchange_ratesMaxAggregateOutputType | null
  }

  export type Exchange_ratesAvgAggregateOutputType = {
    rate: Decimal | null
  }

  export type Exchange_ratesSumAggregateOutputType = {
    rate: Decimal | null
  }

  export type Exchange_ratesMinAggregateOutputType = {
    id: string | null
    from_currency: string | null
    to_currency: string | null
    rate: Decimal | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Exchange_ratesMaxAggregateOutputType = {
    id: string | null
    from_currency: string | null
    to_currency: string | null
    rate: Decimal | null
    date: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Exchange_ratesCountAggregateOutputType = {
    id: number
    from_currency: number
    to_currency: number
    rate: number
    date: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Exchange_ratesAvgAggregateInputType = {
    rate?: true
  }

  export type Exchange_ratesSumAggregateInputType = {
    rate?: true
  }

  export type Exchange_ratesMinAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type Exchange_ratesMaxAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
    created_at?: true
    updated_at?: true
  }

  export type Exchange_ratesCountAggregateInputType = {
    id?: true
    from_currency?: true
    to_currency?: true
    rate?: true
    date?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Exchange_ratesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exchange_rates to aggregate.
     */
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     */
    orderBy?: exchange_ratesOrderByWithRelationInput | exchange_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exchange_rates
    **/
    _count?: true | Exchange_ratesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exchange_ratesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exchange_ratesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exchange_ratesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exchange_ratesMaxAggregateInputType
  }

  export type GetExchange_ratesAggregateType<T extends Exchange_ratesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchange_rates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchange_rates[P]>
      : GetScalarType<T[P], AggregateExchange_rates[P]>
  }




  export type exchange_ratesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exchange_ratesWhereInput
    orderBy?: exchange_ratesOrderByWithAggregationInput | exchange_ratesOrderByWithAggregationInput[]
    by: Exchange_ratesScalarFieldEnum[] | Exchange_ratesScalarFieldEnum
    having?: exchange_ratesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exchange_ratesCountAggregateInputType | true
    _avg?: Exchange_ratesAvgAggregateInputType
    _sum?: Exchange_ratesSumAggregateInputType
    _min?: Exchange_ratesMinAggregateInputType
    _max?: Exchange_ratesMaxAggregateInputType
  }

  export type Exchange_ratesGroupByOutputType = {
    id: string
    from_currency: string
    to_currency: string
    rate: Decimal
    date: Date
    created_at: Date
    updated_at: Date
    _count: Exchange_ratesCountAggregateOutputType | null
    _avg: Exchange_ratesAvgAggregateOutputType | null
    _sum: Exchange_ratesSumAggregateOutputType | null
    _min: Exchange_ratesMinAggregateOutputType | null
    _max: Exchange_ratesMaxAggregateOutputType | null
  }

  type GetExchange_ratesGroupByPayload<T extends exchange_ratesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Exchange_ratesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exchange_ratesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exchange_ratesGroupByOutputType[P]>
            : GetScalarType<T[P], Exchange_ratesGroupByOutputType[P]>
        }
      >
    >


  export type exchange_ratesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["exchange_rates"]>

  export type exchange_ratesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["exchange_rates"]>

  export type exchange_ratesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["exchange_rates"]>

  export type exchange_ratesSelectScalar = {
    id?: boolean
    from_currency?: boolean
    to_currency?: boolean
    rate?: boolean
    date?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type exchange_ratesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "from_currency" | "to_currency" | "rate" | "date" | "created_at" | "updated_at", ExtArgs["result"]["exchange_rates"]>

  export type $exchange_ratesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exchange_rates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      from_currency: string
      to_currency: string
      rate: Prisma.Decimal
      date: Date
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["exchange_rates"]>
    composites: {}
  }

  type exchange_ratesGetPayload<S extends boolean | null | undefined | exchange_ratesDefaultArgs> = $Result.GetResult<Prisma.$exchange_ratesPayload, S>

  type exchange_ratesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exchange_ratesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Exchange_ratesCountAggregateInputType | true
    }

  export interface exchange_ratesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exchange_rates'], meta: { name: 'exchange_rates' } }
    /**
     * Find zero or one Exchange_rates that matches the filter.
     * @param {exchange_ratesFindUniqueArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exchange_ratesFindUniqueArgs>(args: SelectSubset<T, exchange_ratesFindUniqueArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exchange_rates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exchange_ratesFindUniqueOrThrowArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exchange_ratesFindUniqueOrThrowArgs>(args: SelectSubset<T, exchange_ratesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchange_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindFirstArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exchange_ratesFindFirstArgs>(args?: SelectSubset<T, exchange_ratesFindFirstArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchange_rates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindFirstOrThrowArgs} args - Arguments to find a Exchange_rates
     * @example
     * // Get one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exchange_ratesFindFirstOrThrowArgs>(args?: SelectSubset<T, exchange_ratesFindFirstOrThrowArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exchange_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findMany()
     * 
     * // Get first 10 Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchange_ratesWithIdOnly = await prisma.exchange_rates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends exchange_ratesFindManyArgs>(args?: SelectSubset<T, exchange_ratesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exchange_rates.
     * @param {exchange_ratesCreateArgs} args - Arguments to create a Exchange_rates.
     * @example
     * // Create one Exchange_rates
     * const Exchange_rates = await prisma.exchange_rates.create({
     *   data: {
     *     // ... data to create a Exchange_rates
     *   }
     * })
     * 
     */
    create<T extends exchange_ratesCreateArgs>(args: SelectSubset<T, exchange_ratesCreateArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exchange_rates.
     * @param {exchange_ratesCreateManyArgs} args - Arguments to create many Exchange_rates.
     * @example
     * // Create many Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exchange_ratesCreateManyArgs>(args?: SelectSubset<T, exchange_ratesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exchange_rates and returns the data saved in the database.
     * @param {exchange_ratesCreateManyAndReturnArgs} args - Arguments to create many Exchange_rates.
     * @example
     * // Create many Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exchange_rates and only return the `id`
     * const exchange_ratesWithIdOnly = await prisma.exchange_rates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends exchange_ratesCreateManyAndReturnArgs>(args?: SelectSubset<T, exchange_ratesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exchange_rates.
     * @param {exchange_ratesDeleteArgs} args - Arguments to delete one Exchange_rates.
     * @example
     * // Delete one Exchange_rates
     * const Exchange_rates = await prisma.exchange_rates.delete({
     *   where: {
     *     // ... filter to delete one Exchange_rates
     *   }
     * })
     * 
     */
    delete<T extends exchange_ratesDeleteArgs>(args: SelectSubset<T, exchange_ratesDeleteArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exchange_rates.
     * @param {exchange_ratesUpdateArgs} args - Arguments to update one Exchange_rates.
     * @example
     * // Update one Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exchange_ratesUpdateArgs>(args: SelectSubset<T, exchange_ratesUpdateArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exchange_rates.
     * @param {exchange_ratesDeleteManyArgs} args - Arguments to filter Exchange_rates to delete.
     * @example
     * // Delete a few Exchange_rates
     * const { count } = await prisma.exchange_rates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exchange_ratesDeleteManyArgs>(args?: SelectSubset<T, exchange_ratesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exchange_ratesUpdateManyArgs>(args: SelectSubset<T, exchange_ratesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchange_rates and returns the data updated in the database.
     * @param {exchange_ratesUpdateManyAndReturnArgs} args - Arguments to update many Exchange_rates.
     * @example
     * // Update many Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exchange_rates and only return the `id`
     * const exchange_ratesWithIdOnly = await prisma.exchange_rates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends exchange_ratesUpdateManyAndReturnArgs>(args: SelectSubset<T, exchange_ratesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exchange_rates.
     * @param {exchange_ratesUpsertArgs} args - Arguments to update or create a Exchange_rates.
     * @example
     * // Update or create a Exchange_rates
     * const exchange_rates = await prisma.exchange_rates.upsert({
     *   create: {
     *     // ... data to create a Exchange_rates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchange_rates we want to update
     *   }
     * })
     */
    upsert<T extends exchange_ratesUpsertArgs>(args: SelectSubset<T, exchange_ratesUpsertArgs<ExtArgs>>): Prisma__exchange_ratesClient<$Result.GetResult<Prisma.$exchange_ratesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesCountArgs} args - Arguments to filter Exchange_rates to count.
     * @example
     * // Count the number of Exchange_rates
     * const count = await prisma.exchange_rates.count({
     *   where: {
     *     // ... the filter for the Exchange_rates we want to count
     *   }
     * })
    **/
    count<T extends exchange_ratesCountArgs>(
      args?: Subset<T, exchange_ratesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exchange_ratesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exchange_ratesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exchange_ratesAggregateArgs>(args: Subset<T, Exchange_ratesAggregateArgs>): Prisma.PrismaPromise<GetExchange_ratesAggregateType<T>>

    /**
     * Group by Exchange_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchange_ratesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exchange_ratesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exchange_ratesGroupByArgs['orderBy'] }
        : { orderBy?: exchange_ratesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exchange_ratesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchange_ratesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exchange_rates model
   */
  readonly fields: exchange_ratesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exchange_rates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exchange_ratesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exchange_rates model
   */
  interface exchange_ratesFieldRefs {
    readonly id: FieldRef<"exchange_rates", 'String'>
    readonly from_currency: FieldRef<"exchange_rates", 'String'>
    readonly to_currency: FieldRef<"exchange_rates", 'String'>
    readonly rate: FieldRef<"exchange_rates", 'Decimal'>
    readonly date: FieldRef<"exchange_rates", 'DateTime'>
    readonly created_at: FieldRef<"exchange_rates", 'DateTime'>
    readonly updated_at: FieldRef<"exchange_rates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exchange_rates findUnique
   */
  export type exchange_ratesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter, which exchange_rates to fetch.
     */
    where: exchange_ratesWhereUniqueInput
  }

  /**
   * exchange_rates findUniqueOrThrow
   */
  export type exchange_ratesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter, which exchange_rates to fetch.
     */
    where: exchange_ratesWhereUniqueInput
  }

  /**
   * exchange_rates findFirst
   */
  export type exchange_ratesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter, which exchange_rates to fetch.
     */
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     */
    orderBy?: exchange_ratesOrderByWithRelationInput | exchange_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchange_rates.
     */
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchange_rates.
     */
    distinct?: Exchange_ratesScalarFieldEnum | Exchange_ratesScalarFieldEnum[]
  }

  /**
   * exchange_rates findFirstOrThrow
   */
  export type exchange_ratesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter, which exchange_rates to fetch.
     */
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     */
    orderBy?: exchange_ratesOrderByWithRelationInput | exchange_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchange_rates.
     */
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchange_rates.
     */
    distinct?: Exchange_ratesScalarFieldEnum | Exchange_ratesScalarFieldEnum[]
  }

  /**
   * exchange_rates findMany
   */
  export type exchange_ratesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter, which exchange_rates to fetch.
     */
    where?: exchange_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchange_rates to fetch.
     */
    orderBy?: exchange_ratesOrderByWithRelationInput | exchange_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exchange_rates.
     */
    cursor?: exchange_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchange_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchange_rates.
     */
    skip?: number
    distinct?: Exchange_ratesScalarFieldEnum | Exchange_ratesScalarFieldEnum[]
  }

  /**
   * exchange_rates create
   */
  export type exchange_ratesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * The data needed to create a exchange_rates.
     */
    data: XOR<exchange_ratesCreateInput, exchange_ratesUncheckedCreateInput>
  }

  /**
   * exchange_rates createMany
   */
  export type exchange_ratesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exchange_rates.
     */
    data: exchange_ratesCreateManyInput | exchange_ratesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exchange_rates createManyAndReturn
   */
  export type exchange_ratesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * The data used to create many exchange_rates.
     */
    data: exchange_ratesCreateManyInput | exchange_ratesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exchange_rates update
   */
  export type exchange_ratesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * The data needed to update a exchange_rates.
     */
    data: XOR<exchange_ratesUpdateInput, exchange_ratesUncheckedUpdateInput>
    /**
     * Choose, which exchange_rates to update.
     */
    where: exchange_ratesWhereUniqueInput
  }

  /**
   * exchange_rates updateMany
   */
  export type exchange_ratesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exchange_rates.
     */
    data: XOR<exchange_ratesUpdateManyMutationInput, exchange_ratesUncheckedUpdateManyInput>
    /**
     * Filter which exchange_rates to update
     */
    where?: exchange_ratesWhereInput
    /**
     * Limit how many exchange_rates to update.
     */
    limit?: number
  }

  /**
   * exchange_rates updateManyAndReturn
   */
  export type exchange_ratesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * The data used to update exchange_rates.
     */
    data: XOR<exchange_ratesUpdateManyMutationInput, exchange_ratesUncheckedUpdateManyInput>
    /**
     * Filter which exchange_rates to update
     */
    where?: exchange_ratesWhereInput
    /**
     * Limit how many exchange_rates to update.
     */
    limit?: number
  }

  /**
   * exchange_rates upsert
   */
  export type exchange_ratesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * The filter to search for the exchange_rates to update in case it exists.
     */
    where: exchange_ratesWhereUniqueInput
    /**
     * In case the exchange_rates found by the `where` argument doesn't exist, create a new exchange_rates with this data.
     */
    create: XOR<exchange_ratesCreateInput, exchange_ratesUncheckedCreateInput>
    /**
     * In case the exchange_rates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exchange_ratesUpdateInput, exchange_ratesUncheckedUpdateInput>
  }

  /**
   * exchange_rates delete
   */
  export type exchange_ratesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
    /**
     * Filter which exchange_rates to delete.
     */
    where: exchange_ratesWhereUniqueInput
  }

  /**
   * exchange_rates deleteMany
   */
  export type exchange_ratesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exchange_rates to delete
     */
    where?: exchange_ratesWhereInput
    /**
     * Limit how many exchange_rates to delete.
     */
    limit?: number
  }

  /**
   * exchange_rates without action
   */
  export type exchange_ratesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchange_rates
     */
    select?: exchange_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchange_rates
     */
    omit?: exchange_ratesOmit<ExtArgs> | null
  }


  /**
   * Model families
   */

  export type AggregateFamilies = {
    _count: FamiliesCountAggregateOutputType | null
    _min: FamiliesMinAggregateOutputType | null
    _max: FamiliesMaxAggregateOutputType | null
  }

  export type FamiliesMinAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    currency: string | null
    locale: string | null
    stripe_plan_id: string | null
    stripe_customer_id: string | null
    stripe_subscription_status: string | null
    date_format: string | null
    country: string | null
    last_synced_at: Date | null
    timezone: string | null
    data_enrichment_enabled: boolean | null
    trial_started_at: Date | null
    early_access: boolean | null
  }

  export type FamiliesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    currency: string | null
    locale: string | null
    stripe_plan_id: string | null
    stripe_customer_id: string | null
    stripe_subscription_status: string | null
    date_format: string | null
    country: string | null
    last_synced_at: Date | null
    timezone: string | null
    data_enrichment_enabled: boolean | null
    trial_started_at: Date | null
    early_access: boolean | null
  }

  export type FamiliesCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    currency: number
    locale: number
    stripe_plan_id: number
    stripe_customer_id: number
    stripe_subscription_status: number
    date_format: number
    country: number
    last_synced_at: number
    timezone: number
    data_enrichment_enabled: number
    trial_started_at: number
    early_access: number
    _all: number
  }


  export type FamiliesMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    currency?: true
    locale?: true
    stripe_plan_id?: true
    stripe_customer_id?: true
    stripe_subscription_status?: true
    date_format?: true
    country?: true
    last_synced_at?: true
    timezone?: true
    data_enrichment_enabled?: true
    trial_started_at?: true
    early_access?: true
  }

  export type FamiliesMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    currency?: true
    locale?: true
    stripe_plan_id?: true
    stripe_customer_id?: true
    stripe_subscription_status?: true
    date_format?: true
    country?: true
    last_synced_at?: true
    timezone?: true
    data_enrichment_enabled?: true
    trial_started_at?: true
    early_access?: true
  }

  export type FamiliesCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    currency?: true
    locale?: true
    stripe_plan_id?: true
    stripe_customer_id?: true
    stripe_subscription_status?: true
    date_format?: true
    country?: true
    last_synced_at?: true
    timezone?: true
    data_enrichment_enabled?: true
    trial_started_at?: true
    early_access?: true
    _all?: true
  }

  export type FamiliesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which families to aggregate.
     */
    where?: familiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of families to fetch.
     */
    orderBy?: familiesOrderByWithRelationInput | familiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: familiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned families
    **/
    _count?: true | FamiliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamiliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamiliesMaxAggregateInputType
  }

  export type GetFamiliesAggregateType<T extends FamiliesAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilies[P]>
      : GetScalarType<T[P], AggregateFamilies[P]>
  }




  export type familiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: familiesWhereInput
    orderBy?: familiesOrderByWithAggregationInput | familiesOrderByWithAggregationInput[]
    by: FamiliesScalarFieldEnum[] | FamiliesScalarFieldEnum
    having?: familiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamiliesCountAggregateInputType | true
    _min?: FamiliesMinAggregateInputType
    _max?: FamiliesMaxAggregateInputType
  }

  export type FamiliesGroupByOutputType = {
    id: string
    name: string | null
    created_at: Date
    updated_at: Date
    currency: string | null
    locale: string | null
    stripe_plan_id: string | null
    stripe_customer_id: string | null
    stripe_subscription_status: string | null
    date_format: string | null
    country: string | null
    last_synced_at: Date | null
    timezone: string | null
    data_enrichment_enabled: boolean | null
    trial_started_at: Date | null
    early_access: boolean | null
    _count: FamiliesCountAggregateOutputType | null
    _min: FamiliesMinAggregateOutputType | null
    _max: FamiliesMaxAggregateOutputType | null
  }

  type GetFamiliesGroupByPayload<T extends familiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamiliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamiliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamiliesGroupByOutputType[P]>
            : GetScalarType<T[P], FamiliesGroupByOutputType[P]>
        }
      >
    >


  export type familiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locale?: boolean
    stripe_plan_id?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_status?: boolean
    date_format?: boolean
    country?: boolean
    last_synced_at?: boolean
    timezone?: boolean
    data_enrichment_enabled?: boolean
    trial_started_at?: boolean
    early_access?: boolean
    accounts?: boolean | families$accountsArgs<ExtArgs>
    budgets?: boolean | families$budgetsArgs<ExtArgs>
    categories?: boolean | families$categoriesArgs<ExtArgs>
    imports?: boolean | families$importsArgs<ExtArgs>
    invitations?: boolean | families$invitationsArgs<ExtArgs>
    merchants?: boolean | families$merchantsArgs<ExtArgs>
    plaid_items?: boolean | families$plaid_itemsArgs<ExtArgs>
    rules?: boolean | families$rulesArgs<ExtArgs>
    tags?: boolean | families$tagsArgs<ExtArgs>
    users?: boolean | families$usersArgs<ExtArgs>
    _count?: boolean | FamiliesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["families"]>

  export type familiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locale?: boolean
    stripe_plan_id?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_status?: boolean
    date_format?: boolean
    country?: boolean
    last_synced_at?: boolean
    timezone?: boolean
    data_enrichment_enabled?: boolean
    trial_started_at?: boolean
    early_access?: boolean
  }, ExtArgs["result"]["families"]>

  export type familiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locale?: boolean
    stripe_plan_id?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_status?: boolean
    date_format?: boolean
    country?: boolean
    last_synced_at?: boolean
    timezone?: boolean
    data_enrichment_enabled?: boolean
    trial_started_at?: boolean
    early_access?: boolean
  }, ExtArgs["result"]["families"]>

  export type familiesSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locale?: boolean
    stripe_plan_id?: boolean
    stripe_customer_id?: boolean
    stripe_subscription_status?: boolean
    date_format?: boolean
    country?: boolean
    last_synced_at?: boolean
    timezone?: boolean
    data_enrichment_enabled?: boolean
    trial_started_at?: boolean
    early_access?: boolean
  }

  export type familiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "created_at" | "updated_at" | "currency" | "locale" | "stripe_plan_id" | "stripe_customer_id" | "stripe_subscription_status" | "date_format" | "country" | "last_synced_at" | "timezone" | "data_enrichment_enabled" | "trial_started_at" | "early_access", ExtArgs["result"]["families"]>
  export type familiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | families$accountsArgs<ExtArgs>
    budgets?: boolean | families$budgetsArgs<ExtArgs>
    categories?: boolean | families$categoriesArgs<ExtArgs>
    imports?: boolean | families$importsArgs<ExtArgs>
    invitations?: boolean | families$invitationsArgs<ExtArgs>
    merchants?: boolean | families$merchantsArgs<ExtArgs>
    plaid_items?: boolean | families$plaid_itemsArgs<ExtArgs>
    rules?: boolean | families$rulesArgs<ExtArgs>
    tags?: boolean | families$tagsArgs<ExtArgs>
    users?: boolean | families$usersArgs<ExtArgs>
    _count?: boolean | FamiliesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type familiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type familiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $familiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "families"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      budgets: Prisma.$budgetsPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs>[]
      imports: Prisma.$importsPayload<ExtArgs>[]
      invitations: Prisma.$invitationsPayload<ExtArgs>[]
      merchants: Prisma.$merchantsPayload<ExtArgs>[]
      plaid_items: Prisma.$plaid_itemsPayload<ExtArgs>[]
      rules: Prisma.$rulesPayload<ExtArgs>[]
      tags: Prisma.$tagsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      created_at: Date
      updated_at: Date
      currency: string | null
      locale: string | null
      stripe_plan_id: string | null
      stripe_customer_id: string | null
      stripe_subscription_status: string | null
      date_format: string | null
      country: string | null
      last_synced_at: Date | null
      timezone: string | null
      data_enrichment_enabled: boolean | null
      trial_started_at: Date | null
      early_access: boolean | null
    }, ExtArgs["result"]["families"]>
    composites: {}
  }

  type familiesGetPayload<S extends boolean | null | undefined | familiesDefaultArgs> = $Result.GetResult<Prisma.$familiesPayload, S>

  type familiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<familiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamiliesCountAggregateInputType | true
    }

  export interface familiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['families'], meta: { name: 'families' } }
    /**
     * Find zero or one Families that matches the filter.
     * @param {familiesFindUniqueArgs} args - Arguments to find a Families
     * @example
     * // Get one Families
     * const families = await prisma.families.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends familiesFindUniqueArgs>(args: SelectSubset<T, familiesFindUniqueArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Families that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {familiesFindUniqueOrThrowArgs} args - Arguments to find a Families
     * @example
     * // Get one Families
     * const families = await prisma.families.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends familiesFindUniqueOrThrowArgs>(args: SelectSubset<T, familiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Families that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesFindFirstArgs} args - Arguments to find a Families
     * @example
     * // Get one Families
     * const families = await prisma.families.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends familiesFindFirstArgs>(args?: SelectSubset<T, familiesFindFirstArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Families that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesFindFirstOrThrowArgs} args - Arguments to find a Families
     * @example
     * // Get one Families
     * const families = await prisma.families.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends familiesFindFirstOrThrowArgs>(args?: SelectSubset<T, familiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Families that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Families
     * const families = await prisma.families.findMany()
     * 
     * // Get first 10 Families
     * const families = await prisma.families.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familiesWithIdOnly = await prisma.families.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends familiesFindManyArgs>(args?: SelectSubset<T, familiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Families.
     * @param {familiesCreateArgs} args - Arguments to create a Families.
     * @example
     * // Create one Families
     * const Families = await prisma.families.create({
     *   data: {
     *     // ... data to create a Families
     *   }
     * })
     * 
     */
    create<T extends familiesCreateArgs>(args: SelectSubset<T, familiesCreateArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Families.
     * @param {familiesCreateManyArgs} args - Arguments to create many Families.
     * @example
     * // Create many Families
     * const families = await prisma.families.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends familiesCreateManyArgs>(args?: SelectSubset<T, familiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Families and returns the data saved in the database.
     * @param {familiesCreateManyAndReturnArgs} args - Arguments to create many Families.
     * @example
     * // Create many Families
     * const families = await prisma.families.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Families and only return the `id`
     * const familiesWithIdOnly = await prisma.families.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends familiesCreateManyAndReturnArgs>(args?: SelectSubset<T, familiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Families.
     * @param {familiesDeleteArgs} args - Arguments to delete one Families.
     * @example
     * // Delete one Families
     * const Families = await prisma.families.delete({
     *   where: {
     *     // ... filter to delete one Families
     *   }
     * })
     * 
     */
    delete<T extends familiesDeleteArgs>(args: SelectSubset<T, familiesDeleteArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Families.
     * @param {familiesUpdateArgs} args - Arguments to update one Families.
     * @example
     * // Update one Families
     * const families = await prisma.families.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends familiesUpdateArgs>(args: SelectSubset<T, familiesUpdateArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Families.
     * @param {familiesDeleteManyArgs} args - Arguments to filter Families to delete.
     * @example
     * // Delete a few Families
     * const { count } = await prisma.families.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends familiesDeleteManyArgs>(args?: SelectSubset<T, familiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Families
     * const families = await prisma.families.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends familiesUpdateManyArgs>(args: SelectSubset<T, familiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Families and returns the data updated in the database.
     * @param {familiesUpdateManyAndReturnArgs} args - Arguments to update many Families.
     * @example
     * // Update many Families
     * const families = await prisma.families.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Families and only return the `id`
     * const familiesWithIdOnly = await prisma.families.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends familiesUpdateManyAndReturnArgs>(args: SelectSubset<T, familiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Families.
     * @param {familiesUpsertArgs} args - Arguments to update or create a Families.
     * @example
     * // Update or create a Families
     * const families = await prisma.families.upsert({
     *   create: {
     *     // ... data to create a Families
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Families we want to update
     *   }
     * })
     */
    upsert<T extends familiesUpsertArgs>(args: SelectSubset<T, familiesUpsertArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesCountArgs} args - Arguments to filter Families to count.
     * @example
     * // Count the number of Families
     * const count = await prisma.families.count({
     *   where: {
     *     // ... the filter for the Families we want to count
     *   }
     * })
    **/
    count<T extends familiesCountArgs>(
      args?: Subset<T, familiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamiliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamiliesAggregateArgs>(args: Subset<T, FamiliesAggregateArgs>): Prisma.PrismaPromise<GetFamiliesAggregateType<T>>

    /**
     * Group by Families.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {familiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends familiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: familiesGroupByArgs['orderBy'] }
        : { orderBy?: familiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, familiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamiliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the families model
   */
  readonly fields: familiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for families.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__familiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends families$accountsArgs<ExtArgs> = {}>(args?: Subset<T, families$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    budgets<T extends families$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, families$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$budgetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends families$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, families$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imports<T extends families$importsArgs<ExtArgs> = {}>(args?: Subset<T, families$importsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends families$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, families$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    merchants<T extends families$merchantsArgs<ExtArgs> = {}>(args?: Subset<T, families$merchantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plaid_items<T extends families$plaid_itemsArgs<ExtArgs> = {}>(args?: Subset<T, families$plaid_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rules<T extends families$rulesArgs<ExtArgs> = {}>(args?: Subset<T, families$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends families$tagsArgs<ExtArgs> = {}>(args?: Subset<T, families$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends families$usersArgs<ExtArgs> = {}>(args?: Subset<T, families$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the families model
   */
  interface familiesFieldRefs {
    readonly id: FieldRef<"families", 'String'>
    readonly name: FieldRef<"families", 'String'>
    readonly created_at: FieldRef<"families", 'DateTime'>
    readonly updated_at: FieldRef<"families", 'DateTime'>
    readonly currency: FieldRef<"families", 'String'>
    readonly locale: FieldRef<"families", 'String'>
    readonly stripe_plan_id: FieldRef<"families", 'String'>
    readonly stripe_customer_id: FieldRef<"families", 'String'>
    readonly stripe_subscription_status: FieldRef<"families", 'String'>
    readonly date_format: FieldRef<"families", 'String'>
    readonly country: FieldRef<"families", 'String'>
    readonly last_synced_at: FieldRef<"families", 'DateTime'>
    readonly timezone: FieldRef<"families", 'String'>
    readonly data_enrichment_enabled: FieldRef<"families", 'Boolean'>
    readonly trial_started_at: FieldRef<"families", 'DateTime'>
    readonly early_access: FieldRef<"families", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * families findUnique
   */
  export type familiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter, which families to fetch.
     */
    where: familiesWhereUniqueInput
  }

  /**
   * families findUniqueOrThrow
   */
  export type familiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter, which families to fetch.
     */
    where: familiesWhereUniqueInput
  }

  /**
   * families findFirst
   */
  export type familiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter, which families to fetch.
     */
    where?: familiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of families to fetch.
     */
    orderBy?: familiesOrderByWithRelationInput | familiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for families.
     */
    cursor?: familiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of families.
     */
    distinct?: FamiliesScalarFieldEnum | FamiliesScalarFieldEnum[]
  }

  /**
   * families findFirstOrThrow
   */
  export type familiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter, which families to fetch.
     */
    where?: familiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of families to fetch.
     */
    orderBy?: familiesOrderByWithRelationInput | familiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for families.
     */
    cursor?: familiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` families.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of families.
     */
    distinct?: FamiliesScalarFieldEnum | FamiliesScalarFieldEnum[]
  }

  /**
   * families findMany
   */
  export type familiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter, which families to fetch.
     */
    where?: familiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of families to fetch.
     */
    orderBy?: familiesOrderByWithRelationInput | familiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing families.
     */
    cursor?: familiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` families from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` families.
     */
    skip?: number
    distinct?: FamiliesScalarFieldEnum | FamiliesScalarFieldEnum[]
  }

  /**
   * families create
   */
  export type familiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * The data needed to create a families.
     */
    data: XOR<familiesCreateInput, familiesUncheckedCreateInput>
  }

  /**
   * families createMany
   */
  export type familiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many families.
     */
    data: familiesCreateManyInput | familiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * families createManyAndReturn
   */
  export type familiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * The data used to create many families.
     */
    data: familiesCreateManyInput | familiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * families update
   */
  export type familiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * The data needed to update a families.
     */
    data: XOR<familiesUpdateInput, familiesUncheckedUpdateInput>
    /**
     * Choose, which families to update.
     */
    where: familiesWhereUniqueInput
  }

  /**
   * families updateMany
   */
  export type familiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update families.
     */
    data: XOR<familiesUpdateManyMutationInput, familiesUncheckedUpdateManyInput>
    /**
     * Filter which families to update
     */
    where?: familiesWhereInput
    /**
     * Limit how many families to update.
     */
    limit?: number
  }

  /**
   * families updateManyAndReturn
   */
  export type familiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * The data used to update families.
     */
    data: XOR<familiesUpdateManyMutationInput, familiesUncheckedUpdateManyInput>
    /**
     * Filter which families to update
     */
    where?: familiesWhereInput
    /**
     * Limit how many families to update.
     */
    limit?: number
  }

  /**
   * families upsert
   */
  export type familiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * The filter to search for the families to update in case it exists.
     */
    where: familiesWhereUniqueInput
    /**
     * In case the families found by the `where` argument doesn't exist, create a new families with this data.
     */
    create: XOR<familiesCreateInput, familiesUncheckedCreateInput>
    /**
     * In case the families was found with the provided `where` argument, update it with this data.
     */
    update: XOR<familiesUpdateInput, familiesUncheckedUpdateInput>
  }

  /**
   * families delete
   */
  export type familiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    /**
     * Filter which families to delete.
     */
    where: familiesWhereUniqueInput
  }

  /**
   * families deleteMany
   */
  export type familiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which families to delete
     */
    where?: familiesWhereInput
    /**
     * Limit how many families to delete.
     */
    limit?: number
  }

  /**
   * families.accounts
   */
  export type families$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * families.budgets
   */
  export type families$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the budgets
     */
    select?: budgetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the budgets
     */
    omit?: budgetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: budgetsInclude<ExtArgs> | null
    where?: budgetsWhereInput
    orderBy?: budgetsOrderByWithRelationInput | budgetsOrderByWithRelationInput[]
    cursor?: budgetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetsScalarFieldEnum | BudgetsScalarFieldEnum[]
  }

  /**
   * families.categories
   */
  export type families$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * families.imports
   */
  export type families$importsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    where?: importsWhereInput
    orderBy?: importsOrderByWithRelationInput | importsOrderByWithRelationInput[]
    cursor?: importsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportsScalarFieldEnum | ImportsScalarFieldEnum[]
  }

  /**
   * families.invitations
   */
  export type families$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    cursor?: invitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * families.merchants
   */
  export type families$merchantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    where?: merchantsWhereInput
    orderBy?: merchantsOrderByWithRelationInput | merchantsOrderByWithRelationInput[]
    cursor?: merchantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MerchantsScalarFieldEnum | MerchantsScalarFieldEnum[]
  }

  /**
   * families.plaid_items
   */
  export type families$plaid_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    where?: plaid_itemsWhereInput
    orderBy?: plaid_itemsOrderByWithRelationInput | plaid_itemsOrderByWithRelationInput[]
    cursor?: plaid_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plaid_itemsScalarFieldEnum | Plaid_itemsScalarFieldEnum[]
  }

  /**
   * families.rules
   */
  export type families$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    where?: rulesWhereInput
    orderBy?: rulesOrderByWithRelationInput | rulesOrderByWithRelationInput[]
    cursor?: rulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RulesScalarFieldEnum | RulesScalarFieldEnum[]
  }

  /**
   * families.tags
   */
  export type families$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    cursor?: tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * families.users
   */
  export type families$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * families without action
   */
  export type familiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
  }


  /**
   * Model holdings
   */

  export type AggregateHoldings = {
    _count: HoldingsCountAggregateOutputType | null
    _avg: HoldingsAvgAggregateOutputType | null
    _sum: HoldingsSumAggregateOutputType | null
    _min: HoldingsMinAggregateOutputType | null
    _max: HoldingsMaxAggregateOutputType | null
  }

  export type HoldingsAvgAggregateOutputType = {
    qty: Decimal | null
    price: Decimal | null
    amount: Decimal | null
  }

  export type HoldingsSumAggregateOutputType = {
    qty: Decimal | null
    price: Decimal | null
    amount: Decimal | null
  }

  export type HoldingsMinAggregateOutputType = {
    id: string | null
    account_id: string | null
    security_id: string | null
    date: Date | null
    qty: Decimal | null
    price: Decimal | null
    amount: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type HoldingsMaxAggregateOutputType = {
    id: string | null
    account_id: string | null
    security_id: string | null
    date: Date | null
    qty: Decimal | null
    price: Decimal | null
    amount: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type HoldingsCountAggregateOutputType = {
    id: number
    account_id: number
    security_id: number
    date: number
    qty: number
    price: number
    amount: number
    currency: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type HoldingsAvgAggregateInputType = {
    qty?: true
    price?: true
    amount?: true
  }

  export type HoldingsSumAggregateInputType = {
    qty?: true
    price?: true
    amount?: true
  }

  export type HoldingsMinAggregateInputType = {
    id?: true
    account_id?: true
    security_id?: true
    date?: true
    qty?: true
    price?: true
    amount?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type HoldingsMaxAggregateInputType = {
    id?: true
    account_id?: true
    security_id?: true
    date?: true
    qty?: true
    price?: true
    amount?: true
    currency?: true
    created_at?: true
    updated_at?: true
  }

  export type HoldingsCountAggregateInputType = {
    id?: true
    account_id?: true
    security_id?: true
    date?: true
    qty?: true
    price?: true
    amount?: true
    currency?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type HoldingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holdings to aggregate.
     */
    where?: holdingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holdings to fetch.
     */
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: holdingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned holdings
    **/
    _count?: true | HoldingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HoldingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HoldingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HoldingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HoldingsMaxAggregateInputType
  }

  export type GetHoldingsAggregateType<T extends HoldingsAggregateArgs> = {
        [P in keyof T & keyof AggregateHoldings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoldings[P]>
      : GetScalarType<T[P], AggregateHoldings[P]>
  }




  export type holdingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holdingsWhereInput
    orderBy?: holdingsOrderByWithAggregationInput | holdingsOrderByWithAggregationInput[]
    by: HoldingsScalarFieldEnum[] | HoldingsScalarFieldEnum
    having?: holdingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HoldingsCountAggregateInputType | true
    _avg?: HoldingsAvgAggregateInputType
    _sum?: HoldingsSumAggregateInputType
    _min?: HoldingsMinAggregateInputType
    _max?: HoldingsMaxAggregateInputType
  }

  export type HoldingsGroupByOutputType = {
    id: string
    account_id: string
    security_id: string
    date: Date
    qty: Decimal
    price: Decimal
    amount: Decimal
    currency: string
    created_at: Date
    updated_at: Date
    _count: HoldingsCountAggregateOutputType | null
    _avg: HoldingsAvgAggregateOutputType | null
    _sum: HoldingsSumAggregateOutputType | null
    _min: HoldingsMinAggregateOutputType | null
    _max: HoldingsMaxAggregateOutputType | null
  }

  type GetHoldingsGroupByPayload<T extends holdingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HoldingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HoldingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HoldingsGroupByOutputType[P]>
            : GetScalarType<T[P], HoldingsGroupByOutputType[P]>
        }
      >
    >


  export type holdingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    security_id?: boolean
    date?: boolean
    qty?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holdings"]>

  export type holdingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    security_id?: boolean
    date?: boolean
    qty?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holdings"]>

  export type holdingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    security_id?: boolean
    date?: boolean
    qty?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["holdings"]>

  export type holdingsSelectScalar = {
    id?: boolean
    account_id?: boolean
    security_id?: boolean
    date?: boolean
    qty?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type holdingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "account_id" | "security_id" | "date" | "qty" | "price" | "amount" | "currency" | "created_at" | "updated_at", ExtArgs["result"]["holdings"]>
  export type holdingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type holdingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }
  export type holdingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
    accounts?: boolean | accountsDefaultArgs<ExtArgs>
  }

  export type $holdingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "holdings"
    objects: {
      securities: Prisma.$securitiesPayload<ExtArgs>
      accounts: Prisma.$accountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      account_id: string
      security_id: string
      date: Date
      qty: Prisma.Decimal
      price: Prisma.Decimal
      amount: Prisma.Decimal
      currency: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["holdings"]>
    composites: {}
  }

  type holdingsGetPayload<S extends boolean | null | undefined | holdingsDefaultArgs> = $Result.GetResult<Prisma.$holdingsPayload, S>

  type holdingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<holdingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HoldingsCountAggregateInputType | true
    }

  export interface holdingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['holdings'], meta: { name: 'holdings' } }
    /**
     * Find zero or one Holdings that matches the filter.
     * @param {holdingsFindUniqueArgs} args - Arguments to find a Holdings
     * @example
     * // Get one Holdings
     * const holdings = await prisma.holdings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends holdingsFindUniqueArgs>(args: SelectSubset<T, holdingsFindUniqueArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Holdings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {holdingsFindUniqueOrThrowArgs} args - Arguments to find a Holdings
     * @example
     * // Get one Holdings
     * const holdings = await prisma.holdings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends holdingsFindUniqueOrThrowArgs>(args: SelectSubset<T, holdingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsFindFirstArgs} args - Arguments to find a Holdings
     * @example
     * // Get one Holdings
     * const holdings = await prisma.holdings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends holdingsFindFirstArgs>(args?: SelectSubset<T, holdingsFindFirstArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holdings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsFindFirstOrThrowArgs} args - Arguments to find a Holdings
     * @example
     * // Get one Holdings
     * const holdings = await prisma.holdings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends holdingsFindFirstOrThrowArgs>(args?: SelectSubset<T, holdingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holdings
     * const holdings = await prisma.holdings.findMany()
     * 
     * // Get first 10 Holdings
     * const holdings = await prisma.holdings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holdingsWithIdOnly = await prisma.holdings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends holdingsFindManyArgs>(args?: SelectSubset<T, holdingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Holdings.
     * @param {holdingsCreateArgs} args - Arguments to create a Holdings.
     * @example
     * // Create one Holdings
     * const Holdings = await prisma.holdings.create({
     *   data: {
     *     // ... data to create a Holdings
     *   }
     * })
     * 
     */
    create<T extends holdingsCreateArgs>(args: SelectSubset<T, holdingsCreateArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holdings.
     * @param {holdingsCreateManyArgs} args - Arguments to create many Holdings.
     * @example
     * // Create many Holdings
     * const holdings = await prisma.holdings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends holdingsCreateManyArgs>(args?: SelectSubset<T, holdingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Holdings and returns the data saved in the database.
     * @param {holdingsCreateManyAndReturnArgs} args - Arguments to create many Holdings.
     * @example
     * // Create many Holdings
     * const holdings = await prisma.holdings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Holdings and only return the `id`
     * const holdingsWithIdOnly = await prisma.holdings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends holdingsCreateManyAndReturnArgs>(args?: SelectSubset<T, holdingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Holdings.
     * @param {holdingsDeleteArgs} args - Arguments to delete one Holdings.
     * @example
     * // Delete one Holdings
     * const Holdings = await prisma.holdings.delete({
     *   where: {
     *     // ... filter to delete one Holdings
     *   }
     * })
     * 
     */
    delete<T extends holdingsDeleteArgs>(args: SelectSubset<T, holdingsDeleteArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Holdings.
     * @param {holdingsUpdateArgs} args - Arguments to update one Holdings.
     * @example
     * // Update one Holdings
     * const holdings = await prisma.holdings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends holdingsUpdateArgs>(args: SelectSubset<T, holdingsUpdateArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holdings.
     * @param {holdingsDeleteManyArgs} args - Arguments to filter Holdings to delete.
     * @example
     * // Delete a few Holdings
     * const { count } = await prisma.holdings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends holdingsDeleteManyArgs>(args?: SelectSubset<T, holdingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holdings
     * const holdings = await prisma.holdings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends holdingsUpdateManyArgs>(args: SelectSubset<T, holdingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holdings and returns the data updated in the database.
     * @param {holdingsUpdateManyAndReturnArgs} args - Arguments to update many Holdings.
     * @example
     * // Update many Holdings
     * const holdings = await prisma.holdings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Holdings and only return the `id`
     * const holdingsWithIdOnly = await prisma.holdings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends holdingsUpdateManyAndReturnArgs>(args: SelectSubset<T, holdingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Holdings.
     * @param {holdingsUpsertArgs} args - Arguments to update or create a Holdings.
     * @example
     * // Update or create a Holdings
     * const holdings = await prisma.holdings.upsert({
     *   create: {
     *     // ... data to create a Holdings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holdings we want to update
     *   }
     * })
     */
    upsert<T extends holdingsUpsertArgs>(args: SelectSubset<T, holdingsUpsertArgs<ExtArgs>>): Prisma__holdingsClient<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsCountArgs} args - Arguments to filter Holdings to count.
     * @example
     * // Count the number of Holdings
     * const count = await prisma.holdings.count({
     *   where: {
     *     // ... the filter for the Holdings we want to count
     *   }
     * })
    **/
    count<T extends holdingsCountArgs>(
      args?: Subset<T, holdingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HoldingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HoldingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HoldingsAggregateArgs>(args: Subset<T, HoldingsAggregateArgs>): Prisma.PrismaPromise<GetHoldingsAggregateType<T>>

    /**
     * Group by Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holdingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends holdingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: holdingsGroupByArgs['orderBy'] }
        : { orderBy?: holdingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, holdingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHoldingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the holdings model
   */
  readonly fields: holdingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for holdings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__holdingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    securities<T extends securitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, securitiesDefaultArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    accounts<T extends accountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, accountsDefaultArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the holdings model
   */
  interface holdingsFieldRefs {
    readonly id: FieldRef<"holdings", 'String'>
    readonly account_id: FieldRef<"holdings", 'String'>
    readonly security_id: FieldRef<"holdings", 'String'>
    readonly date: FieldRef<"holdings", 'DateTime'>
    readonly qty: FieldRef<"holdings", 'Decimal'>
    readonly price: FieldRef<"holdings", 'Decimal'>
    readonly amount: FieldRef<"holdings", 'Decimal'>
    readonly currency: FieldRef<"holdings", 'String'>
    readonly created_at: FieldRef<"holdings", 'DateTime'>
    readonly updated_at: FieldRef<"holdings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * holdings findUnique
   */
  export type holdingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter, which holdings to fetch.
     */
    where: holdingsWhereUniqueInput
  }

  /**
   * holdings findUniqueOrThrow
   */
  export type holdingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter, which holdings to fetch.
     */
    where: holdingsWhereUniqueInput
  }

  /**
   * holdings findFirst
   */
  export type holdingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter, which holdings to fetch.
     */
    where?: holdingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holdings to fetch.
     */
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holdings.
     */
    cursor?: holdingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holdings.
     */
    distinct?: HoldingsScalarFieldEnum | HoldingsScalarFieldEnum[]
  }

  /**
   * holdings findFirstOrThrow
   */
  export type holdingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter, which holdings to fetch.
     */
    where?: holdingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holdings to fetch.
     */
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holdings.
     */
    cursor?: holdingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holdings.
     */
    distinct?: HoldingsScalarFieldEnum | HoldingsScalarFieldEnum[]
  }

  /**
   * holdings findMany
   */
  export type holdingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter, which holdings to fetch.
     */
    where?: holdingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holdings to fetch.
     */
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing holdings.
     */
    cursor?: holdingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holdings.
     */
    skip?: number
    distinct?: HoldingsScalarFieldEnum | HoldingsScalarFieldEnum[]
  }

  /**
   * holdings create
   */
  export type holdingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * The data needed to create a holdings.
     */
    data: XOR<holdingsCreateInput, holdingsUncheckedCreateInput>
  }

  /**
   * holdings createMany
   */
  export type holdingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many holdings.
     */
    data: holdingsCreateManyInput | holdingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * holdings createManyAndReturn
   */
  export type holdingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * The data used to create many holdings.
     */
    data: holdingsCreateManyInput | holdingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * holdings update
   */
  export type holdingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * The data needed to update a holdings.
     */
    data: XOR<holdingsUpdateInput, holdingsUncheckedUpdateInput>
    /**
     * Choose, which holdings to update.
     */
    where: holdingsWhereUniqueInput
  }

  /**
   * holdings updateMany
   */
  export type holdingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update holdings.
     */
    data: XOR<holdingsUpdateManyMutationInput, holdingsUncheckedUpdateManyInput>
    /**
     * Filter which holdings to update
     */
    where?: holdingsWhereInput
    /**
     * Limit how many holdings to update.
     */
    limit?: number
  }

  /**
   * holdings updateManyAndReturn
   */
  export type holdingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * The data used to update holdings.
     */
    data: XOR<holdingsUpdateManyMutationInput, holdingsUncheckedUpdateManyInput>
    /**
     * Filter which holdings to update
     */
    where?: holdingsWhereInput
    /**
     * Limit how many holdings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * holdings upsert
   */
  export type holdingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * The filter to search for the holdings to update in case it exists.
     */
    where: holdingsWhereUniqueInput
    /**
     * In case the holdings found by the `where` argument doesn't exist, create a new holdings with this data.
     */
    create: XOR<holdingsCreateInput, holdingsUncheckedCreateInput>
    /**
     * In case the holdings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<holdingsUpdateInput, holdingsUncheckedUpdateInput>
  }

  /**
   * holdings delete
   */
  export type holdingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    /**
     * Filter which holdings to delete.
     */
    where: holdingsWhereUniqueInput
  }

  /**
   * holdings deleteMany
   */
  export type holdingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holdings to delete
     */
    where?: holdingsWhereInput
    /**
     * Limit how many holdings to delete.
     */
    limit?: number
  }

  /**
   * holdings without action
   */
  export type holdingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
  }


  /**
   * Model impersonation_session_logs
   */

  export type AggregateImpersonation_session_logs = {
    _count: Impersonation_session_logsCountAggregateOutputType | null
    _min: Impersonation_session_logsMinAggregateOutputType | null
    _max: Impersonation_session_logsMaxAggregateOutputType | null
  }

  export type Impersonation_session_logsMinAggregateOutputType = {
    id: string | null
    impersonation_session_id: string | null
    controller: string | null
    action: string | null
    path: string | null
    method: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Impersonation_session_logsMaxAggregateOutputType = {
    id: string | null
    impersonation_session_id: string | null
    controller: string | null
    action: string | null
    path: string | null
    method: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Impersonation_session_logsCountAggregateOutputType = {
    id: number
    impersonation_session_id: number
    controller: number
    action: number
    path: number
    method: number
    ip_address: number
    user_agent: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Impersonation_session_logsMinAggregateInputType = {
    id?: true
    impersonation_session_id?: true
    controller?: true
    action?: true
    path?: true
    method?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    updated_at?: true
  }

  export type Impersonation_session_logsMaxAggregateInputType = {
    id?: true
    impersonation_session_id?: true
    controller?: true
    action?: true
    path?: true
    method?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    updated_at?: true
  }

  export type Impersonation_session_logsCountAggregateInputType = {
    id?: true
    impersonation_session_id?: true
    controller?: true
    action?: true
    path?: true
    method?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Impersonation_session_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which impersonation_session_logs to aggregate.
     */
    where?: impersonation_session_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_session_logs to fetch.
     */
    orderBy?: impersonation_session_logsOrderByWithRelationInput | impersonation_session_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: impersonation_session_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_session_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_session_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned impersonation_session_logs
    **/
    _count?: true | Impersonation_session_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Impersonation_session_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Impersonation_session_logsMaxAggregateInputType
  }

  export type GetImpersonation_session_logsAggregateType<T extends Impersonation_session_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateImpersonation_session_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpersonation_session_logs[P]>
      : GetScalarType<T[P], AggregateImpersonation_session_logs[P]>
  }




  export type impersonation_session_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: impersonation_session_logsWhereInput
    orderBy?: impersonation_session_logsOrderByWithAggregationInput | impersonation_session_logsOrderByWithAggregationInput[]
    by: Impersonation_session_logsScalarFieldEnum[] | Impersonation_session_logsScalarFieldEnum
    having?: impersonation_session_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Impersonation_session_logsCountAggregateInputType | true
    _min?: Impersonation_session_logsMinAggregateInputType
    _max?: Impersonation_session_logsMaxAggregateInputType
  }

  export type Impersonation_session_logsGroupByOutputType = {
    id: string
    impersonation_session_id: string
    controller: string | null
    action: string | null
    path: string | null
    method: string | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date
    updated_at: Date
    _count: Impersonation_session_logsCountAggregateOutputType | null
    _min: Impersonation_session_logsMinAggregateOutputType | null
    _max: Impersonation_session_logsMaxAggregateOutputType | null
  }

  type GetImpersonation_session_logsGroupByPayload<T extends impersonation_session_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Impersonation_session_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Impersonation_session_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Impersonation_session_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Impersonation_session_logsGroupByOutputType[P]>
        }
      >
    >


  export type impersonation_session_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonation_session_id?: boolean
    controller?: boolean
    action?: boolean
    path?: boolean
    method?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    updated_at?: boolean
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_session_logs"]>

  export type impersonation_session_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonation_session_id?: boolean
    controller?: boolean
    action?: boolean
    path?: boolean
    method?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    updated_at?: boolean
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_session_logs"]>

  export type impersonation_session_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonation_session_id?: boolean
    controller?: boolean
    action?: boolean
    path?: boolean
    method?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    updated_at?: boolean
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_session_logs"]>

  export type impersonation_session_logsSelectScalar = {
    id?: boolean
    impersonation_session_id?: boolean
    controller?: boolean
    action?: boolean
    path?: boolean
    method?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type impersonation_session_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "impersonation_session_id" | "controller" | "action" | "path" | "method" | "ip_address" | "user_agent" | "created_at" | "updated_at", ExtArgs["result"]["impersonation_session_logs"]>
  export type impersonation_session_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }
  export type impersonation_session_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }
  export type impersonation_session_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | impersonation_sessionsDefaultArgs<ExtArgs>
  }

  export type $impersonation_session_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "impersonation_session_logs"
    objects: {
      impersonation_sessions: Prisma.$impersonation_sessionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      impersonation_session_id: string
      controller: string | null
      action: string | null
      path: string | null
      method: string | null
      ip_address: string | null
      user_agent: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["impersonation_session_logs"]>
    composites: {}
  }

  type impersonation_session_logsGetPayload<S extends boolean | null | undefined | impersonation_session_logsDefaultArgs> = $Result.GetResult<Prisma.$impersonation_session_logsPayload, S>

  type impersonation_session_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<impersonation_session_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Impersonation_session_logsCountAggregateInputType | true
    }

  export interface impersonation_session_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['impersonation_session_logs'], meta: { name: 'impersonation_session_logs' } }
    /**
     * Find zero or one Impersonation_session_logs that matches the filter.
     * @param {impersonation_session_logsFindUniqueArgs} args - Arguments to find a Impersonation_session_logs
     * @example
     * // Get one Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends impersonation_session_logsFindUniqueArgs>(args: SelectSubset<T, impersonation_session_logsFindUniqueArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Impersonation_session_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {impersonation_session_logsFindUniqueOrThrowArgs} args - Arguments to find a Impersonation_session_logs
     * @example
     * // Get one Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends impersonation_session_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, impersonation_session_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impersonation_session_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsFindFirstArgs} args - Arguments to find a Impersonation_session_logs
     * @example
     * // Get one Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends impersonation_session_logsFindFirstArgs>(args?: SelectSubset<T, impersonation_session_logsFindFirstArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impersonation_session_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsFindFirstOrThrowArgs} args - Arguments to find a Impersonation_session_logs
     * @example
     * // Get one Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends impersonation_session_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, impersonation_session_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impersonation_session_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findMany()
     * 
     * // Get first 10 Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impersonation_session_logsWithIdOnly = await prisma.impersonation_session_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends impersonation_session_logsFindManyArgs>(args?: SelectSubset<T, impersonation_session_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Impersonation_session_logs.
     * @param {impersonation_session_logsCreateArgs} args - Arguments to create a Impersonation_session_logs.
     * @example
     * // Create one Impersonation_session_logs
     * const Impersonation_session_logs = await prisma.impersonation_session_logs.create({
     *   data: {
     *     // ... data to create a Impersonation_session_logs
     *   }
     * })
     * 
     */
    create<T extends impersonation_session_logsCreateArgs>(args: SelectSubset<T, impersonation_session_logsCreateArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Impersonation_session_logs.
     * @param {impersonation_session_logsCreateManyArgs} args - Arguments to create many Impersonation_session_logs.
     * @example
     * // Create many Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends impersonation_session_logsCreateManyArgs>(args?: SelectSubset<T, impersonation_session_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Impersonation_session_logs and returns the data saved in the database.
     * @param {impersonation_session_logsCreateManyAndReturnArgs} args - Arguments to create many Impersonation_session_logs.
     * @example
     * // Create many Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Impersonation_session_logs and only return the `id`
     * const impersonation_session_logsWithIdOnly = await prisma.impersonation_session_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends impersonation_session_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, impersonation_session_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Impersonation_session_logs.
     * @param {impersonation_session_logsDeleteArgs} args - Arguments to delete one Impersonation_session_logs.
     * @example
     * // Delete one Impersonation_session_logs
     * const Impersonation_session_logs = await prisma.impersonation_session_logs.delete({
     *   where: {
     *     // ... filter to delete one Impersonation_session_logs
     *   }
     * })
     * 
     */
    delete<T extends impersonation_session_logsDeleteArgs>(args: SelectSubset<T, impersonation_session_logsDeleteArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Impersonation_session_logs.
     * @param {impersonation_session_logsUpdateArgs} args - Arguments to update one Impersonation_session_logs.
     * @example
     * // Update one Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends impersonation_session_logsUpdateArgs>(args: SelectSubset<T, impersonation_session_logsUpdateArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Impersonation_session_logs.
     * @param {impersonation_session_logsDeleteManyArgs} args - Arguments to filter Impersonation_session_logs to delete.
     * @example
     * // Delete a few Impersonation_session_logs
     * const { count } = await prisma.impersonation_session_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends impersonation_session_logsDeleteManyArgs>(args?: SelectSubset<T, impersonation_session_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impersonation_session_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends impersonation_session_logsUpdateManyArgs>(args: SelectSubset<T, impersonation_session_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impersonation_session_logs and returns the data updated in the database.
     * @param {impersonation_session_logsUpdateManyAndReturnArgs} args - Arguments to update many Impersonation_session_logs.
     * @example
     * // Update many Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Impersonation_session_logs and only return the `id`
     * const impersonation_session_logsWithIdOnly = await prisma.impersonation_session_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends impersonation_session_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, impersonation_session_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Impersonation_session_logs.
     * @param {impersonation_session_logsUpsertArgs} args - Arguments to update or create a Impersonation_session_logs.
     * @example
     * // Update or create a Impersonation_session_logs
     * const impersonation_session_logs = await prisma.impersonation_session_logs.upsert({
     *   create: {
     *     // ... data to create a Impersonation_session_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Impersonation_session_logs we want to update
     *   }
     * })
     */
    upsert<T extends impersonation_session_logsUpsertArgs>(args: SelectSubset<T, impersonation_session_logsUpsertArgs<ExtArgs>>): Prisma__impersonation_session_logsClient<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Impersonation_session_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsCountArgs} args - Arguments to filter Impersonation_session_logs to count.
     * @example
     * // Count the number of Impersonation_session_logs
     * const count = await prisma.impersonation_session_logs.count({
     *   where: {
     *     // ... the filter for the Impersonation_session_logs we want to count
     *   }
     * })
    **/
    count<T extends impersonation_session_logsCountArgs>(
      args?: Subset<T, impersonation_session_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Impersonation_session_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Impersonation_session_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Impersonation_session_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Impersonation_session_logsAggregateArgs>(args: Subset<T, Impersonation_session_logsAggregateArgs>): Prisma.PrismaPromise<GetImpersonation_session_logsAggregateType<T>>

    /**
     * Group by Impersonation_session_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_session_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends impersonation_session_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: impersonation_session_logsGroupByArgs['orderBy'] }
        : { orderBy?: impersonation_session_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, impersonation_session_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpersonation_session_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the impersonation_session_logs model
   */
  readonly fields: impersonation_session_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for impersonation_session_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__impersonation_session_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    impersonation_sessions<T extends impersonation_sessionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, impersonation_sessionsDefaultArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the impersonation_session_logs model
   */
  interface impersonation_session_logsFieldRefs {
    readonly id: FieldRef<"impersonation_session_logs", 'String'>
    readonly impersonation_session_id: FieldRef<"impersonation_session_logs", 'String'>
    readonly controller: FieldRef<"impersonation_session_logs", 'String'>
    readonly action: FieldRef<"impersonation_session_logs", 'String'>
    readonly path: FieldRef<"impersonation_session_logs", 'String'>
    readonly method: FieldRef<"impersonation_session_logs", 'String'>
    readonly ip_address: FieldRef<"impersonation_session_logs", 'String'>
    readonly user_agent: FieldRef<"impersonation_session_logs", 'String'>
    readonly created_at: FieldRef<"impersonation_session_logs", 'DateTime'>
    readonly updated_at: FieldRef<"impersonation_session_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * impersonation_session_logs findUnique
   */
  export type impersonation_session_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_session_logs to fetch.
     */
    where: impersonation_session_logsWhereUniqueInput
  }

  /**
   * impersonation_session_logs findUniqueOrThrow
   */
  export type impersonation_session_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_session_logs to fetch.
     */
    where: impersonation_session_logsWhereUniqueInput
  }

  /**
   * impersonation_session_logs findFirst
   */
  export type impersonation_session_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_session_logs to fetch.
     */
    where?: impersonation_session_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_session_logs to fetch.
     */
    orderBy?: impersonation_session_logsOrderByWithRelationInput | impersonation_session_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for impersonation_session_logs.
     */
    cursor?: impersonation_session_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_session_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_session_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of impersonation_session_logs.
     */
    distinct?: Impersonation_session_logsScalarFieldEnum | Impersonation_session_logsScalarFieldEnum[]
  }

  /**
   * impersonation_session_logs findFirstOrThrow
   */
  export type impersonation_session_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_session_logs to fetch.
     */
    where?: impersonation_session_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_session_logs to fetch.
     */
    orderBy?: impersonation_session_logsOrderByWithRelationInput | impersonation_session_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for impersonation_session_logs.
     */
    cursor?: impersonation_session_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_session_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_session_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of impersonation_session_logs.
     */
    distinct?: Impersonation_session_logsScalarFieldEnum | Impersonation_session_logsScalarFieldEnum[]
  }

  /**
   * impersonation_session_logs findMany
   */
  export type impersonation_session_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_session_logs to fetch.
     */
    where?: impersonation_session_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_session_logs to fetch.
     */
    orderBy?: impersonation_session_logsOrderByWithRelationInput | impersonation_session_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing impersonation_session_logs.
     */
    cursor?: impersonation_session_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_session_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_session_logs.
     */
    skip?: number
    distinct?: Impersonation_session_logsScalarFieldEnum | Impersonation_session_logsScalarFieldEnum[]
  }

  /**
   * impersonation_session_logs create
   */
  export type impersonation_session_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a impersonation_session_logs.
     */
    data: XOR<impersonation_session_logsCreateInput, impersonation_session_logsUncheckedCreateInput>
  }

  /**
   * impersonation_session_logs createMany
   */
  export type impersonation_session_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many impersonation_session_logs.
     */
    data: impersonation_session_logsCreateManyInput | impersonation_session_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * impersonation_session_logs createManyAndReturn
   */
  export type impersonation_session_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * The data used to create many impersonation_session_logs.
     */
    data: impersonation_session_logsCreateManyInput | impersonation_session_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * impersonation_session_logs update
   */
  export type impersonation_session_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a impersonation_session_logs.
     */
    data: XOR<impersonation_session_logsUpdateInput, impersonation_session_logsUncheckedUpdateInput>
    /**
     * Choose, which impersonation_session_logs to update.
     */
    where: impersonation_session_logsWhereUniqueInput
  }

  /**
   * impersonation_session_logs updateMany
   */
  export type impersonation_session_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update impersonation_session_logs.
     */
    data: XOR<impersonation_session_logsUpdateManyMutationInput, impersonation_session_logsUncheckedUpdateManyInput>
    /**
     * Filter which impersonation_session_logs to update
     */
    where?: impersonation_session_logsWhereInput
    /**
     * Limit how many impersonation_session_logs to update.
     */
    limit?: number
  }

  /**
   * impersonation_session_logs updateManyAndReturn
   */
  export type impersonation_session_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * The data used to update impersonation_session_logs.
     */
    data: XOR<impersonation_session_logsUpdateManyMutationInput, impersonation_session_logsUncheckedUpdateManyInput>
    /**
     * Filter which impersonation_session_logs to update
     */
    where?: impersonation_session_logsWhereInput
    /**
     * Limit how many impersonation_session_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * impersonation_session_logs upsert
   */
  export type impersonation_session_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the impersonation_session_logs to update in case it exists.
     */
    where: impersonation_session_logsWhereUniqueInput
    /**
     * In case the impersonation_session_logs found by the `where` argument doesn't exist, create a new impersonation_session_logs with this data.
     */
    create: XOR<impersonation_session_logsCreateInput, impersonation_session_logsUncheckedCreateInput>
    /**
     * In case the impersonation_session_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<impersonation_session_logsUpdateInput, impersonation_session_logsUncheckedUpdateInput>
  }

  /**
   * impersonation_session_logs delete
   */
  export type impersonation_session_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    /**
     * Filter which impersonation_session_logs to delete.
     */
    where: impersonation_session_logsWhereUniqueInput
  }

  /**
   * impersonation_session_logs deleteMany
   */
  export type impersonation_session_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which impersonation_session_logs to delete
     */
    where?: impersonation_session_logsWhereInput
    /**
     * Limit how many impersonation_session_logs to delete.
     */
    limit?: number
  }

  /**
   * impersonation_session_logs without action
   */
  export type impersonation_session_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
  }


  /**
   * Model impersonation_sessions
   */

  export type AggregateImpersonation_sessions = {
    _count: Impersonation_sessionsCountAggregateOutputType | null
    _min: Impersonation_sessionsMinAggregateOutputType | null
    _max: Impersonation_sessionsMaxAggregateOutputType | null
  }

  export type Impersonation_sessionsMinAggregateOutputType = {
    id: string | null
    impersonator_id: string | null
    impersonated_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Impersonation_sessionsMaxAggregateOutputType = {
    id: string | null
    impersonator_id: string | null
    impersonated_id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Impersonation_sessionsCountAggregateOutputType = {
    id: number
    impersonator_id: number
    impersonated_id: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Impersonation_sessionsMinAggregateInputType = {
    id?: true
    impersonator_id?: true
    impersonated_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Impersonation_sessionsMaxAggregateInputType = {
    id?: true
    impersonator_id?: true
    impersonated_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Impersonation_sessionsCountAggregateInputType = {
    id?: true
    impersonator_id?: true
    impersonated_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Impersonation_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which impersonation_sessions to aggregate.
     */
    where?: impersonation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_sessions to fetch.
     */
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: impersonation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned impersonation_sessions
    **/
    _count?: true | Impersonation_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Impersonation_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Impersonation_sessionsMaxAggregateInputType
  }

  export type GetImpersonation_sessionsAggregateType<T extends Impersonation_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateImpersonation_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpersonation_sessions[P]>
      : GetScalarType<T[P], AggregateImpersonation_sessions[P]>
  }




  export type impersonation_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: impersonation_sessionsWhereInput
    orderBy?: impersonation_sessionsOrderByWithAggregationInput | impersonation_sessionsOrderByWithAggregationInput[]
    by: Impersonation_sessionsScalarFieldEnum[] | Impersonation_sessionsScalarFieldEnum
    having?: impersonation_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Impersonation_sessionsCountAggregateInputType | true
    _min?: Impersonation_sessionsMinAggregateInputType
    _max?: Impersonation_sessionsMaxAggregateInputType
  }

  export type Impersonation_sessionsGroupByOutputType = {
    id: string
    impersonator_id: string
    impersonated_id: string
    status: string
    created_at: Date
    updated_at: Date
    _count: Impersonation_sessionsCountAggregateOutputType | null
    _min: Impersonation_sessionsMinAggregateOutputType | null
    _max: Impersonation_sessionsMaxAggregateOutputType | null
  }

  type GetImpersonation_sessionsGroupByPayload<T extends impersonation_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Impersonation_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Impersonation_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Impersonation_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Impersonation_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type impersonation_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonator_id?: boolean
    impersonated_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    impersonation_session_logs?: boolean | impersonation_sessions$impersonation_session_logsArgs<ExtArgs>
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    sessions?: boolean | impersonation_sessions$sessionsArgs<ExtArgs>
    _count?: boolean | Impersonation_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_sessions"]>

  export type impersonation_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonator_id?: boolean
    impersonated_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_sessions"]>

  export type impersonation_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    impersonator_id?: boolean
    impersonated_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impersonation_sessions"]>

  export type impersonation_sessionsSelectScalar = {
    id?: boolean
    impersonator_id?: boolean
    impersonated_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type impersonation_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "impersonator_id" | "impersonated_id" | "status" | "created_at" | "updated_at", ExtArgs["result"]["impersonation_sessions"]>
  export type impersonation_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_session_logs?: boolean | impersonation_sessions$impersonation_session_logsArgs<ExtArgs>
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    sessions?: boolean | impersonation_sessions$sessionsArgs<ExtArgs>
    _count?: boolean | Impersonation_sessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type impersonation_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type impersonation_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_impersonation_sessions_impersonator_idTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_impersonation_sessions_impersonated_idTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $impersonation_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "impersonation_sessions"
    objects: {
      impersonation_session_logs: Prisma.$impersonation_session_logsPayload<ExtArgs>[]
      users_impersonation_sessions_impersonator_idTousers: Prisma.$usersPayload<ExtArgs>
      users_impersonation_sessions_impersonated_idTousers: Prisma.$usersPayload<ExtArgs>
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      impersonator_id: string
      impersonated_id: string
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["impersonation_sessions"]>
    composites: {}
  }

  type impersonation_sessionsGetPayload<S extends boolean | null | undefined | impersonation_sessionsDefaultArgs> = $Result.GetResult<Prisma.$impersonation_sessionsPayload, S>

  type impersonation_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<impersonation_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Impersonation_sessionsCountAggregateInputType | true
    }

  export interface impersonation_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['impersonation_sessions'], meta: { name: 'impersonation_sessions' } }
    /**
     * Find zero or one Impersonation_sessions that matches the filter.
     * @param {impersonation_sessionsFindUniqueArgs} args - Arguments to find a Impersonation_sessions
     * @example
     * // Get one Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends impersonation_sessionsFindUniqueArgs>(args: SelectSubset<T, impersonation_sessionsFindUniqueArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Impersonation_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {impersonation_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Impersonation_sessions
     * @example
     * // Get one Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends impersonation_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, impersonation_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impersonation_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsFindFirstArgs} args - Arguments to find a Impersonation_sessions
     * @example
     * // Get one Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends impersonation_sessionsFindFirstArgs>(args?: SelectSubset<T, impersonation_sessionsFindFirstArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impersonation_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsFindFirstOrThrowArgs} args - Arguments to find a Impersonation_sessions
     * @example
     * // Get one Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends impersonation_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, impersonation_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impersonation_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findMany()
     * 
     * // Get first 10 Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impersonation_sessionsWithIdOnly = await prisma.impersonation_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends impersonation_sessionsFindManyArgs>(args?: SelectSubset<T, impersonation_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Impersonation_sessions.
     * @param {impersonation_sessionsCreateArgs} args - Arguments to create a Impersonation_sessions.
     * @example
     * // Create one Impersonation_sessions
     * const Impersonation_sessions = await prisma.impersonation_sessions.create({
     *   data: {
     *     // ... data to create a Impersonation_sessions
     *   }
     * })
     * 
     */
    create<T extends impersonation_sessionsCreateArgs>(args: SelectSubset<T, impersonation_sessionsCreateArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Impersonation_sessions.
     * @param {impersonation_sessionsCreateManyArgs} args - Arguments to create many Impersonation_sessions.
     * @example
     * // Create many Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends impersonation_sessionsCreateManyArgs>(args?: SelectSubset<T, impersonation_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Impersonation_sessions and returns the data saved in the database.
     * @param {impersonation_sessionsCreateManyAndReturnArgs} args - Arguments to create many Impersonation_sessions.
     * @example
     * // Create many Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Impersonation_sessions and only return the `id`
     * const impersonation_sessionsWithIdOnly = await prisma.impersonation_sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends impersonation_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, impersonation_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Impersonation_sessions.
     * @param {impersonation_sessionsDeleteArgs} args - Arguments to delete one Impersonation_sessions.
     * @example
     * // Delete one Impersonation_sessions
     * const Impersonation_sessions = await prisma.impersonation_sessions.delete({
     *   where: {
     *     // ... filter to delete one Impersonation_sessions
     *   }
     * })
     * 
     */
    delete<T extends impersonation_sessionsDeleteArgs>(args: SelectSubset<T, impersonation_sessionsDeleteArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Impersonation_sessions.
     * @param {impersonation_sessionsUpdateArgs} args - Arguments to update one Impersonation_sessions.
     * @example
     * // Update one Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends impersonation_sessionsUpdateArgs>(args: SelectSubset<T, impersonation_sessionsUpdateArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Impersonation_sessions.
     * @param {impersonation_sessionsDeleteManyArgs} args - Arguments to filter Impersonation_sessions to delete.
     * @example
     * // Delete a few Impersonation_sessions
     * const { count } = await prisma.impersonation_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends impersonation_sessionsDeleteManyArgs>(args?: SelectSubset<T, impersonation_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impersonation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends impersonation_sessionsUpdateManyArgs>(args: SelectSubset<T, impersonation_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impersonation_sessions and returns the data updated in the database.
     * @param {impersonation_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Impersonation_sessions.
     * @example
     * // Update many Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Impersonation_sessions and only return the `id`
     * const impersonation_sessionsWithIdOnly = await prisma.impersonation_sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends impersonation_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, impersonation_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Impersonation_sessions.
     * @param {impersonation_sessionsUpsertArgs} args - Arguments to update or create a Impersonation_sessions.
     * @example
     * // Update or create a Impersonation_sessions
     * const impersonation_sessions = await prisma.impersonation_sessions.upsert({
     *   create: {
     *     // ... data to create a Impersonation_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Impersonation_sessions we want to update
     *   }
     * })
     */
    upsert<T extends impersonation_sessionsUpsertArgs>(args: SelectSubset<T, impersonation_sessionsUpsertArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Impersonation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsCountArgs} args - Arguments to filter Impersonation_sessions to count.
     * @example
     * // Count the number of Impersonation_sessions
     * const count = await prisma.impersonation_sessions.count({
     *   where: {
     *     // ... the filter for the Impersonation_sessions we want to count
     *   }
     * })
    **/
    count<T extends impersonation_sessionsCountArgs>(
      args?: Subset<T, impersonation_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Impersonation_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Impersonation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Impersonation_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Impersonation_sessionsAggregateArgs>(args: Subset<T, Impersonation_sessionsAggregateArgs>): Prisma.PrismaPromise<GetImpersonation_sessionsAggregateType<T>>

    /**
     * Group by Impersonation_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {impersonation_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends impersonation_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: impersonation_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: impersonation_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, impersonation_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpersonation_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the impersonation_sessions model
   */
  readonly fields: impersonation_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for impersonation_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__impersonation_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    impersonation_session_logs<T extends impersonation_sessions$impersonation_session_logsArgs<ExtArgs> = {}>(args?: Subset<T, impersonation_sessions$impersonation_session_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_session_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_impersonation_sessions_impersonator_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_impersonation_sessions_impersonated_idTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends impersonation_sessions$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, impersonation_sessions$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the impersonation_sessions model
   */
  interface impersonation_sessionsFieldRefs {
    readonly id: FieldRef<"impersonation_sessions", 'String'>
    readonly impersonator_id: FieldRef<"impersonation_sessions", 'String'>
    readonly impersonated_id: FieldRef<"impersonation_sessions", 'String'>
    readonly status: FieldRef<"impersonation_sessions", 'String'>
    readonly created_at: FieldRef<"impersonation_sessions", 'DateTime'>
    readonly updated_at: FieldRef<"impersonation_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * impersonation_sessions findUnique
   */
  export type impersonation_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_sessions to fetch.
     */
    where: impersonation_sessionsWhereUniqueInput
  }

  /**
   * impersonation_sessions findUniqueOrThrow
   */
  export type impersonation_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_sessions to fetch.
     */
    where: impersonation_sessionsWhereUniqueInput
  }

  /**
   * impersonation_sessions findFirst
   */
  export type impersonation_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_sessions to fetch.
     */
    where?: impersonation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_sessions to fetch.
     */
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for impersonation_sessions.
     */
    cursor?: impersonation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of impersonation_sessions.
     */
    distinct?: Impersonation_sessionsScalarFieldEnum | Impersonation_sessionsScalarFieldEnum[]
  }

  /**
   * impersonation_sessions findFirstOrThrow
   */
  export type impersonation_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_sessions to fetch.
     */
    where?: impersonation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_sessions to fetch.
     */
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for impersonation_sessions.
     */
    cursor?: impersonation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of impersonation_sessions.
     */
    distinct?: Impersonation_sessionsScalarFieldEnum | Impersonation_sessionsScalarFieldEnum[]
  }

  /**
   * impersonation_sessions findMany
   */
  export type impersonation_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which impersonation_sessions to fetch.
     */
    where?: impersonation_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of impersonation_sessions to fetch.
     */
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing impersonation_sessions.
     */
    cursor?: impersonation_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` impersonation_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` impersonation_sessions.
     */
    skip?: number
    distinct?: Impersonation_sessionsScalarFieldEnum | Impersonation_sessionsScalarFieldEnum[]
  }

  /**
   * impersonation_sessions create
   */
  export type impersonation_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a impersonation_sessions.
     */
    data: XOR<impersonation_sessionsCreateInput, impersonation_sessionsUncheckedCreateInput>
  }

  /**
   * impersonation_sessions createMany
   */
  export type impersonation_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many impersonation_sessions.
     */
    data: impersonation_sessionsCreateManyInput | impersonation_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * impersonation_sessions createManyAndReturn
   */
  export type impersonation_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many impersonation_sessions.
     */
    data: impersonation_sessionsCreateManyInput | impersonation_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * impersonation_sessions update
   */
  export type impersonation_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a impersonation_sessions.
     */
    data: XOR<impersonation_sessionsUpdateInput, impersonation_sessionsUncheckedUpdateInput>
    /**
     * Choose, which impersonation_sessions to update.
     */
    where: impersonation_sessionsWhereUniqueInput
  }

  /**
   * impersonation_sessions updateMany
   */
  export type impersonation_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update impersonation_sessions.
     */
    data: XOR<impersonation_sessionsUpdateManyMutationInput, impersonation_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which impersonation_sessions to update
     */
    where?: impersonation_sessionsWhereInput
    /**
     * Limit how many impersonation_sessions to update.
     */
    limit?: number
  }

  /**
   * impersonation_sessions updateManyAndReturn
   */
  export type impersonation_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update impersonation_sessions.
     */
    data: XOR<impersonation_sessionsUpdateManyMutationInput, impersonation_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which impersonation_sessions to update
     */
    where?: impersonation_sessionsWhereInput
    /**
     * Limit how many impersonation_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * impersonation_sessions upsert
   */
  export type impersonation_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the impersonation_sessions to update in case it exists.
     */
    where: impersonation_sessionsWhereUniqueInput
    /**
     * In case the impersonation_sessions found by the `where` argument doesn't exist, create a new impersonation_sessions with this data.
     */
    create: XOR<impersonation_sessionsCreateInput, impersonation_sessionsUncheckedCreateInput>
    /**
     * In case the impersonation_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<impersonation_sessionsUpdateInput, impersonation_sessionsUncheckedUpdateInput>
  }

  /**
   * impersonation_sessions delete
   */
  export type impersonation_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    /**
     * Filter which impersonation_sessions to delete.
     */
    where: impersonation_sessionsWhereUniqueInput
  }

  /**
   * impersonation_sessions deleteMany
   */
  export type impersonation_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which impersonation_sessions to delete
     */
    where?: impersonation_sessionsWhereInput
    /**
     * Limit how many impersonation_sessions to delete.
     */
    limit?: number
  }

  /**
   * impersonation_sessions.impersonation_session_logs
   */
  export type impersonation_sessions$impersonation_session_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_session_logs
     */
    select?: impersonation_session_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_session_logs
     */
    omit?: impersonation_session_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_session_logsInclude<ExtArgs> | null
    where?: impersonation_session_logsWhereInput
    orderBy?: impersonation_session_logsOrderByWithRelationInput | impersonation_session_logsOrderByWithRelationInput[]
    cursor?: impersonation_session_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Impersonation_session_logsScalarFieldEnum | Impersonation_session_logsScalarFieldEnum[]
  }

  /**
   * impersonation_sessions.sessions
   */
  export type impersonation_sessions$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * impersonation_sessions without action
   */
  export type impersonation_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model import_mappings
   */

  export type AggregateImport_mappings = {
    _count: Import_mappingsCountAggregateOutputType | null
    _min: Import_mappingsMinAggregateOutputType | null
    _max: Import_mappingsMaxAggregateOutputType | null
  }

  export type Import_mappingsMinAggregateOutputType = {
    id: string | null
    type: string | null
    key: string | null
    value: string | null
    create_when_empty: boolean | null
    import_id: string | null
    mappable_type: string | null
    mappable_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Import_mappingsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    key: string | null
    value: string | null
    create_when_empty: boolean | null
    import_id: string | null
    mappable_type: string | null
    mappable_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Import_mappingsCountAggregateOutputType = {
    id: number
    type: number
    key: number
    value: number
    create_when_empty: number
    import_id: number
    mappable_type: number
    mappable_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Import_mappingsMinAggregateInputType = {
    id?: true
    type?: true
    key?: true
    value?: true
    create_when_empty?: true
    import_id?: true
    mappable_type?: true
    mappable_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Import_mappingsMaxAggregateInputType = {
    id?: true
    type?: true
    key?: true
    value?: true
    create_when_empty?: true
    import_id?: true
    mappable_type?: true
    mappable_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Import_mappingsCountAggregateInputType = {
    id?: true
    type?: true
    key?: true
    value?: true
    create_when_empty?: true
    import_id?: true
    mappable_type?: true
    mappable_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Import_mappingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which import_mappings to aggregate.
     */
    where?: import_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_mappings to fetch.
     */
    orderBy?: import_mappingsOrderByWithRelationInput | import_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: import_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned import_mappings
    **/
    _count?: true | Import_mappingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Import_mappingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Import_mappingsMaxAggregateInputType
  }

  export type GetImport_mappingsAggregateType<T extends Import_mappingsAggregateArgs> = {
        [P in keyof T & keyof AggregateImport_mappings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImport_mappings[P]>
      : GetScalarType<T[P], AggregateImport_mappings[P]>
  }




  export type import_mappingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: import_mappingsWhereInput
    orderBy?: import_mappingsOrderByWithAggregationInput | import_mappingsOrderByWithAggregationInput[]
    by: Import_mappingsScalarFieldEnum[] | Import_mappingsScalarFieldEnum
    having?: import_mappingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Import_mappingsCountAggregateInputType | true
    _min?: Import_mappingsMinAggregateInputType
    _max?: Import_mappingsMaxAggregateInputType
  }

  export type Import_mappingsGroupByOutputType = {
    id: string
    type: string
    key: string | null
    value: string | null
    create_when_empty: boolean | null
    import_id: string
    mappable_type: string | null
    mappable_id: string | null
    created_at: Date
    updated_at: Date
    _count: Import_mappingsCountAggregateOutputType | null
    _min: Import_mappingsMinAggregateOutputType | null
    _max: Import_mappingsMaxAggregateOutputType | null
  }

  type GetImport_mappingsGroupByPayload<T extends import_mappingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Import_mappingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Import_mappingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Import_mappingsGroupByOutputType[P]>
            : GetScalarType<T[P], Import_mappingsGroupByOutputType[P]>
        }
      >
    >


  export type import_mappingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    create_when_empty?: boolean
    import_id?: boolean
    mappable_type?: boolean
    mappable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["import_mappings"]>

  export type import_mappingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    create_when_empty?: boolean
    import_id?: boolean
    mappable_type?: boolean
    mappable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["import_mappings"]>

  export type import_mappingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    create_when_empty?: boolean
    import_id?: boolean
    mappable_type?: boolean
    mappable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["import_mappings"]>

  export type import_mappingsSelectScalar = {
    id?: boolean
    type?: boolean
    key?: boolean
    value?: boolean
    create_when_empty?: boolean
    import_id?: boolean
    mappable_type?: boolean
    mappable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type import_mappingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "key" | "value" | "create_when_empty" | "import_id" | "mappable_type" | "mappable_id" | "created_at" | "updated_at", ExtArgs["result"]["import_mappings"]>

  export type $import_mappingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "import_mappings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      key: string | null
      value: string | null
      create_when_empty: boolean | null
      import_id: string
      mappable_type: string | null
      mappable_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["import_mappings"]>
    composites: {}
  }

  type import_mappingsGetPayload<S extends boolean | null | undefined | import_mappingsDefaultArgs> = $Result.GetResult<Prisma.$import_mappingsPayload, S>

  type import_mappingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<import_mappingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Import_mappingsCountAggregateInputType | true
    }

  export interface import_mappingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['import_mappings'], meta: { name: 'import_mappings' } }
    /**
     * Find zero or one Import_mappings that matches the filter.
     * @param {import_mappingsFindUniqueArgs} args - Arguments to find a Import_mappings
     * @example
     * // Get one Import_mappings
     * const import_mappings = await prisma.import_mappings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends import_mappingsFindUniqueArgs>(args: SelectSubset<T, import_mappingsFindUniqueArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Import_mappings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {import_mappingsFindUniqueOrThrowArgs} args - Arguments to find a Import_mappings
     * @example
     * // Get one Import_mappings
     * const import_mappings = await prisma.import_mappings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends import_mappingsFindUniqueOrThrowArgs>(args: SelectSubset<T, import_mappingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Import_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsFindFirstArgs} args - Arguments to find a Import_mappings
     * @example
     * // Get one Import_mappings
     * const import_mappings = await prisma.import_mappings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends import_mappingsFindFirstArgs>(args?: SelectSubset<T, import_mappingsFindFirstArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Import_mappings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsFindFirstOrThrowArgs} args - Arguments to find a Import_mappings
     * @example
     * // Get one Import_mappings
     * const import_mappings = await prisma.import_mappings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends import_mappingsFindFirstOrThrowArgs>(args?: SelectSubset<T, import_mappingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Import_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Import_mappings
     * const import_mappings = await prisma.import_mappings.findMany()
     * 
     * // Get first 10 Import_mappings
     * const import_mappings = await prisma.import_mappings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const import_mappingsWithIdOnly = await prisma.import_mappings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends import_mappingsFindManyArgs>(args?: SelectSubset<T, import_mappingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Import_mappings.
     * @param {import_mappingsCreateArgs} args - Arguments to create a Import_mappings.
     * @example
     * // Create one Import_mappings
     * const Import_mappings = await prisma.import_mappings.create({
     *   data: {
     *     // ... data to create a Import_mappings
     *   }
     * })
     * 
     */
    create<T extends import_mappingsCreateArgs>(args: SelectSubset<T, import_mappingsCreateArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Import_mappings.
     * @param {import_mappingsCreateManyArgs} args - Arguments to create many Import_mappings.
     * @example
     * // Create many Import_mappings
     * const import_mappings = await prisma.import_mappings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends import_mappingsCreateManyArgs>(args?: SelectSubset<T, import_mappingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Import_mappings and returns the data saved in the database.
     * @param {import_mappingsCreateManyAndReturnArgs} args - Arguments to create many Import_mappings.
     * @example
     * // Create many Import_mappings
     * const import_mappings = await prisma.import_mappings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Import_mappings and only return the `id`
     * const import_mappingsWithIdOnly = await prisma.import_mappings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends import_mappingsCreateManyAndReturnArgs>(args?: SelectSubset<T, import_mappingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Import_mappings.
     * @param {import_mappingsDeleteArgs} args - Arguments to delete one Import_mappings.
     * @example
     * // Delete one Import_mappings
     * const Import_mappings = await prisma.import_mappings.delete({
     *   where: {
     *     // ... filter to delete one Import_mappings
     *   }
     * })
     * 
     */
    delete<T extends import_mappingsDeleteArgs>(args: SelectSubset<T, import_mappingsDeleteArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Import_mappings.
     * @param {import_mappingsUpdateArgs} args - Arguments to update one Import_mappings.
     * @example
     * // Update one Import_mappings
     * const import_mappings = await prisma.import_mappings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends import_mappingsUpdateArgs>(args: SelectSubset<T, import_mappingsUpdateArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Import_mappings.
     * @param {import_mappingsDeleteManyArgs} args - Arguments to filter Import_mappings to delete.
     * @example
     * // Delete a few Import_mappings
     * const { count } = await prisma.import_mappings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends import_mappingsDeleteManyArgs>(args?: SelectSubset<T, import_mappingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Import_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Import_mappings
     * const import_mappings = await prisma.import_mappings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends import_mappingsUpdateManyArgs>(args: SelectSubset<T, import_mappingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Import_mappings and returns the data updated in the database.
     * @param {import_mappingsUpdateManyAndReturnArgs} args - Arguments to update many Import_mappings.
     * @example
     * // Update many Import_mappings
     * const import_mappings = await prisma.import_mappings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Import_mappings and only return the `id`
     * const import_mappingsWithIdOnly = await prisma.import_mappings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends import_mappingsUpdateManyAndReturnArgs>(args: SelectSubset<T, import_mappingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Import_mappings.
     * @param {import_mappingsUpsertArgs} args - Arguments to update or create a Import_mappings.
     * @example
     * // Update or create a Import_mappings
     * const import_mappings = await prisma.import_mappings.upsert({
     *   create: {
     *     // ... data to create a Import_mappings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Import_mappings we want to update
     *   }
     * })
     */
    upsert<T extends import_mappingsUpsertArgs>(args: SelectSubset<T, import_mappingsUpsertArgs<ExtArgs>>): Prisma__import_mappingsClient<$Result.GetResult<Prisma.$import_mappingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Import_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsCountArgs} args - Arguments to filter Import_mappings to count.
     * @example
     * // Count the number of Import_mappings
     * const count = await prisma.import_mappings.count({
     *   where: {
     *     // ... the filter for the Import_mappings we want to count
     *   }
     * })
    **/
    count<T extends import_mappingsCountArgs>(
      args?: Subset<T, import_mappingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Import_mappingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Import_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Import_mappingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Import_mappingsAggregateArgs>(args: Subset<T, Import_mappingsAggregateArgs>): Prisma.PrismaPromise<GetImport_mappingsAggregateType<T>>

    /**
     * Group by Import_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_mappingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends import_mappingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: import_mappingsGroupByArgs['orderBy'] }
        : { orderBy?: import_mappingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, import_mappingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImport_mappingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the import_mappings model
   */
  readonly fields: import_mappingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for import_mappings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__import_mappingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the import_mappings model
   */
  interface import_mappingsFieldRefs {
    readonly id: FieldRef<"import_mappings", 'String'>
    readonly type: FieldRef<"import_mappings", 'String'>
    readonly key: FieldRef<"import_mappings", 'String'>
    readonly value: FieldRef<"import_mappings", 'String'>
    readonly create_when_empty: FieldRef<"import_mappings", 'Boolean'>
    readonly import_id: FieldRef<"import_mappings", 'String'>
    readonly mappable_type: FieldRef<"import_mappings", 'String'>
    readonly mappable_id: FieldRef<"import_mappings", 'String'>
    readonly created_at: FieldRef<"import_mappings", 'DateTime'>
    readonly updated_at: FieldRef<"import_mappings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * import_mappings findUnique
   */
  export type import_mappingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter, which import_mappings to fetch.
     */
    where: import_mappingsWhereUniqueInput
  }

  /**
   * import_mappings findUniqueOrThrow
   */
  export type import_mappingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter, which import_mappings to fetch.
     */
    where: import_mappingsWhereUniqueInput
  }

  /**
   * import_mappings findFirst
   */
  export type import_mappingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter, which import_mappings to fetch.
     */
    where?: import_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_mappings to fetch.
     */
    orderBy?: import_mappingsOrderByWithRelationInput | import_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for import_mappings.
     */
    cursor?: import_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of import_mappings.
     */
    distinct?: Import_mappingsScalarFieldEnum | Import_mappingsScalarFieldEnum[]
  }

  /**
   * import_mappings findFirstOrThrow
   */
  export type import_mappingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter, which import_mappings to fetch.
     */
    where?: import_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_mappings to fetch.
     */
    orderBy?: import_mappingsOrderByWithRelationInput | import_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for import_mappings.
     */
    cursor?: import_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of import_mappings.
     */
    distinct?: Import_mappingsScalarFieldEnum | Import_mappingsScalarFieldEnum[]
  }

  /**
   * import_mappings findMany
   */
  export type import_mappingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter, which import_mappings to fetch.
     */
    where?: import_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_mappings to fetch.
     */
    orderBy?: import_mappingsOrderByWithRelationInput | import_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing import_mappings.
     */
    cursor?: import_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_mappings.
     */
    skip?: number
    distinct?: Import_mappingsScalarFieldEnum | Import_mappingsScalarFieldEnum[]
  }

  /**
   * import_mappings create
   */
  export type import_mappingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * The data needed to create a import_mappings.
     */
    data: XOR<import_mappingsCreateInput, import_mappingsUncheckedCreateInput>
  }

  /**
   * import_mappings createMany
   */
  export type import_mappingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many import_mappings.
     */
    data: import_mappingsCreateManyInput | import_mappingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * import_mappings createManyAndReturn
   */
  export type import_mappingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * The data used to create many import_mappings.
     */
    data: import_mappingsCreateManyInput | import_mappingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * import_mappings update
   */
  export type import_mappingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * The data needed to update a import_mappings.
     */
    data: XOR<import_mappingsUpdateInput, import_mappingsUncheckedUpdateInput>
    /**
     * Choose, which import_mappings to update.
     */
    where: import_mappingsWhereUniqueInput
  }

  /**
   * import_mappings updateMany
   */
  export type import_mappingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update import_mappings.
     */
    data: XOR<import_mappingsUpdateManyMutationInput, import_mappingsUncheckedUpdateManyInput>
    /**
     * Filter which import_mappings to update
     */
    where?: import_mappingsWhereInput
    /**
     * Limit how many import_mappings to update.
     */
    limit?: number
  }

  /**
   * import_mappings updateManyAndReturn
   */
  export type import_mappingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * The data used to update import_mappings.
     */
    data: XOR<import_mappingsUpdateManyMutationInput, import_mappingsUncheckedUpdateManyInput>
    /**
     * Filter which import_mappings to update
     */
    where?: import_mappingsWhereInput
    /**
     * Limit how many import_mappings to update.
     */
    limit?: number
  }

  /**
   * import_mappings upsert
   */
  export type import_mappingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * The filter to search for the import_mappings to update in case it exists.
     */
    where: import_mappingsWhereUniqueInput
    /**
     * In case the import_mappings found by the `where` argument doesn't exist, create a new import_mappings with this data.
     */
    create: XOR<import_mappingsCreateInput, import_mappingsUncheckedCreateInput>
    /**
     * In case the import_mappings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<import_mappingsUpdateInput, import_mappingsUncheckedUpdateInput>
  }

  /**
   * import_mappings delete
   */
  export type import_mappingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
    /**
     * Filter which import_mappings to delete.
     */
    where: import_mappingsWhereUniqueInput
  }

  /**
   * import_mappings deleteMany
   */
  export type import_mappingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which import_mappings to delete
     */
    where?: import_mappingsWhereInput
    /**
     * Limit how many import_mappings to delete.
     */
    limit?: number
  }

  /**
   * import_mappings without action
   */
  export type import_mappingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_mappings
     */
    select?: import_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_mappings
     */
    omit?: import_mappingsOmit<ExtArgs> | null
  }


  /**
   * Model import_rows
   */

  export type AggregateImport_rows = {
    _count: Import_rowsCountAggregateOutputType | null
    _min: Import_rowsMinAggregateOutputType | null
    _max: Import_rowsMaxAggregateOutputType | null
  }

  export type Import_rowsMinAggregateOutputType = {
    id: string | null
    import_id: string | null
    account: string | null
    date: string | null
    qty: string | null
    ticker: string | null
    price: string | null
    amount: string | null
    currency: string | null
    name: string | null
    category: string | null
    tags: string | null
    entity_type: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    exchange_operating_mic: string | null
  }

  export type Import_rowsMaxAggregateOutputType = {
    id: string | null
    import_id: string | null
    account: string | null
    date: string | null
    qty: string | null
    ticker: string | null
    price: string | null
    amount: string | null
    currency: string | null
    name: string | null
    category: string | null
    tags: string | null
    entity_type: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
    exchange_operating_mic: string | null
  }

  export type Import_rowsCountAggregateOutputType = {
    id: number
    import_id: number
    account: number
    date: number
    qty: number
    ticker: number
    price: number
    amount: number
    currency: number
    name: number
    category: number
    tags: number
    entity_type: number
    notes: number
    created_at: number
    updated_at: number
    exchange_operating_mic: number
    _all: number
  }


  export type Import_rowsMinAggregateInputType = {
    id?: true
    import_id?: true
    account?: true
    date?: true
    qty?: true
    ticker?: true
    price?: true
    amount?: true
    currency?: true
    name?: true
    category?: true
    tags?: true
    entity_type?: true
    notes?: true
    created_at?: true
    updated_at?: true
    exchange_operating_mic?: true
  }

  export type Import_rowsMaxAggregateInputType = {
    id?: true
    import_id?: true
    account?: true
    date?: true
    qty?: true
    ticker?: true
    price?: true
    amount?: true
    currency?: true
    name?: true
    category?: true
    tags?: true
    entity_type?: true
    notes?: true
    created_at?: true
    updated_at?: true
    exchange_operating_mic?: true
  }

  export type Import_rowsCountAggregateInputType = {
    id?: true
    import_id?: true
    account?: true
    date?: true
    qty?: true
    ticker?: true
    price?: true
    amount?: true
    currency?: true
    name?: true
    category?: true
    tags?: true
    entity_type?: true
    notes?: true
    created_at?: true
    updated_at?: true
    exchange_operating_mic?: true
    _all?: true
  }

  export type Import_rowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which import_rows to aggregate.
     */
    where?: import_rowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_rows to fetch.
     */
    orderBy?: import_rowsOrderByWithRelationInput | import_rowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: import_rowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned import_rows
    **/
    _count?: true | Import_rowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Import_rowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Import_rowsMaxAggregateInputType
  }

  export type GetImport_rowsAggregateType<T extends Import_rowsAggregateArgs> = {
        [P in keyof T & keyof AggregateImport_rows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImport_rows[P]>
      : GetScalarType<T[P], AggregateImport_rows[P]>
  }




  export type import_rowsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: import_rowsWhereInput
    orderBy?: import_rowsOrderByWithAggregationInput | import_rowsOrderByWithAggregationInput[]
    by: Import_rowsScalarFieldEnum[] | Import_rowsScalarFieldEnum
    having?: import_rowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Import_rowsCountAggregateInputType | true
    _min?: Import_rowsMinAggregateInputType
    _max?: Import_rowsMaxAggregateInputType
  }

  export type Import_rowsGroupByOutputType = {
    id: string
    import_id: string
    account: string | null
    date: string | null
    qty: string | null
    ticker: string | null
    price: string | null
    amount: string | null
    currency: string | null
    name: string | null
    category: string | null
    tags: string | null
    entity_type: string | null
    notes: string | null
    created_at: Date
    updated_at: Date
    exchange_operating_mic: string | null
    _count: Import_rowsCountAggregateOutputType | null
    _min: Import_rowsMinAggregateOutputType | null
    _max: Import_rowsMaxAggregateOutputType | null
  }

  type GetImport_rowsGroupByPayload<T extends import_rowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Import_rowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Import_rowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Import_rowsGroupByOutputType[P]>
            : GetScalarType<T[P], Import_rowsGroupByOutputType[P]>
        }
      >
    >


  export type import_rowsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    import_id?: boolean
    account?: boolean
    date?: boolean
    qty?: boolean
    ticker?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    name?: boolean
    category?: boolean
    tags?: boolean
    entity_type?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    exchange_operating_mic?: boolean
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["import_rows"]>

  export type import_rowsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    import_id?: boolean
    account?: boolean
    date?: boolean
    qty?: boolean
    ticker?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    name?: boolean
    category?: boolean
    tags?: boolean
    entity_type?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    exchange_operating_mic?: boolean
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["import_rows"]>

  export type import_rowsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    import_id?: boolean
    account?: boolean
    date?: boolean
    qty?: boolean
    ticker?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    name?: boolean
    category?: boolean
    tags?: boolean
    entity_type?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    exchange_operating_mic?: boolean
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["import_rows"]>

  export type import_rowsSelectScalar = {
    id?: boolean
    import_id?: boolean
    account?: boolean
    date?: boolean
    qty?: boolean
    ticker?: boolean
    price?: boolean
    amount?: boolean
    currency?: boolean
    name?: boolean
    category?: boolean
    tags?: boolean
    entity_type?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    exchange_operating_mic?: boolean
  }

  export type import_rowsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "import_id" | "account" | "date" | "qty" | "ticker" | "price" | "amount" | "currency" | "name" | "category" | "tags" | "entity_type" | "notes" | "created_at" | "updated_at" | "exchange_operating_mic", ExtArgs["result"]["import_rows"]>
  export type import_rowsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }
  export type import_rowsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }
  export type import_rowsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imports?: boolean | importsDefaultArgs<ExtArgs>
  }

  export type $import_rowsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "import_rows"
    objects: {
      imports: Prisma.$importsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      import_id: string
      account: string | null
      date: string | null
      qty: string | null
      ticker: string | null
      price: string | null
      amount: string | null
      currency: string | null
      name: string | null
      category: string | null
      tags: string | null
      entity_type: string | null
      notes: string | null
      created_at: Date
      updated_at: Date
      exchange_operating_mic: string | null
    }, ExtArgs["result"]["import_rows"]>
    composites: {}
  }

  type import_rowsGetPayload<S extends boolean | null | undefined | import_rowsDefaultArgs> = $Result.GetResult<Prisma.$import_rowsPayload, S>

  type import_rowsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<import_rowsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Import_rowsCountAggregateInputType | true
    }

  export interface import_rowsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['import_rows'], meta: { name: 'import_rows' } }
    /**
     * Find zero or one Import_rows that matches the filter.
     * @param {import_rowsFindUniqueArgs} args - Arguments to find a Import_rows
     * @example
     * // Get one Import_rows
     * const import_rows = await prisma.import_rows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends import_rowsFindUniqueArgs>(args: SelectSubset<T, import_rowsFindUniqueArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Import_rows that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {import_rowsFindUniqueOrThrowArgs} args - Arguments to find a Import_rows
     * @example
     * // Get one Import_rows
     * const import_rows = await prisma.import_rows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends import_rowsFindUniqueOrThrowArgs>(args: SelectSubset<T, import_rowsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Import_rows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsFindFirstArgs} args - Arguments to find a Import_rows
     * @example
     * // Get one Import_rows
     * const import_rows = await prisma.import_rows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends import_rowsFindFirstArgs>(args?: SelectSubset<T, import_rowsFindFirstArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Import_rows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsFindFirstOrThrowArgs} args - Arguments to find a Import_rows
     * @example
     * // Get one Import_rows
     * const import_rows = await prisma.import_rows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends import_rowsFindFirstOrThrowArgs>(args?: SelectSubset<T, import_rowsFindFirstOrThrowArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Import_rows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Import_rows
     * const import_rows = await prisma.import_rows.findMany()
     * 
     * // Get first 10 Import_rows
     * const import_rows = await prisma.import_rows.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const import_rowsWithIdOnly = await prisma.import_rows.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends import_rowsFindManyArgs>(args?: SelectSubset<T, import_rowsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Import_rows.
     * @param {import_rowsCreateArgs} args - Arguments to create a Import_rows.
     * @example
     * // Create one Import_rows
     * const Import_rows = await prisma.import_rows.create({
     *   data: {
     *     // ... data to create a Import_rows
     *   }
     * })
     * 
     */
    create<T extends import_rowsCreateArgs>(args: SelectSubset<T, import_rowsCreateArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Import_rows.
     * @param {import_rowsCreateManyArgs} args - Arguments to create many Import_rows.
     * @example
     * // Create many Import_rows
     * const import_rows = await prisma.import_rows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends import_rowsCreateManyArgs>(args?: SelectSubset<T, import_rowsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Import_rows and returns the data saved in the database.
     * @param {import_rowsCreateManyAndReturnArgs} args - Arguments to create many Import_rows.
     * @example
     * // Create many Import_rows
     * const import_rows = await prisma.import_rows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Import_rows and only return the `id`
     * const import_rowsWithIdOnly = await prisma.import_rows.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends import_rowsCreateManyAndReturnArgs>(args?: SelectSubset<T, import_rowsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Import_rows.
     * @param {import_rowsDeleteArgs} args - Arguments to delete one Import_rows.
     * @example
     * // Delete one Import_rows
     * const Import_rows = await prisma.import_rows.delete({
     *   where: {
     *     // ... filter to delete one Import_rows
     *   }
     * })
     * 
     */
    delete<T extends import_rowsDeleteArgs>(args: SelectSubset<T, import_rowsDeleteArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Import_rows.
     * @param {import_rowsUpdateArgs} args - Arguments to update one Import_rows.
     * @example
     * // Update one Import_rows
     * const import_rows = await prisma.import_rows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends import_rowsUpdateArgs>(args: SelectSubset<T, import_rowsUpdateArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Import_rows.
     * @param {import_rowsDeleteManyArgs} args - Arguments to filter Import_rows to delete.
     * @example
     * // Delete a few Import_rows
     * const { count } = await prisma.import_rows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends import_rowsDeleteManyArgs>(args?: SelectSubset<T, import_rowsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Import_rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Import_rows
     * const import_rows = await prisma.import_rows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends import_rowsUpdateManyArgs>(args: SelectSubset<T, import_rowsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Import_rows and returns the data updated in the database.
     * @param {import_rowsUpdateManyAndReturnArgs} args - Arguments to update many Import_rows.
     * @example
     * // Update many Import_rows
     * const import_rows = await prisma.import_rows.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Import_rows and only return the `id`
     * const import_rowsWithIdOnly = await prisma.import_rows.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends import_rowsUpdateManyAndReturnArgs>(args: SelectSubset<T, import_rowsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Import_rows.
     * @param {import_rowsUpsertArgs} args - Arguments to update or create a Import_rows.
     * @example
     * // Update or create a Import_rows
     * const import_rows = await prisma.import_rows.upsert({
     *   create: {
     *     // ... data to create a Import_rows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Import_rows we want to update
     *   }
     * })
     */
    upsert<T extends import_rowsUpsertArgs>(args: SelectSubset<T, import_rowsUpsertArgs<ExtArgs>>): Prisma__import_rowsClient<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Import_rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsCountArgs} args - Arguments to filter Import_rows to count.
     * @example
     * // Count the number of Import_rows
     * const count = await prisma.import_rows.count({
     *   where: {
     *     // ... the filter for the Import_rows we want to count
     *   }
     * })
    **/
    count<T extends import_rowsCountArgs>(
      args?: Subset<T, import_rowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Import_rowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Import_rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Import_rowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Import_rowsAggregateArgs>(args: Subset<T, Import_rowsAggregateArgs>): Prisma.PrismaPromise<GetImport_rowsAggregateType<T>>

    /**
     * Group by Import_rows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {import_rowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends import_rowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: import_rowsGroupByArgs['orderBy'] }
        : { orderBy?: import_rowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, import_rowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImport_rowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the import_rows model
   */
  readonly fields: import_rowsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for import_rows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__import_rowsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    imports<T extends importsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, importsDefaultArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the import_rows model
   */
  interface import_rowsFieldRefs {
    readonly id: FieldRef<"import_rows", 'String'>
    readonly import_id: FieldRef<"import_rows", 'String'>
    readonly account: FieldRef<"import_rows", 'String'>
    readonly date: FieldRef<"import_rows", 'String'>
    readonly qty: FieldRef<"import_rows", 'String'>
    readonly ticker: FieldRef<"import_rows", 'String'>
    readonly price: FieldRef<"import_rows", 'String'>
    readonly amount: FieldRef<"import_rows", 'String'>
    readonly currency: FieldRef<"import_rows", 'String'>
    readonly name: FieldRef<"import_rows", 'String'>
    readonly category: FieldRef<"import_rows", 'String'>
    readonly tags: FieldRef<"import_rows", 'String'>
    readonly entity_type: FieldRef<"import_rows", 'String'>
    readonly notes: FieldRef<"import_rows", 'String'>
    readonly created_at: FieldRef<"import_rows", 'DateTime'>
    readonly updated_at: FieldRef<"import_rows", 'DateTime'>
    readonly exchange_operating_mic: FieldRef<"import_rows", 'String'>
  }
    

  // Custom InputTypes
  /**
   * import_rows findUnique
   */
  export type import_rowsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter, which import_rows to fetch.
     */
    where: import_rowsWhereUniqueInput
  }

  /**
   * import_rows findUniqueOrThrow
   */
  export type import_rowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter, which import_rows to fetch.
     */
    where: import_rowsWhereUniqueInput
  }

  /**
   * import_rows findFirst
   */
  export type import_rowsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter, which import_rows to fetch.
     */
    where?: import_rowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_rows to fetch.
     */
    orderBy?: import_rowsOrderByWithRelationInput | import_rowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for import_rows.
     */
    cursor?: import_rowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of import_rows.
     */
    distinct?: Import_rowsScalarFieldEnum | Import_rowsScalarFieldEnum[]
  }

  /**
   * import_rows findFirstOrThrow
   */
  export type import_rowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter, which import_rows to fetch.
     */
    where?: import_rowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_rows to fetch.
     */
    orderBy?: import_rowsOrderByWithRelationInput | import_rowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for import_rows.
     */
    cursor?: import_rowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_rows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of import_rows.
     */
    distinct?: Import_rowsScalarFieldEnum | Import_rowsScalarFieldEnum[]
  }

  /**
   * import_rows findMany
   */
  export type import_rowsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter, which import_rows to fetch.
     */
    where?: import_rowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of import_rows to fetch.
     */
    orderBy?: import_rowsOrderByWithRelationInput | import_rowsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing import_rows.
     */
    cursor?: import_rowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` import_rows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` import_rows.
     */
    skip?: number
    distinct?: Import_rowsScalarFieldEnum | Import_rowsScalarFieldEnum[]
  }

  /**
   * import_rows create
   */
  export type import_rowsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * The data needed to create a import_rows.
     */
    data: XOR<import_rowsCreateInput, import_rowsUncheckedCreateInput>
  }

  /**
   * import_rows createMany
   */
  export type import_rowsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many import_rows.
     */
    data: import_rowsCreateManyInput | import_rowsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * import_rows createManyAndReturn
   */
  export type import_rowsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * The data used to create many import_rows.
     */
    data: import_rowsCreateManyInput | import_rowsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * import_rows update
   */
  export type import_rowsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * The data needed to update a import_rows.
     */
    data: XOR<import_rowsUpdateInput, import_rowsUncheckedUpdateInput>
    /**
     * Choose, which import_rows to update.
     */
    where: import_rowsWhereUniqueInput
  }

  /**
   * import_rows updateMany
   */
  export type import_rowsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update import_rows.
     */
    data: XOR<import_rowsUpdateManyMutationInput, import_rowsUncheckedUpdateManyInput>
    /**
     * Filter which import_rows to update
     */
    where?: import_rowsWhereInput
    /**
     * Limit how many import_rows to update.
     */
    limit?: number
  }

  /**
   * import_rows updateManyAndReturn
   */
  export type import_rowsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * The data used to update import_rows.
     */
    data: XOR<import_rowsUpdateManyMutationInput, import_rowsUncheckedUpdateManyInput>
    /**
     * Filter which import_rows to update
     */
    where?: import_rowsWhereInput
    /**
     * Limit how many import_rows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * import_rows upsert
   */
  export type import_rowsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * The filter to search for the import_rows to update in case it exists.
     */
    where: import_rowsWhereUniqueInput
    /**
     * In case the import_rows found by the `where` argument doesn't exist, create a new import_rows with this data.
     */
    create: XOR<import_rowsCreateInput, import_rowsUncheckedCreateInput>
    /**
     * In case the import_rows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<import_rowsUpdateInput, import_rowsUncheckedUpdateInput>
  }

  /**
   * import_rows delete
   */
  export type import_rowsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    /**
     * Filter which import_rows to delete.
     */
    where: import_rowsWhereUniqueInput
  }

  /**
   * import_rows deleteMany
   */
  export type import_rowsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which import_rows to delete
     */
    where?: import_rowsWhereInput
    /**
     * Limit how many import_rows to delete.
     */
    limit?: number
  }

  /**
   * import_rows without action
   */
  export type import_rowsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
  }


  /**
   * Model imports
   */

  export type AggregateImports = {
    _count: ImportsCountAggregateOutputType | null
    _min: ImportsMinAggregateOutputType | null
    _max: ImportsMaxAggregateOutputType | null
  }

  export type ImportsMinAggregateOutputType = {
    id: string | null
    status: string | null
    raw_file_str: string | null
    normalized_csv_str: string | null
    created_at: Date | null
    updated_at: Date | null
    col_sep: string | null
    family_id: string | null
    account_id: string | null
    type: string | null
    date_col_label: string | null
    amount_col_label: string | null
    name_col_label: string | null
    category_col_label: string | null
    tags_col_label: string | null
    account_col_label: string | null
    qty_col_label: string | null
    ticker_col_label: string | null
    price_col_label: string | null
    entity_type_col_label: string | null
    notes_col_label: string | null
    currency_col_label: string | null
    date_format: string | null
    signage_convention: string | null
    error: string | null
    number_format: string | null
    exchange_operating_mic_col_label: string | null
    amount_type_strategy: string | null
    amount_type_inflow_value: string | null
  }

  export type ImportsMaxAggregateOutputType = {
    id: string | null
    status: string | null
    raw_file_str: string | null
    normalized_csv_str: string | null
    created_at: Date | null
    updated_at: Date | null
    col_sep: string | null
    family_id: string | null
    account_id: string | null
    type: string | null
    date_col_label: string | null
    amount_col_label: string | null
    name_col_label: string | null
    category_col_label: string | null
    tags_col_label: string | null
    account_col_label: string | null
    qty_col_label: string | null
    ticker_col_label: string | null
    price_col_label: string | null
    entity_type_col_label: string | null
    notes_col_label: string | null
    currency_col_label: string | null
    date_format: string | null
    signage_convention: string | null
    error: string | null
    number_format: string | null
    exchange_operating_mic_col_label: string | null
    amount_type_strategy: string | null
    amount_type_inflow_value: string | null
  }

  export type ImportsCountAggregateOutputType = {
    id: number
    column_mappings: number
    status: number
    raw_file_str: number
    normalized_csv_str: number
    created_at: number
    updated_at: number
    col_sep: number
    family_id: number
    account_id: number
    type: number
    date_col_label: number
    amount_col_label: number
    name_col_label: number
    category_col_label: number
    tags_col_label: number
    account_col_label: number
    qty_col_label: number
    ticker_col_label: number
    price_col_label: number
    entity_type_col_label: number
    notes_col_label: number
    currency_col_label: number
    date_format: number
    signage_convention: number
    error: number
    number_format: number
    exchange_operating_mic_col_label: number
    amount_type_strategy: number
    amount_type_inflow_value: number
    _all: number
  }


  export type ImportsMinAggregateInputType = {
    id?: true
    status?: true
    raw_file_str?: true
    normalized_csv_str?: true
    created_at?: true
    updated_at?: true
    col_sep?: true
    family_id?: true
    account_id?: true
    type?: true
    date_col_label?: true
    amount_col_label?: true
    name_col_label?: true
    category_col_label?: true
    tags_col_label?: true
    account_col_label?: true
    qty_col_label?: true
    ticker_col_label?: true
    price_col_label?: true
    entity_type_col_label?: true
    notes_col_label?: true
    currency_col_label?: true
    date_format?: true
    signage_convention?: true
    error?: true
    number_format?: true
    exchange_operating_mic_col_label?: true
    amount_type_strategy?: true
    amount_type_inflow_value?: true
  }

  export type ImportsMaxAggregateInputType = {
    id?: true
    status?: true
    raw_file_str?: true
    normalized_csv_str?: true
    created_at?: true
    updated_at?: true
    col_sep?: true
    family_id?: true
    account_id?: true
    type?: true
    date_col_label?: true
    amount_col_label?: true
    name_col_label?: true
    category_col_label?: true
    tags_col_label?: true
    account_col_label?: true
    qty_col_label?: true
    ticker_col_label?: true
    price_col_label?: true
    entity_type_col_label?: true
    notes_col_label?: true
    currency_col_label?: true
    date_format?: true
    signage_convention?: true
    error?: true
    number_format?: true
    exchange_operating_mic_col_label?: true
    amount_type_strategy?: true
    amount_type_inflow_value?: true
  }

  export type ImportsCountAggregateInputType = {
    id?: true
    column_mappings?: true
    status?: true
    raw_file_str?: true
    normalized_csv_str?: true
    created_at?: true
    updated_at?: true
    col_sep?: true
    family_id?: true
    account_id?: true
    type?: true
    date_col_label?: true
    amount_col_label?: true
    name_col_label?: true
    category_col_label?: true
    tags_col_label?: true
    account_col_label?: true
    qty_col_label?: true
    ticker_col_label?: true
    price_col_label?: true
    entity_type_col_label?: true
    notes_col_label?: true
    currency_col_label?: true
    date_format?: true
    signage_convention?: true
    error?: true
    number_format?: true
    exchange_operating_mic_col_label?: true
    amount_type_strategy?: true
    amount_type_inflow_value?: true
    _all?: true
  }

  export type ImportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which imports to aggregate.
     */
    where?: importsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imports to fetch.
     */
    orderBy?: importsOrderByWithRelationInput | importsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: importsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned imports
    **/
    _count?: true | ImportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportsMaxAggregateInputType
  }

  export type GetImportsAggregateType<T extends ImportsAggregateArgs> = {
        [P in keyof T & keyof AggregateImports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImports[P]>
      : GetScalarType<T[P], AggregateImports[P]>
  }




  export type importsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: importsWhereInput
    orderBy?: importsOrderByWithAggregationInput | importsOrderByWithAggregationInput[]
    by: ImportsScalarFieldEnum[] | ImportsScalarFieldEnum
    having?: importsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportsCountAggregateInputType | true
    _min?: ImportsMinAggregateInputType
    _max?: ImportsMaxAggregateInputType
  }

  export type ImportsGroupByOutputType = {
    id: string
    column_mappings: JsonValue | null
    status: string | null
    raw_file_str: string | null
    normalized_csv_str: string | null
    created_at: Date
    updated_at: Date
    col_sep: string | null
    family_id: string
    account_id: string | null
    type: string
    date_col_label: string | null
    amount_col_label: string | null
    name_col_label: string | null
    category_col_label: string | null
    tags_col_label: string | null
    account_col_label: string | null
    qty_col_label: string | null
    ticker_col_label: string | null
    price_col_label: string | null
    entity_type_col_label: string | null
    notes_col_label: string | null
    currency_col_label: string | null
    date_format: string | null
    signage_convention: string | null
    error: string | null
    number_format: string | null
    exchange_operating_mic_col_label: string | null
    amount_type_strategy: string | null
    amount_type_inflow_value: string | null
    _count: ImportsCountAggregateOutputType | null
    _min: ImportsMinAggregateOutputType | null
    _max: ImportsMaxAggregateOutputType | null
  }

  type GetImportsGroupByPayload<T extends importsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportsGroupByOutputType[P]>
            : GetScalarType<T[P], ImportsGroupByOutputType[P]>
        }
      >
    >


  export type importsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    column_mappings?: boolean
    status?: boolean
    raw_file_str?: boolean
    normalized_csv_str?: boolean
    created_at?: boolean
    updated_at?: boolean
    col_sep?: boolean
    family_id?: boolean
    account_id?: boolean
    type?: boolean
    date_col_label?: boolean
    amount_col_label?: boolean
    name_col_label?: boolean
    category_col_label?: boolean
    tags_col_label?: boolean
    account_col_label?: boolean
    qty_col_label?: boolean
    ticker_col_label?: boolean
    price_col_label?: boolean
    entity_type_col_label?: boolean
    notes_col_label?: boolean
    currency_col_label?: boolean
    date_format?: boolean
    signage_convention?: boolean
    error?: boolean
    number_format?: boolean
    exchange_operating_mic_col_label?: boolean
    amount_type_strategy?: boolean
    amount_type_inflow_value?: boolean
    accounts?: boolean | imports$accountsArgs<ExtArgs>
    entries?: boolean | imports$entriesArgs<ExtArgs>
    import_rows?: boolean | imports$import_rowsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | ImportsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imports"]>

  export type importsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    column_mappings?: boolean
    status?: boolean
    raw_file_str?: boolean
    normalized_csv_str?: boolean
    created_at?: boolean
    updated_at?: boolean
    col_sep?: boolean
    family_id?: boolean
    account_id?: boolean
    type?: boolean
    date_col_label?: boolean
    amount_col_label?: boolean
    name_col_label?: boolean
    category_col_label?: boolean
    tags_col_label?: boolean
    account_col_label?: boolean
    qty_col_label?: boolean
    ticker_col_label?: boolean
    price_col_label?: boolean
    entity_type_col_label?: boolean
    notes_col_label?: boolean
    currency_col_label?: boolean
    date_format?: boolean
    signage_convention?: boolean
    error?: boolean
    number_format?: boolean
    exchange_operating_mic_col_label?: boolean
    amount_type_strategy?: boolean
    amount_type_inflow_value?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imports"]>

  export type importsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    column_mappings?: boolean
    status?: boolean
    raw_file_str?: boolean
    normalized_csv_str?: boolean
    created_at?: boolean
    updated_at?: boolean
    col_sep?: boolean
    family_id?: boolean
    account_id?: boolean
    type?: boolean
    date_col_label?: boolean
    amount_col_label?: boolean
    name_col_label?: boolean
    category_col_label?: boolean
    tags_col_label?: boolean
    account_col_label?: boolean
    qty_col_label?: boolean
    ticker_col_label?: boolean
    price_col_label?: boolean
    entity_type_col_label?: boolean
    notes_col_label?: boolean
    currency_col_label?: boolean
    date_format?: boolean
    signage_convention?: boolean
    error?: boolean
    number_format?: boolean
    exchange_operating_mic_col_label?: boolean
    amount_type_strategy?: boolean
    amount_type_inflow_value?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["imports"]>

  export type importsSelectScalar = {
    id?: boolean
    column_mappings?: boolean
    status?: boolean
    raw_file_str?: boolean
    normalized_csv_str?: boolean
    created_at?: boolean
    updated_at?: boolean
    col_sep?: boolean
    family_id?: boolean
    account_id?: boolean
    type?: boolean
    date_col_label?: boolean
    amount_col_label?: boolean
    name_col_label?: boolean
    category_col_label?: boolean
    tags_col_label?: boolean
    account_col_label?: boolean
    qty_col_label?: boolean
    ticker_col_label?: boolean
    price_col_label?: boolean
    entity_type_col_label?: boolean
    notes_col_label?: boolean
    currency_col_label?: boolean
    date_format?: boolean
    signage_convention?: boolean
    error?: boolean
    number_format?: boolean
    exchange_operating_mic_col_label?: boolean
    amount_type_strategy?: boolean
    amount_type_inflow_value?: boolean
  }

  export type importsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "column_mappings" | "status" | "raw_file_str" | "normalized_csv_str" | "created_at" | "updated_at" | "col_sep" | "family_id" | "account_id" | "type" | "date_col_label" | "amount_col_label" | "name_col_label" | "category_col_label" | "tags_col_label" | "account_col_label" | "qty_col_label" | "ticker_col_label" | "price_col_label" | "entity_type_col_label" | "notes_col_label" | "currency_col_label" | "date_format" | "signage_convention" | "error" | "number_format" | "exchange_operating_mic_col_label" | "amount_type_strategy" | "amount_type_inflow_value", ExtArgs["result"]["imports"]>
  export type importsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | imports$accountsArgs<ExtArgs>
    entries?: boolean | imports$entriesArgs<ExtArgs>
    import_rows?: boolean | imports$import_rowsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | ImportsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type importsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type importsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $importsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "imports"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      entries: Prisma.$entriesPayload<ExtArgs>[]
      import_rows: Prisma.$import_rowsPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      column_mappings: Prisma.JsonValue | null
      status: string | null
      raw_file_str: string | null
      normalized_csv_str: string | null
      created_at: Date
      updated_at: Date
      col_sep: string | null
      family_id: string
      account_id: string | null
      type: string
      date_col_label: string | null
      amount_col_label: string | null
      name_col_label: string | null
      category_col_label: string | null
      tags_col_label: string | null
      account_col_label: string | null
      qty_col_label: string | null
      ticker_col_label: string | null
      price_col_label: string | null
      entity_type_col_label: string | null
      notes_col_label: string | null
      currency_col_label: string | null
      date_format: string | null
      signage_convention: string | null
      error: string | null
      number_format: string | null
      exchange_operating_mic_col_label: string | null
      amount_type_strategy: string | null
      amount_type_inflow_value: string | null
    }, ExtArgs["result"]["imports"]>
    composites: {}
  }

  type importsGetPayload<S extends boolean | null | undefined | importsDefaultArgs> = $Result.GetResult<Prisma.$importsPayload, S>

  type importsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<importsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportsCountAggregateInputType | true
    }

  export interface importsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['imports'], meta: { name: 'imports' } }
    /**
     * Find zero or one Imports that matches the filter.
     * @param {importsFindUniqueArgs} args - Arguments to find a Imports
     * @example
     * // Get one Imports
     * const imports = await prisma.imports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends importsFindUniqueArgs>(args: SelectSubset<T, importsFindUniqueArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Imports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {importsFindUniqueOrThrowArgs} args - Arguments to find a Imports
     * @example
     * // Get one Imports
     * const imports = await prisma.imports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends importsFindUniqueOrThrowArgs>(args: SelectSubset<T, importsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Imports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsFindFirstArgs} args - Arguments to find a Imports
     * @example
     * // Get one Imports
     * const imports = await prisma.imports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends importsFindFirstArgs>(args?: SelectSubset<T, importsFindFirstArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Imports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsFindFirstOrThrowArgs} args - Arguments to find a Imports
     * @example
     * // Get one Imports
     * const imports = await prisma.imports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends importsFindFirstOrThrowArgs>(args?: SelectSubset<T, importsFindFirstOrThrowArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Imports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Imports
     * const imports = await prisma.imports.findMany()
     * 
     * // Get first 10 Imports
     * const imports = await prisma.imports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importsWithIdOnly = await prisma.imports.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends importsFindManyArgs>(args?: SelectSubset<T, importsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Imports.
     * @param {importsCreateArgs} args - Arguments to create a Imports.
     * @example
     * // Create one Imports
     * const Imports = await prisma.imports.create({
     *   data: {
     *     // ... data to create a Imports
     *   }
     * })
     * 
     */
    create<T extends importsCreateArgs>(args: SelectSubset<T, importsCreateArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Imports.
     * @param {importsCreateManyArgs} args - Arguments to create many Imports.
     * @example
     * // Create many Imports
     * const imports = await prisma.imports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends importsCreateManyArgs>(args?: SelectSubset<T, importsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Imports and returns the data saved in the database.
     * @param {importsCreateManyAndReturnArgs} args - Arguments to create many Imports.
     * @example
     * // Create many Imports
     * const imports = await prisma.imports.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Imports and only return the `id`
     * const importsWithIdOnly = await prisma.imports.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends importsCreateManyAndReturnArgs>(args?: SelectSubset<T, importsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Imports.
     * @param {importsDeleteArgs} args - Arguments to delete one Imports.
     * @example
     * // Delete one Imports
     * const Imports = await prisma.imports.delete({
     *   where: {
     *     // ... filter to delete one Imports
     *   }
     * })
     * 
     */
    delete<T extends importsDeleteArgs>(args: SelectSubset<T, importsDeleteArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Imports.
     * @param {importsUpdateArgs} args - Arguments to update one Imports.
     * @example
     * // Update one Imports
     * const imports = await prisma.imports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends importsUpdateArgs>(args: SelectSubset<T, importsUpdateArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Imports.
     * @param {importsDeleteManyArgs} args - Arguments to filter Imports to delete.
     * @example
     * // Delete a few Imports
     * const { count } = await prisma.imports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends importsDeleteManyArgs>(args?: SelectSubset<T, importsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Imports
     * const imports = await prisma.imports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends importsUpdateManyArgs>(args: SelectSubset<T, importsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Imports and returns the data updated in the database.
     * @param {importsUpdateManyAndReturnArgs} args - Arguments to update many Imports.
     * @example
     * // Update many Imports
     * const imports = await prisma.imports.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Imports and only return the `id`
     * const importsWithIdOnly = await prisma.imports.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends importsUpdateManyAndReturnArgs>(args: SelectSubset<T, importsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Imports.
     * @param {importsUpsertArgs} args - Arguments to update or create a Imports.
     * @example
     * // Update or create a Imports
     * const imports = await prisma.imports.upsert({
     *   create: {
     *     // ... data to create a Imports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Imports we want to update
     *   }
     * })
     */
    upsert<T extends importsUpsertArgs>(args: SelectSubset<T, importsUpsertArgs<ExtArgs>>): Prisma__importsClient<$Result.GetResult<Prisma.$importsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsCountArgs} args - Arguments to filter Imports to count.
     * @example
     * // Count the number of Imports
     * const count = await prisma.imports.count({
     *   where: {
     *     // ... the filter for the Imports we want to count
     *   }
     * })
    **/
    count<T extends importsCountArgs>(
      args?: Subset<T, importsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportsAggregateArgs>(args: Subset<T, ImportsAggregateArgs>): Prisma.PrismaPromise<GetImportsAggregateType<T>>

    /**
     * Group by Imports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {importsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends importsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: importsGroupByArgs['orderBy'] }
        : { orderBy?: importsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, importsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the imports model
   */
  readonly fields: importsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for imports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__importsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends imports$accountsArgs<ExtArgs> = {}>(args?: Subset<T, imports$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entries<T extends imports$entriesArgs<ExtArgs> = {}>(args?: Subset<T, imports$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    import_rows<T extends imports$import_rowsArgs<ExtArgs> = {}>(args?: Subset<T, imports$import_rowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$import_rowsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the imports model
   */
  interface importsFieldRefs {
    readonly id: FieldRef<"imports", 'String'>
    readonly column_mappings: FieldRef<"imports", 'Json'>
    readonly status: FieldRef<"imports", 'String'>
    readonly raw_file_str: FieldRef<"imports", 'String'>
    readonly normalized_csv_str: FieldRef<"imports", 'String'>
    readonly created_at: FieldRef<"imports", 'DateTime'>
    readonly updated_at: FieldRef<"imports", 'DateTime'>
    readonly col_sep: FieldRef<"imports", 'String'>
    readonly family_id: FieldRef<"imports", 'String'>
    readonly account_id: FieldRef<"imports", 'String'>
    readonly type: FieldRef<"imports", 'String'>
    readonly date_col_label: FieldRef<"imports", 'String'>
    readonly amount_col_label: FieldRef<"imports", 'String'>
    readonly name_col_label: FieldRef<"imports", 'String'>
    readonly category_col_label: FieldRef<"imports", 'String'>
    readonly tags_col_label: FieldRef<"imports", 'String'>
    readonly account_col_label: FieldRef<"imports", 'String'>
    readonly qty_col_label: FieldRef<"imports", 'String'>
    readonly ticker_col_label: FieldRef<"imports", 'String'>
    readonly price_col_label: FieldRef<"imports", 'String'>
    readonly entity_type_col_label: FieldRef<"imports", 'String'>
    readonly notes_col_label: FieldRef<"imports", 'String'>
    readonly currency_col_label: FieldRef<"imports", 'String'>
    readonly date_format: FieldRef<"imports", 'String'>
    readonly signage_convention: FieldRef<"imports", 'String'>
    readonly error: FieldRef<"imports", 'String'>
    readonly number_format: FieldRef<"imports", 'String'>
    readonly exchange_operating_mic_col_label: FieldRef<"imports", 'String'>
    readonly amount_type_strategy: FieldRef<"imports", 'String'>
    readonly amount_type_inflow_value: FieldRef<"imports", 'String'>
  }
    

  // Custom InputTypes
  /**
   * imports findUnique
   */
  export type importsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter, which imports to fetch.
     */
    where: importsWhereUniqueInput
  }

  /**
   * imports findUniqueOrThrow
   */
  export type importsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter, which imports to fetch.
     */
    where: importsWhereUniqueInput
  }

  /**
   * imports findFirst
   */
  export type importsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter, which imports to fetch.
     */
    where?: importsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imports to fetch.
     */
    orderBy?: importsOrderByWithRelationInput | importsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for imports.
     */
    cursor?: importsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of imports.
     */
    distinct?: ImportsScalarFieldEnum | ImportsScalarFieldEnum[]
  }

  /**
   * imports findFirstOrThrow
   */
  export type importsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter, which imports to fetch.
     */
    where?: importsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imports to fetch.
     */
    orderBy?: importsOrderByWithRelationInput | importsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for imports.
     */
    cursor?: importsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of imports.
     */
    distinct?: ImportsScalarFieldEnum | ImportsScalarFieldEnum[]
  }

  /**
   * imports findMany
   */
  export type importsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter, which imports to fetch.
     */
    where?: importsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of imports to fetch.
     */
    orderBy?: importsOrderByWithRelationInput | importsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing imports.
     */
    cursor?: importsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` imports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` imports.
     */
    skip?: number
    distinct?: ImportsScalarFieldEnum | ImportsScalarFieldEnum[]
  }

  /**
   * imports create
   */
  export type importsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * The data needed to create a imports.
     */
    data: XOR<importsCreateInput, importsUncheckedCreateInput>
  }

  /**
   * imports createMany
   */
  export type importsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many imports.
     */
    data: importsCreateManyInput | importsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * imports createManyAndReturn
   */
  export type importsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * The data used to create many imports.
     */
    data: importsCreateManyInput | importsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * imports update
   */
  export type importsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * The data needed to update a imports.
     */
    data: XOR<importsUpdateInput, importsUncheckedUpdateInput>
    /**
     * Choose, which imports to update.
     */
    where: importsWhereUniqueInput
  }

  /**
   * imports updateMany
   */
  export type importsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update imports.
     */
    data: XOR<importsUpdateManyMutationInput, importsUncheckedUpdateManyInput>
    /**
     * Filter which imports to update
     */
    where?: importsWhereInput
    /**
     * Limit how many imports to update.
     */
    limit?: number
  }

  /**
   * imports updateManyAndReturn
   */
  export type importsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * The data used to update imports.
     */
    data: XOR<importsUpdateManyMutationInput, importsUncheckedUpdateManyInput>
    /**
     * Filter which imports to update
     */
    where?: importsWhereInput
    /**
     * Limit how many imports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * imports upsert
   */
  export type importsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * The filter to search for the imports to update in case it exists.
     */
    where: importsWhereUniqueInput
    /**
     * In case the imports found by the `where` argument doesn't exist, create a new imports with this data.
     */
    create: XOR<importsCreateInput, importsUncheckedCreateInput>
    /**
     * In case the imports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<importsUpdateInput, importsUncheckedUpdateInput>
  }

  /**
   * imports delete
   */
  export type importsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
    /**
     * Filter which imports to delete.
     */
    where: importsWhereUniqueInput
  }

  /**
   * imports deleteMany
   */
  export type importsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which imports to delete
     */
    where?: importsWhereInput
    /**
     * Limit how many imports to delete.
     */
    limit?: number
  }

  /**
   * imports.accounts
   */
  export type imports$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * imports.entries
   */
  export type imports$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entries
     */
    select?: entriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entries
     */
    omit?: entriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entriesInclude<ExtArgs> | null
    where?: entriesWhereInput
    orderBy?: entriesOrderByWithRelationInput | entriesOrderByWithRelationInput[]
    cursor?: entriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntriesScalarFieldEnum | EntriesScalarFieldEnum[]
  }

  /**
   * imports.import_rows
   */
  export type imports$import_rowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the import_rows
     */
    select?: import_rowsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the import_rows
     */
    omit?: import_rowsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: import_rowsInclude<ExtArgs> | null
    where?: import_rowsWhereInput
    orderBy?: import_rowsOrderByWithRelationInput | import_rowsOrderByWithRelationInput[]
    cursor?: import_rowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Import_rowsScalarFieldEnum | Import_rowsScalarFieldEnum[]
  }

  /**
   * imports without action
   */
  export type importsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the imports
     */
    select?: importsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the imports
     */
    omit?: importsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: importsInclude<ExtArgs> | null
  }


  /**
   * Model investments
   */

  export type AggregateInvestments = {
    _count: InvestmentsCountAggregateOutputType | null
    _min: InvestmentsMinAggregateOutputType | null
    _max: InvestmentsMaxAggregateOutputType | null
  }

  export type InvestmentsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvestmentsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvestmentsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type InvestmentsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvestmentsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type InvestmentsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type InvestmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investments to aggregate.
     */
    where?: investmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investments to fetch.
     */
    orderBy?: investmentsOrderByWithRelationInput | investmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investments
    **/
    _count?: true | InvestmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestmentsMaxAggregateInputType
  }

  export type GetInvestmentsAggregateType<T extends InvestmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestments[P]>
      : GetScalarType<T[P], AggregateInvestments[P]>
  }




  export type investmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investmentsWhereInput
    orderBy?: investmentsOrderByWithAggregationInput | investmentsOrderByWithAggregationInput[]
    by: InvestmentsScalarFieldEnum[] | InvestmentsScalarFieldEnum
    having?: investmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestmentsCountAggregateInputType | true
    _min?: InvestmentsMinAggregateInputType
    _max?: InvestmentsMaxAggregateInputType
  }

  export type InvestmentsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: InvestmentsCountAggregateOutputType | null
    _min: InvestmentsMinAggregateOutputType | null
    _max: InvestmentsMaxAggregateOutputType | null
  }

  type GetInvestmentsGroupByPayload<T extends investmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestmentsGroupByOutputType[P]>
            : GetScalarType<T[P], InvestmentsGroupByOutputType[P]>
        }
      >
    >


  export type investmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["investments"]>

  export type investmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["investments"]>

  export type investmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["investments"]>

  export type investmentsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type investmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["investments"]>

  export type $investmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["investments"]>
    composites: {}
  }

  type investmentsGetPayload<S extends boolean | null | undefined | investmentsDefaultArgs> = $Result.GetResult<Prisma.$investmentsPayload, S>

  type investmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<investmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestmentsCountAggregateInputType | true
    }

  export interface investmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investments'], meta: { name: 'investments' } }
    /**
     * Find zero or one Investments that matches the filter.
     * @param {investmentsFindUniqueArgs} args - Arguments to find a Investments
     * @example
     * // Get one Investments
     * const investments = await prisma.investments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investmentsFindUniqueArgs>(args: SelectSubset<T, investmentsFindUniqueArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Investments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {investmentsFindUniqueOrThrowArgs} args - Arguments to find a Investments
     * @example
     * // Get one Investments
     * const investments = await prisma.investments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, investmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsFindFirstArgs} args - Arguments to find a Investments
     * @example
     * // Get one Investments
     * const investments = await prisma.investments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investmentsFindFirstArgs>(args?: SelectSubset<T, investmentsFindFirstArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Investments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsFindFirstOrThrowArgs} args - Arguments to find a Investments
     * @example
     * // Get one Investments
     * const investments = await prisma.investments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, investmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Investments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investments
     * const investments = await prisma.investments.findMany()
     * 
     * // Get first 10 Investments
     * const investments = await prisma.investments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investmentsWithIdOnly = await prisma.investments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends investmentsFindManyArgs>(args?: SelectSubset<T, investmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Investments.
     * @param {investmentsCreateArgs} args - Arguments to create a Investments.
     * @example
     * // Create one Investments
     * const Investments = await prisma.investments.create({
     *   data: {
     *     // ... data to create a Investments
     *   }
     * })
     * 
     */
    create<T extends investmentsCreateArgs>(args: SelectSubset<T, investmentsCreateArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Investments.
     * @param {investmentsCreateManyArgs} args - Arguments to create many Investments.
     * @example
     * // Create many Investments
     * const investments = await prisma.investments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investmentsCreateManyArgs>(args?: SelectSubset<T, investmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Investments and returns the data saved in the database.
     * @param {investmentsCreateManyAndReturnArgs} args - Arguments to create many Investments.
     * @example
     * // Create many Investments
     * const investments = await prisma.investments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Investments and only return the `id`
     * const investmentsWithIdOnly = await prisma.investments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends investmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, investmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Investments.
     * @param {investmentsDeleteArgs} args - Arguments to delete one Investments.
     * @example
     * // Delete one Investments
     * const Investments = await prisma.investments.delete({
     *   where: {
     *     // ... filter to delete one Investments
     *   }
     * })
     * 
     */
    delete<T extends investmentsDeleteArgs>(args: SelectSubset<T, investmentsDeleteArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Investments.
     * @param {investmentsUpdateArgs} args - Arguments to update one Investments.
     * @example
     * // Update one Investments
     * const investments = await prisma.investments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investmentsUpdateArgs>(args: SelectSubset<T, investmentsUpdateArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Investments.
     * @param {investmentsDeleteManyArgs} args - Arguments to filter Investments to delete.
     * @example
     * // Delete a few Investments
     * const { count } = await prisma.investments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investmentsDeleteManyArgs>(args?: SelectSubset<T, investmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investments
     * const investments = await prisma.investments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investmentsUpdateManyArgs>(args: SelectSubset<T, investmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investments and returns the data updated in the database.
     * @param {investmentsUpdateManyAndReturnArgs} args - Arguments to update many Investments.
     * @example
     * // Update many Investments
     * const investments = await prisma.investments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Investments and only return the `id`
     * const investmentsWithIdOnly = await prisma.investments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends investmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, investmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Investments.
     * @param {investmentsUpsertArgs} args - Arguments to update or create a Investments.
     * @example
     * // Update or create a Investments
     * const investments = await prisma.investments.upsert({
     *   create: {
     *     // ... data to create a Investments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investments we want to update
     *   }
     * })
     */
    upsert<T extends investmentsUpsertArgs>(args: SelectSubset<T, investmentsUpsertArgs<ExtArgs>>): Prisma__investmentsClient<$Result.GetResult<Prisma.$investmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsCountArgs} args - Arguments to filter Investments to count.
     * @example
     * // Count the number of Investments
     * const count = await prisma.investments.count({
     *   where: {
     *     // ... the filter for the Investments we want to count
     *   }
     * })
    **/
    count<T extends investmentsCountArgs>(
      args?: Subset<T, investmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestmentsAggregateArgs>(args: Subset<T, InvestmentsAggregateArgs>): Prisma.PrismaPromise<GetInvestmentsAggregateType<T>>

    /**
     * Group by Investments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investmentsGroupByArgs['orderBy'] }
        : { orderBy?: investmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investments model
   */
  readonly fields: investmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investments model
   */
  interface investmentsFieldRefs {
    readonly id: FieldRef<"investments", 'String'>
    readonly created_at: FieldRef<"investments", 'DateTime'>
    readonly updated_at: FieldRef<"investments", 'DateTime'>
    readonly locked_attributes: FieldRef<"investments", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * investments findUnique
   */
  export type investmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter, which investments to fetch.
     */
    where: investmentsWhereUniqueInput
  }

  /**
   * investments findUniqueOrThrow
   */
  export type investmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter, which investments to fetch.
     */
    where: investmentsWhereUniqueInput
  }

  /**
   * investments findFirst
   */
  export type investmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter, which investments to fetch.
     */
    where?: investmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investments to fetch.
     */
    orderBy?: investmentsOrderByWithRelationInput | investmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investments.
     */
    cursor?: investmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investments.
     */
    distinct?: InvestmentsScalarFieldEnum | InvestmentsScalarFieldEnum[]
  }

  /**
   * investments findFirstOrThrow
   */
  export type investmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter, which investments to fetch.
     */
    where?: investmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investments to fetch.
     */
    orderBy?: investmentsOrderByWithRelationInput | investmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investments.
     */
    cursor?: investmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investments.
     */
    distinct?: InvestmentsScalarFieldEnum | InvestmentsScalarFieldEnum[]
  }

  /**
   * investments findMany
   */
  export type investmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter, which investments to fetch.
     */
    where?: investmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investments to fetch.
     */
    orderBy?: investmentsOrderByWithRelationInput | investmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investments.
     */
    cursor?: investmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investments.
     */
    skip?: number
    distinct?: InvestmentsScalarFieldEnum | InvestmentsScalarFieldEnum[]
  }

  /**
   * investments create
   */
  export type investmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a investments.
     */
    data: XOR<investmentsCreateInput, investmentsUncheckedCreateInput>
  }

  /**
   * investments createMany
   */
  export type investmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investments.
     */
    data: investmentsCreateManyInput | investmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investments createManyAndReturn
   */
  export type investmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * The data used to create many investments.
     */
    data: investmentsCreateManyInput | investmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investments update
   */
  export type investmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a investments.
     */
    data: XOR<investmentsUpdateInput, investmentsUncheckedUpdateInput>
    /**
     * Choose, which investments to update.
     */
    where: investmentsWhereUniqueInput
  }

  /**
   * investments updateMany
   */
  export type investmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investments.
     */
    data: XOR<investmentsUpdateManyMutationInput, investmentsUncheckedUpdateManyInput>
    /**
     * Filter which investments to update
     */
    where?: investmentsWhereInput
    /**
     * Limit how many investments to update.
     */
    limit?: number
  }

  /**
   * investments updateManyAndReturn
   */
  export type investmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * The data used to update investments.
     */
    data: XOR<investmentsUpdateManyMutationInput, investmentsUncheckedUpdateManyInput>
    /**
     * Filter which investments to update
     */
    where?: investmentsWhereInput
    /**
     * Limit how many investments to update.
     */
    limit?: number
  }

  /**
   * investments upsert
   */
  export type investmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the investments to update in case it exists.
     */
    where: investmentsWhereUniqueInput
    /**
     * In case the investments found by the `where` argument doesn't exist, create a new investments with this data.
     */
    create: XOR<investmentsCreateInput, investmentsUncheckedCreateInput>
    /**
     * In case the investments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investmentsUpdateInput, investmentsUncheckedUpdateInput>
  }

  /**
   * investments delete
   */
  export type investmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
    /**
     * Filter which investments to delete.
     */
    where: investmentsWhereUniqueInput
  }

  /**
   * investments deleteMany
   */
  export type investmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investments to delete
     */
    where?: investmentsWhereInput
    /**
     * Limit how many investments to delete.
     */
    limit?: number
  }

  /**
   * investments without action
   */
  export type investmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investments
     */
    select?: investmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the investments
     */
    omit?: investmentsOmit<ExtArgs> | null
  }


  /**
   * Model invitations
   */

  export type AggregateInvitations = {
    _count: InvitationsCountAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  export type InvitationsMinAggregateOutputType = {
    id: string | null
    email: string | null
    role: string | null
    token: string | null
    family_id: string | null
    inviter_id: string | null
    accepted_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvitationsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    role: string | null
    token: string | null
    family_id: string | null
    inviter_id: string | null
    accepted_at: Date | null
    expires_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvitationsCountAggregateOutputType = {
    id: number
    email: number
    role: number
    token: number
    family_id: number
    inviter_id: number
    accepted_at: number
    expires_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvitationsMinAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    family_id?: true
    inviter_id?: true
    accepted_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type InvitationsMaxAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    family_id?: true
    inviter_id?: true
    accepted_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
  }

  export type InvitationsCountAggregateInputType = {
    id?: true
    email?: true
    role?: true
    token?: true
    family_id?: true
    inviter_id?: true
    accepted_at?: true
    expires_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvitationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to aggregate.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invitations
    **/
    _count?: true | InvitationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationsMaxAggregateInputType
  }

  export type GetInvitationsAggregateType<T extends InvitationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitations[P]>
      : GetScalarType<T[P], AggregateInvitations[P]>
  }




  export type invitationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithAggregationInput | invitationsOrderByWithAggregationInput[]
    by: InvitationsScalarFieldEnum[] | InvitationsScalarFieldEnum
    having?: invitationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationsCountAggregateInputType | true
    _min?: InvitationsMinAggregateInputType
    _max?: InvitationsMaxAggregateInputType
  }

  export type InvitationsGroupByOutputType = {
    id: string
    email: string | null
    role: string | null
    token: string | null
    family_id: string
    inviter_id: string
    accepted_at: Date | null
    expires_at: Date | null
    created_at: Date
    updated_at: Date
    _count: InvitationsCountAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  type GetInvitationsGroupByPayload<T extends invitationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
        }
      >
    >


  export type invitationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    family_id?: boolean
    inviter_id?: boolean
    accepted_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    family_id?: boolean
    inviter_id?: boolean
    accepted_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    family_id?: boolean
    inviter_id?: boolean
    accepted_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type invitationsSelectScalar = {
    id?: boolean
    email?: boolean
    role?: boolean
    token?: boolean
    family_id?: boolean
    inviter_id?: boolean
    accepted_at?: boolean
    expires_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type invitationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "role" | "token" | "family_id" | "inviter_id" | "accepted_at" | "expires_at" | "created_at" | "updated_at", ExtArgs["result"]["invitations"]>
  export type invitationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type invitationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $invitationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invitations"
    objects: {
      families: Prisma.$familiesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      role: string | null
      token: string | null
      family_id: string
      inviter_id: string
      accepted_at: Date | null
      expires_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invitations"]>
    composites: {}
  }

  type invitationsGetPayload<S extends boolean | null | undefined | invitationsDefaultArgs> = $Result.GetResult<Prisma.$invitationsPayload, S>

  type invitationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invitationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationsCountAggregateInputType | true
    }

  export interface invitationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invitations'], meta: { name: 'invitations' } }
    /**
     * Find zero or one Invitations that matches the filter.
     * @param {invitationsFindUniqueArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invitationsFindUniqueArgs>(args: SelectSubset<T, invitationsFindUniqueArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invitationsFindUniqueOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invitationsFindUniqueOrThrowArgs>(args: SelectSubset<T, invitationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invitationsFindFirstArgs>(args?: SelectSubset<T, invitationsFindFirstArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindFirstOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invitationsFindFirstOrThrowArgs>(args?: SelectSubset<T, invitationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitations.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationsWithIdOnly = await prisma.invitations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invitationsFindManyArgs>(args?: SelectSubset<T, invitationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitations.
     * @param {invitationsCreateArgs} args - Arguments to create a Invitations.
     * @example
     * // Create one Invitations
     * const Invitations = await prisma.invitations.create({
     *   data: {
     *     // ... data to create a Invitations
     *   }
     * })
     * 
     */
    create<T extends invitationsCreateArgs>(args: SelectSubset<T, invitationsCreateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {invitationsCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invitationsCreateManyArgs>(args?: SelectSubset<T, invitationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {invitationsCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invitationsCreateManyAndReturnArgs>(args?: SelectSubset<T, invitationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitations.
     * @param {invitationsDeleteArgs} args - Arguments to delete one Invitations.
     * @example
     * // Delete one Invitations
     * const Invitations = await prisma.invitations.delete({
     *   where: {
     *     // ... filter to delete one Invitations
     *   }
     * })
     * 
     */
    delete<T extends invitationsDeleteArgs>(args: SelectSubset<T, invitationsDeleteArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitations.
     * @param {invitationsUpdateArgs} args - Arguments to update one Invitations.
     * @example
     * // Update one Invitations
     * const invitations = await prisma.invitations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invitationsUpdateArgs>(args: SelectSubset<T, invitationsUpdateArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {invitationsDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invitationsDeleteManyArgs>(args?: SelectSubset<T, invitationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invitationsUpdateManyArgs>(args: SelectSubset<T, invitationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {invitationsUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invitationsUpdateManyAndReturnArgs>(args: SelectSubset<T, invitationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitations.
     * @param {invitationsUpsertArgs} args - Arguments to update or create a Invitations.
     * @example
     * // Update or create a Invitations
     * const invitations = await prisma.invitations.upsert({
     *   create: {
     *     // ... data to create a Invitations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitations we want to update
     *   }
     * })
     */
    upsert<T extends invitationsUpsertArgs>(args: SelectSubset<T, invitationsUpsertArgs<ExtArgs>>): Prisma__invitationsClient<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitations.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends invitationsCountArgs>(
      args?: Subset<T, invitationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationsAggregateArgs>(args: Subset<T, InvitationsAggregateArgs>): Prisma.PrismaPromise<GetInvitationsAggregateType<T>>

    /**
     * Group by Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invitationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invitationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invitationsGroupByArgs['orderBy'] }
        : { orderBy?: invitationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invitationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invitations model
   */
  readonly fields: invitationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invitations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invitationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invitations model
   */
  interface invitationsFieldRefs {
    readonly id: FieldRef<"invitations", 'String'>
    readonly email: FieldRef<"invitations", 'String'>
    readonly role: FieldRef<"invitations", 'String'>
    readonly token: FieldRef<"invitations", 'String'>
    readonly family_id: FieldRef<"invitations", 'String'>
    readonly inviter_id: FieldRef<"invitations", 'String'>
    readonly accepted_at: FieldRef<"invitations", 'DateTime'>
    readonly expires_at: FieldRef<"invitations", 'DateTime'>
    readonly created_at: FieldRef<"invitations", 'DateTime'>
    readonly updated_at: FieldRef<"invitations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invitations findUnique
   */
  export type invitationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findUniqueOrThrow
   */
  export type invitationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations findFirst
   */
  export type invitationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findFirstOrThrow
   */
  export type invitationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations findMany
   */
  export type invitationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter, which invitations to fetch.
     */
    where?: invitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invitations to fetch.
     */
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invitations.
     */
    cursor?: invitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invitations.
     */
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * invitations create
   */
  export type invitationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to create a invitations.
     */
    data: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
  }

  /**
   * invitations createMany
   */
  export type invitationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invitations createManyAndReturn
   */
  export type invitationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to create many invitations.
     */
    data: invitationsCreateManyInput | invitationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations update
   */
  export type invitationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The data needed to update a invitations.
     */
    data: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
    /**
     * Choose, which invitations to update.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations updateMany
   */
  export type invitationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
  }

  /**
   * invitations updateManyAndReturn
   */
  export type invitationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * The data used to update invitations.
     */
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyInput>
    /**
     * Filter which invitations to update
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invitations upsert
   */
  export type invitationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * The filter to search for the invitations to update in case it exists.
     */
    where: invitationsWhereUniqueInput
    /**
     * In case the invitations found by the `where` argument doesn't exist, create a new invitations with this data.
     */
    create: XOR<invitationsCreateInput, invitationsUncheckedCreateInput>
    /**
     * In case the invitations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invitationsUpdateInput, invitationsUncheckedUpdateInput>
  }

  /**
   * invitations delete
   */
  export type invitationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    /**
     * Filter which invitations to delete.
     */
    where: invitationsWhereUniqueInput
  }

  /**
   * invitations deleteMany
   */
  export type invitationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invitations to delete
     */
    where?: invitationsWhereInput
    /**
     * Limit how many invitations to delete.
     */
    limit?: number
  }

  /**
   * invitations without action
   */
  export type invitationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
  }


  /**
   * Model invite_codes
   */

  export type AggregateInvite_codes = {
    _count: Invite_codesCountAggregateOutputType | null
    _min: Invite_codesMinAggregateOutputType | null
    _max: Invite_codesMaxAggregateOutputType | null
  }

  export type Invite_codesMinAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Invite_codesMaxAggregateOutputType = {
    id: string | null
    token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Invite_codesCountAggregateOutputType = {
    id: number
    token: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Invite_codesMinAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    updated_at?: true
  }

  export type Invite_codesMaxAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    updated_at?: true
  }

  export type Invite_codesCountAggregateInputType = {
    id?: true
    token?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Invite_codesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invite_codes to aggregate.
     */
    where?: invite_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invite_codes to fetch.
     */
    orderBy?: invite_codesOrderByWithRelationInput | invite_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invite_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invite_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invite_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invite_codes
    **/
    _count?: true | Invite_codesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invite_codesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invite_codesMaxAggregateInputType
  }

  export type GetInvite_codesAggregateType<T extends Invite_codesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite_codes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite_codes[P]>
      : GetScalarType<T[P], AggregateInvite_codes[P]>
  }




  export type invite_codesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invite_codesWhereInput
    orderBy?: invite_codesOrderByWithAggregationInput | invite_codesOrderByWithAggregationInput[]
    by: Invite_codesScalarFieldEnum[] | Invite_codesScalarFieldEnum
    having?: invite_codesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invite_codesCountAggregateInputType | true
    _min?: Invite_codesMinAggregateInputType
    _max?: Invite_codesMaxAggregateInputType
  }

  export type Invite_codesGroupByOutputType = {
    id: string
    token: string
    created_at: Date
    updated_at: Date
    _count: Invite_codesCountAggregateOutputType | null
    _min: Invite_codesMinAggregateOutputType | null
    _max: Invite_codesMaxAggregateOutputType | null
  }

  type GetInvite_codesGroupByPayload<T extends invite_codesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invite_codesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invite_codesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invite_codesGroupByOutputType[P]>
            : GetScalarType<T[P], Invite_codesGroupByOutputType[P]>
        }
      >
    >


  export type invite_codesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["invite_codes"]>

  export type invite_codesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["invite_codes"]>

  export type invite_codesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["invite_codes"]>

  export type invite_codesSelectScalar = {
    id?: boolean
    token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type invite_codesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "created_at" | "updated_at", ExtArgs["result"]["invite_codes"]>

  export type $invite_codesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invite_codes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invite_codes"]>
    composites: {}
  }

  type invite_codesGetPayload<S extends boolean | null | undefined | invite_codesDefaultArgs> = $Result.GetResult<Prisma.$invite_codesPayload, S>

  type invite_codesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invite_codesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Invite_codesCountAggregateInputType | true
    }

  export interface invite_codesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invite_codes'], meta: { name: 'invite_codes' } }
    /**
     * Find zero or one Invite_codes that matches the filter.
     * @param {invite_codesFindUniqueArgs} args - Arguments to find a Invite_codes
     * @example
     * // Get one Invite_codes
     * const invite_codes = await prisma.invite_codes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invite_codesFindUniqueArgs>(args: SelectSubset<T, invite_codesFindUniqueArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invite_codes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invite_codesFindUniqueOrThrowArgs} args - Arguments to find a Invite_codes
     * @example
     * // Get one Invite_codes
     * const invite_codes = await prisma.invite_codes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invite_codesFindUniqueOrThrowArgs>(args: SelectSubset<T, invite_codesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesFindFirstArgs} args - Arguments to find a Invite_codes
     * @example
     * // Get one Invite_codes
     * const invite_codes = await prisma.invite_codes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invite_codesFindFirstArgs>(args?: SelectSubset<T, invite_codesFindFirstArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite_codes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesFindFirstOrThrowArgs} args - Arguments to find a Invite_codes
     * @example
     * // Get one Invite_codes
     * const invite_codes = await prisma.invite_codes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invite_codesFindFirstOrThrowArgs>(args?: SelectSubset<T, invite_codesFindFirstOrThrowArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invite_codes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invite_codes
     * const invite_codes = await prisma.invite_codes.findMany()
     * 
     * // Get first 10 Invite_codes
     * const invite_codes = await prisma.invite_codes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invite_codesWithIdOnly = await prisma.invite_codes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invite_codesFindManyArgs>(args?: SelectSubset<T, invite_codesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invite_codes.
     * @param {invite_codesCreateArgs} args - Arguments to create a Invite_codes.
     * @example
     * // Create one Invite_codes
     * const Invite_codes = await prisma.invite_codes.create({
     *   data: {
     *     // ... data to create a Invite_codes
     *   }
     * })
     * 
     */
    create<T extends invite_codesCreateArgs>(args: SelectSubset<T, invite_codesCreateArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invite_codes.
     * @param {invite_codesCreateManyArgs} args - Arguments to create many Invite_codes.
     * @example
     * // Create many Invite_codes
     * const invite_codes = await prisma.invite_codes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invite_codesCreateManyArgs>(args?: SelectSubset<T, invite_codesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invite_codes and returns the data saved in the database.
     * @param {invite_codesCreateManyAndReturnArgs} args - Arguments to create many Invite_codes.
     * @example
     * // Create many Invite_codes
     * const invite_codes = await prisma.invite_codes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invite_codes and only return the `id`
     * const invite_codesWithIdOnly = await prisma.invite_codes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends invite_codesCreateManyAndReturnArgs>(args?: SelectSubset<T, invite_codesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invite_codes.
     * @param {invite_codesDeleteArgs} args - Arguments to delete one Invite_codes.
     * @example
     * // Delete one Invite_codes
     * const Invite_codes = await prisma.invite_codes.delete({
     *   where: {
     *     // ... filter to delete one Invite_codes
     *   }
     * })
     * 
     */
    delete<T extends invite_codesDeleteArgs>(args: SelectSubset<T, invite_codesDeleteArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invite_codes.
     * @param {invite_codesUpdateArgs} args - Arguments to update one Invite_codes.
     * @example
     * // Update one Invite_codes
     * const invite_codes = await prisma.invite_codes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invite_codesUpdateArgs>(args: SelectSubset<T, invite_codesUpdateArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invite_codes.
     * @param {invite_codesDeleteManyArgs} args - Arguments to filter Invite_codes to delete.
     * @example
     * // Delete a few Invite_codes
     * const { count } = await prisma.invite_codes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invite_codesDeleteManyArgs>(args?: SelectSubset<T, invite_codesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invite_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invite_codes
     * const invite_codes = await prisma.invite_codes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invite_codesUpdateManyArgs>(args: SelectSubset<T, invite_codesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invite_codes and returns the data updated in the database.
     * @param {invite_codesUpdateManyAndReturnArgs} args - Arguments to update many Invite_codes.
     * @example
     * // Update many Invite_codes
     * const invite_codes = await prisma.invite_codes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invite_codes and only return the `id`
     * const invite_codesWithIdOnly = await prisma.invite_codes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends invite_codesUpdateManyAndReturnArgs>(args: SelectSubset<T, invite_codesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invite_codes.
     * @param {invite_codesUpsertArgs} args - Arguments to update or create a Invite_codes.
     * @example
     * // Update or create a Invite_codes
     * const invite_codes = await prisma.invite_codes.upsert({
     *   create: {
     *     // ... data to create a Invite_codes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite_codes we want to update
     *   }
     * })
     */
    upsert<T extends invite_codesUpsertArgs>(args: SelectSubset<T, invite_codesUpsertArgs<ExtArgs>>): Prisma__invite_codesClient<$Result.GetResult<Prisma.$invite_codesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invite_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesCountArgs} args - Arguments to filter Invite_codes to count.
     * @example
     * // Count the number of Invite_codes
     * const count = await prisma.invite_codes.count({
     *   where: {
     *     // ... the filter for the Invite_codes we want to count
     *   }
     * })
    **/
    count<T extends invite_codesCountArgs>(
      args?: Subset<T, invite_codesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invite_codesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invite_codesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invite_codesAggregateArgs>(args: Subset<T, Invite_codesAggregateArgs>): Prisma.PrismaPromise<GetInvite_codesAggregateType<T>>

    /**
     * Group by Invite_codes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invite_codesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invite_codesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invite_codesGroupByArgs['orderBy'] }
        : { orderBy?: invite_codesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invite_codesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvite_codesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invite_codes model
   */
  readonly fields: invite_codesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invite_codes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invite_codesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invite_codes model
   */
  interface invite_codesFieldRefs {
    readonly id: FieldRef<"invite_codes", 'String'>
    readonly token: FieldRef<"invite_codes", 'String'>
    readonly created_at: FieldRef<"invite_codes", 'DateTime'>
    readonly updated_at: FieldRef<"invite_codes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invite_codes findUnique
   */
  export type invite_codesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter, which invite_codes to fetch.
     */
    where: invite_codesWhereUniqueInput
  }

  /**
   * invite_codes findUniqueOrThrow
   */
  export type invite_codesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter, which invite_codes to fetch.
     */
    where: invite_codesWhereUniqueInput
  }

  /**
   * invite_codes findFirst
   */
  export type invite_codesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter, which invite_codes to fetch.
     */
    where?: invite_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invite_codes to fetch.
     */
    orderBy?: invite_codesOrderByWithRelationInput | invite_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invite_codes.
     */
    cursor?: invite_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invite_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invite_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invite_codes.
     */
    distinct?: Invite_codesScalarFieldEnum | Invite_codesScalarFieldEnum[]
  }

  /**
   * invite_codes findFirstOrThrow
   */
  export type invite_codesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter, which invite_codes to fetch.
     */
    where?: invite_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invite_codes to fetch.
     */
    orderBy?: invite_codesOrderByWithRelationInput | invite_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invite_codes.
     */
    cursor?: invite_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invite_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invite_codes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invite_codes.
     */
    distinct?: Invite_codesScalarFieldEnum | Invite_codesScalarFieldEnum[]
  }

  /**
   * invite_codes findMany
   */
  export type invite_codesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter, which invite_codes to fetch.
     */
    where?: invite_codesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invite_codes to fetch.
     */
    orderBy?: invite_codesOrderByWithRelationInput | invite_codesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invite_codes.
     */
    cursor?: invite_codesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invite_codes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invite_codes.
     */
    skip?: number
    distinct?: Invite_codesScalarFieldEnum | Invite_codesScalarFieldEnum[]
  }

  /**
   * invite_codes create
   */
  export type invite_codesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * The data needed to create a invite_codes.
     */
    data: XOR<invite_codesCreateInput, invite_codesUncheckedCreateInput>
  }

  /**
   * invite_codes createMany
   */
  export type invite_codesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invite_codes.
     */
    data: invite_codesCreateManyInput | invite_codesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invite_codes createManyAndReturn
   */
  export type invite_codesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * The data used to create many invite_codes.
     */
    data: invite_codesCreateManyInput | invite_codesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invite_codes update
   */
  export type invite_codesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * The data needed to update a invite_codes.
     */
    data: XOR<invite_codesUpdateInput, invite_codesUncheckedUpdateInput>
    /**
     * Choose, which invite_codes to update.
     */
    where: invite_codesWhereUniqueInput
  }

  /**
   * invite_codes updateMany
   */
  export type invite_codesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invite_codes.
     */
    data: XOR<invite_codesUpdateManyMutationInput, invite_codesUncheckedUpdateManyInput>
    /**
     * Filter which invite_codes to update
     */
    where?: invite_codesWhereInput
    /**
     * Limit how many invite_codes to update.
     */
    limit?: number
  }

  /**
   * invite_codes updateManyAndReturn
   */
  export type invite_codesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * The data used to update invite_codes.
     */
    data: XOR<invite_codesUpdateManyMutationInput, invite_codesUncheckedUpdateManyInput>
    /**
     * Filter which invite_codes to update
     */
    where?: invite_codesWhereInput
    /**
     * Limit how many invite_codes to update.
     */
    limit?: number
  }

  /**
   * invite_codes upsert
   */
  export type invite_codesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * The filter to search for the invite_codes to update in case it exists.
     */
    where: invite_codesWhereUniqueInput
    /**
     * In case the invite_codes found by the `where` argument doesn't exist, create a new invite_codes with this data.
     */
    create: XOR<invite_codesCreateInput, invite_codesUncheckedCreateInput>
    /**
     * In case the invite_codes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invite_codesUpdateInput, invite_codesUncheckedUpdateInput>
  }

  /**
   * invite_codes delete
   */
  export type invite_codesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
    /**
     * Filter which invite_codes to delete.
     */
    where: invite_codesWhereUniqueInput
  }

  /**
   * invite_codes deleteMany
   */
  export type invite_codesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invite_codes to delete
     */
    where?: invite_codesWhereInput
    /**
     * Limit how many invite_codes to delete.
     */
    limit?: number
  }

  /**
   * invite_codes without action
   */
  export type invite_codesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite_codes
     */
    select?: invite_codesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite_codes
     */
    omit?: invite_codesOmit<ExtArgs> | null
  }


  /**
   * Model loans
   */

  export type AggregateLoans = {
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  export type LoansAvgAggregateOutputType = {
    interest_rate: Decimal | null
    term_months: number | null
    initial_balance: Decimal | null
  }

  export type LoansSumAggregateOutputType = {
    interest_rate: Decimal | null
    term_months: number | null
    initial_balance: Decimal | null
  }

  export type LoansMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    rate_type: string | null
    interest_rate: Decimal | null
    term_months: number | null
    initial_balance: Decimal | null
  }

  export type LoansMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    rate_type: string | null
    interest_rate: Decimal | null
    term_months: number | null
    initial_balance: Decimal | null
  }

  export type LoansCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    rate_type: number
    interest_rate: number
    term_months: number
    initial_balance: number
    locked_attributes: number
    _all: number
  }


  export type LoansAvgAggregateInputType = {
    interest_rate?: true
    term_months?: true
    initial_balance?: true
  }

  export type LoansSumAggregateInputType = {
    interest_rate?: true
    term_months?: true
    initial_balance?: true
  }

  export type LoansMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    rate_type?: true
    interest_rate?: true
    term_months?: true
    initial_balance?: true
  }

  export type LoansMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    rate_type?: true
    interest_rate?: true
    term_months?: true
    initial_balance?: true
  }

  export type LoansCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    rate_type?: true
    interest_rate?: true
    term_months?: true
    initial_balance?: true
    locked_attributes?: true
    _all?: true
  }

  export type LoansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loans to aggregate.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned loans
    **/
    _count?: true | LoansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoansMaxAggregateInputType
  }

  export type GetLoansAggregateType<T extends LoansAggregateArgs> = {
        [P in keyof T & keyof AggregateLoans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoans[P]>
      : GetScalarType<T[P], AggregateLoans[P]>
  }




  export type loansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loansWhereInput
    orderBy?: loansOrderByWithAggregationInput | loansOrderByWithAggregationInput[]
    by: LoansScalarFieldEnum[] | LoansScalarFieldEnum
    having?: loansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoansCountAggregateInputType | true
    _avg?: LoansAvgAggregateInputType
    _sum?: LoansSumAggregateInputType
    _min?: LoansMinAggregateInputType
    _max?: LoansMaxAggregateInputType
  }

  export type LoansGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    rate_type: string | null
    interest_rate: Decimal | null
    term_months: number | null
    initial_balance: Decimal | null
    locked_attributes: JsonValue | null
    _count: LoansCountAggregateOutputType | null
    _avg: LoansAvgAggregateOutputType | null
    _sum: LoansSumAggregateOutputType | null
    _min: LoansMinAggregateOutputType | null
    _max: LoansMaxAggregateOutputType | null
  }

  type GetLoansGroupByPayload<T extends loansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoansGroupByOutputType[P]>
            : GetScalarType<T[P], LoansGroupByOutputType[P]>
        }
      >
    >


  export type loansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    rate_type?: boolean
    interest_rate?: boolean
    term_months?: boolean
    initial_balance?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["loans"]>

  export type loansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    rate_type?: boolean
    interest_rate?: boolean
    term_months?: boolean
    initial_balance?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["loans"]>

  export type loansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    rate_type?: boolean
    interest_rate?: boolean
    term_months?: boolean
    initial_balance?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["loans"]>

  export type loansSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    rate_type?: boolean
    interest_rate?: boolean
    term_months?: boolean
    initial_balance?: boolean
    locked_attributes?: boolean
  }

  export type loansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "rate_type" | "interest_rate" | "term_months" | "initial_balance" | "locked_attributes", ExtArgs["result"]["loans"]>

  export type $loansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "loans"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      rate_type: string | null
      interest_rate: Prisma.Decimal | null
      term_months: number | null
      initial_balance: Prisma.Decimal | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["loans"]>
    composites: {}
  }

  type loansGetPayload<S extends boolean | null | undefined | loansDefaultArgs> = $Result.GetResult<Prisma.$loansPayload, S>

  type loansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<loansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoansCountAggregateInputType | true
    }

  export interface loansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['loans'], meta: { name: 'loans' } }
    /**
     * Find zero or one Loans that matches the filter.
     * @param {loansFindUniqueArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loansFindUniqueArgs>(args: SelectSubset<T, loansFindUniqueArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Loans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {loansFindUniqueOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loansFindUniqueOrThrowArgs>(args: SelectSubset<T, loansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindFirstArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loansFindFirstArgs>(args?: SelectSubset<T, loansFindFirstArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Loans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindFirstOrThrowArgs} args - Arguments to find a Loans
     * @example
     * // Get one Loans
     * const loans = await prisma.loans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loansFindFirstOrThrowArgs>(args?: SelectSubset<T, loansFindFirstOrThrowArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Loans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Loans
     * const loans = await prisma.loans.findMany()
     * 
     * // Get first 10 Loans
     * const loans = await prisma.loans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loansWithIdOnly = await prisma.loans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends loansFindManyArgs>(args?: SelectSubset<T, loansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Loans.
     * @param {loansCreateArgs} args - Arguments to create a Loans.
     * @example
     * // Create one Loans
     * const Loans = await prisma.loans.create({
     *   data: {
     *     // ... data to create a Loans
     *   }
     * })
     * 
     */
    create<T extends loansCreateArgs>(args: SelectSubset<T, loansCreateArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Loans.
     * @param {loansCreateManyArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loans = await prisma.loans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loansCreateManyArgs>(args?: SelectSubset<T, loansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Loans and returns the data saved in the database.
     * @param {loansCreateManyAndReturnArgs} args - Arguments to create many Loans.
     * @example
     * // Create many Loans
     * const loans = await prisma.loans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Loans and only return the `id`
     * const loansWithIdOnly = await prisma.loans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends loansCreateManyAndReturnArgs>(args?: SelectSubset<T, loansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Loans.
     * @param {loansDeleteArgs} args - Arguments to delete one Loans.
     * @example
     * // Delete one Loans
     * const Loans = await prisma.loans.delete({
     *   where: {
     *     // ... filter to delete one Loans
     *   }
     * })
     * 
     */
    delete<T extends loansDeleteArgs>(args: SelectSubset<T, loansDeleteArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Loans.
     * @param {loansUpdateArgs} args - Arguments to update one Loans.
     * @example
     * // Update one Loans
     * const loans = await prisma.loans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loansUpdateArgs>(args: SelectSubset<T, loansUpdateArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Loans.
     * @param {loansDeleteManyArgs} args - Arguments to filter Loans to delete.
     * @example
     * // Delete a few Loans
     * const { count } = await prisma.loans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loansDeleteManyArgs>(args?: SelectSubset<T, loansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Loans
     * const loans = await prisma.loans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loansUpdateManyArgs>(args: SelectSubset<T, loansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Loans and returns the data updated in the database.
     * @param {loansUpdateManyAndReturnArgs} args - Arguments to update many Loans.
     * @example
     * // Update many Loans
     * const loans = await prisma.loans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Loans and only return the `id`
     * const loansWithIdOnly = await prisma.loans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends loansUpdateManyAndReturnArgs>(args: SelectSubset<T, loansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Loans.
     * @param {loansUpsertArgs} args - Arguments to update or create a Loans.
     * @example
     * // Update or create a Loans
     * const loans = await prisma.loans.upsert({
     *   create: {
     *     // ... data to create a Loans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loans we want to update
     *   }
     * })
     */
    upsert<T extends loansUpsertArgs>(args: SelectSubset<T, loansUpsertArgs<ExtArgs>>): Prisma__loansClient<$Result.GetResult<Prisma.$loansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansCountArgs} args - Arguments to filter Loans to count.
     * @example
     * // Count the number of Loans
     * const count = await prisma.loans.count({
     *   where: {
     *     // ... the filter for the Loans we want to count
     *   }
     * })
    **/
    count<T extends loansCountArgs>(
      args?: Subset<T, loansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoansAggregateArgs>(args: Subset<T, LoansAggregateArgs>): Prisma.PrismaPromise<GetLoansAggregateType<T>>

    /**
     * Group by Loans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loansGroupByArgs['orderBy'] }
        : { orderBy?: loansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the loans model
   */
  readonly fields: loansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for loans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the loans model
   */
  interface loansFieldRefs {
    readonly id: FieldRef<"loans", 'String'>
    readonly created_at: FieldRef<"loans", 'DateTime'>
    readonly updated_at: FieldRef<"loans", 'DateTime'>
    readonly rate_type: FieldRef<"loans", 'String'>
    readonly interest_rate: FieldRef<"loans", 'Decimal'>
    readonly term_months: FieldRef<"loans", 'Int'>
    readonly initial_balance: FieldRef<"loans", 'Decimal'>
    readonly locked_attributes: FieldRef<"loans", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * loans findUnique
   */
  export type loansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans findUniqueOrThrow
   */
  export type loansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans findFirst
   */
  export type loansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans findFirstOrThrow
   */
  export type loansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of loans.
     */
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans findMany
   */
  export type loansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter, which loans to fetch.
     */
    where?: loansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of loans to fetch.
     */
    orderBy?: loansOrderByWithRelationInput | loansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing loans.
     */
    cursor?: loansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` loans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` loans.
     */
    skip?: number
    distinct?: LoansScalarFieldEnum | LoansScalarFieldEnum[]
  }

  /**
   * loans create
   */
  export type loansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data needed to create a loans.
     */
    data: XOR<loansCreateInput, loansUncheckedCreateInput>
  }

  /**
   * loans createMany
   */
  export type loansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many loans.
     */
    data: loansCreateManyInput | loansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loans createManyAndReturn
   */
  export type loansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data used to create many loans.
     */
    data: loansCreateManyInput | loansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * loans update
   */
  export type loansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data needed to update a loans.
     */
    data: XOR<loansUpdateInput, loansUncheckedUpdateInput>
    /**
     * Choose, which loans to update.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans updateMany
   */
  export type loansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update loans.
     */
    data: XOR<loansUpdateManyMutationInput, loansUncheckedUpdateManyInput>
    /**
     * Filter which loans to update
     */
    where?: loansWhereInput
    /**
     * Limit how many loans to update.
     */
    limit?: number
  }

  /**
   * loans updateManyAndReturn
   */
  export type loansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The data used to update loans.
     */
    data: XOR<loansUpdateManyMutationInput, loansUncheckedUpdateManyInput>
    /**
     * Filter which loans to update
     */
    where?: loansWhereInput
    /**
     * Limit how many loans to update.
     */
    limit?: number
  }

  /**
   * loans upsert
   */
  export type loansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * The filter to search for the loans to update in case it exists.
     */
    where: loansWhereUniqueInput
    /**
     * In case the loans found by the `where` argument doesn't exist, create a new loans with this data.
     */
    create: XOR<loansCreateInput, loansUncheckedCreateInput>
    /**
     * In case the loans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loansUpdateInput, loansUncheckedUpdateInput>
  }

  /**
   * loans delete
   */
  export type loansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
    /**
     * Filter which loans to delete.
     */
    where: loansWhereUniqueInput
  }

  /**
   * loans deleteMany
   */
  export type loansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which loans to delete
     */
    where?: loansWhereInput
    /**
     * Limit how many loans to delete.
     */
    limit?: number
  }

  /**
   * loans without action
   */
  export type loansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the loans
     */
    select?: loansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the loans
     */
    omit?: loansOmit<ExtArgs> | null
  }


  /**
   * Model merchants
   */

  export type AggregateMerchants = {
    _count: MerchantsCountAggregateOutputType | null
    _min: MerchantsMinAggregateOutputType | null
    _max: MerchantsMaxAggregateOutputType | null
  }

  export type MerchantsMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
    logo_url: string | null
    website_url: string | null
    type: string | null
    source: string | null
    provider_merchant_id: string | null
  }

  export type MerchantsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
    logo_url: string | null
    website_url: string | null
    type: string | null
    source: string | null
    provider_merchant_id: string | null
  }

  export type MerchantsCountAggregateOutputType = {
    id: number
    name: number
    color: number
    family_id: number
    created_at: number
    updated_at: number
    logo_url: number
    website_url: number
    type: number
    source: number
    provider_merchant_id: number
    _all: number
  }


  export type MerchantsMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    logo_url?: true
    website_url?: true
    type?: true
    source?: true
    provider_merchant_id?: true
  }

  export type MerchantsMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    logo_url?: true
    website_url?: true
    type?: true
    source?: true
    provider_merchant_id?: true
  }

  export type MerchantsCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    logo_url?: true
    website_url?: true
    type?: true
    source?: true
    provider_merchant_id?: true
    _all?: true
  }

  export type MerchantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which merchants to aggregate.
     */
    where?: merchantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantsOrderByWithRelationInput | merchantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: merchantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned merchants
    **/
    _count?: true | MerchantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MerchantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MerchantsMaxAggregateInputType
  }

  export type GetMerchantsAggregateType<T extends MerchantsAggregateArgs> = {
        [P in keyof T & keyof AggregateMerchants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMerchants[P]>
      : GetScalarType<T[P], AggregateMerchants[P]>
  }




  export type merchantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: merchantsWhereInput
    orderBy?: merchantsOrderByWithAggregationInput | merchantsOrderByWithAggregationInput[]
    by: MerchantsScalarFieldEnum[] | MerchantsScalarFieldEnum
    having?: merchantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MerchantsCountAggregateInputType | true
    _min?: MerchantsMinAggregateInputType
    _max?: MerchantsMaxAggregateInputType
  }

  export type MerchantsGroupByOutputType = {
    id: string
    name: string
    color: string | null
    family_id: string | null
    created_at: Date
    updated_at: Date
    logo_url: string | null
    website_url: string | null
    type: string
    source: string | null
    provider_merchant_id: string | null
    _count: MerchantsCountAggregateOutputType | null
    _min: MerchantsMinAggregateOutputType | null
    _max: MerchantsMaxAggregateOutputType | null
  }

  type GetMerchantsGroupByPayload<T extends merchantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MerchantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MerchantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MerchantsGroupByOutputType[P]>
            : GetScalarType<T[P], MerchantsGroupByOutputType[P]>
        }
      >
    >


  export type merchantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    logo_url?: boolean
    website_url?: boolean
    type?: boolean
    source?: boolean
    provider_merchant_id?: boolean
    families?: boolean | merchants$familiesArgs<ExtArgs>
    transactions?: boolean | merchants$transactionsArgs<ExtArgs>
    _count?: boolean | MerchantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["merchants"]>

  export type merchantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    logo_url?: boolean
    website_url?: boolean
    type?: boolean
    source?: boolean
    provider_merchant_id?: boolean
    families?: boolean | merchants$familiesArgs<ExtArgs>
  }, ExtArgs["result"]["merchants"]>

  export type merchantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    logo_url?: boolean
    website_url?: boolean
    type?: boolean
    source?: boolean
    provider_merchant_id?: boolean
    families?: boolean | merchants$familiesArgs<ExtArgs>
  }, ExtArgs["result"]["merchants"]>

  export type merchantsSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    logo_url?: boolean
    website_url?: boolean
    type?: boolean
    source?: boolean
    provider_merchant_id?: boolean
  }

  export type merchantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "family_id" | "created_at" | "updated_at" | "logo_url" | "website_url" | "type" | "source" | "provider_merchant_id", ExtArgs["result"]["merchants"]>
  export type merchantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | merchants$familiesArgs<ExtArgs>
    transactions?: boolean | merchants$transactionsArgs<ExtArgs>
    _count?: boolean | MerchantsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type merchantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | merchants$familiesArgs<ExtArgs>
  }
  export type merchantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | merchants$familiesArgs<ExtArgs>
  }

  export type $merchantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "merchants"
    objects: {
      families: Prisma.$familiesPayload<ExtArgs> | null
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      family_id: string | null
      created_at: Date
      updated_at: Date
      logo_url: string | null
      website_url: string | null
      type: string
      source: string | null
      provider_merchant_id: string | null
    }, ExtArgs["result"]["merchants"]>
    composites: {}
  }

  type merchantsGetPayload<S extends boolean | null | undefined | merchantsDefaultArgs> = $Result.GetResult<Prisma.$merchantsPayload, S>

  type merchantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<merchantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MerchantsCountAggregateInputType | true
    }

  export interface merchantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['merchants'], meta: { name: 'merchants' } }
    /**
     * Find zero or one Merchants that matches the filter.
     * @param {merchantsFindUniqueArgs} args - Arguments to find a Merchants
     * @example
     * // Get one Merchants
     * const merchants = await prisma.merchants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends merchantsFindUniqueArgs>(args: SelectSubset<T, merchantsFindUniqueArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Merchants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {merchantsFindUniqueOrThrowArgs} args - Arguments to find a Merchants
     * @example
     * // Get one Merchants
     * const merchants = await prisma.merchants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends merchantsFindUniqueOrThrowArgs>(args: SelectSubset<T, merchantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsFindFirstArgs} args - Arguments to find a Merchants
     * @example
     * // Get one Merchants
     * const merchants = await prisma.merchants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends merchantsFindFirstArgs>(args?: SelectSubset<T, merchantsFindFirstArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Merchants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsFindFirstOrThrowArgs} args - Arguments to find a Merchants
     * @example
     * // Get one Merchants
     * const merchants = await prisma.merchants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends merchantsFindFirstOrThrowArgs>(args?: SelectSubset<T, merchantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Merchants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Merchants
     * const merchants = await prisma.merchants.findMany()
     * 
     * // Get first 10 Merchants
     * const merchants = await prisma.merchants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const merchantsWithIdOnly = await prisma.merchants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends merchantsFindManyArgs>(args?: SelectSubset<T, merchantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Merchants.
     * @param {merchantsCreateArgs} args - Arguments to create a Merchants.
     * @example
     * // Create one Merchants
     * const Merchants = await prisma.merchants.create({
     *   data: {
     *     // ... data to create a Merchants
     *   }
     * })
     * 
     */
    create<T extends merchantsCreateArgs>(args: SelectSubset<T, merchantsCreateArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Merchants.
     * @param {merchantsCreateManyArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchants = await prisma.merchants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends merchantsCreateManyArgs>(args?: SelectSubset<T, merchantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Merchants and returns the data saved in the database.
     * @param {merchantsCreateManyAndReturnArgs} args - Arguments to create many Merchants.
     * @example
     * // Create many Merchants
     * const merchants = await prisma.merchants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Merchants and only return the `id`
     * const merchantsWithIdOnly = await prisma.merchants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends merchantsCreateManyAndReturnArgs>(args?: SelectSubset<T, merchantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Merchants.
     * @param {merchantsDeleteArgs} args - Arguments to delete one Merchants.
     * @example
     * // Delete one Merchants
     * const Merchants = await prisma.merchants.delete({
     *   where: {
     *     // ... filter to delete one Merchants
     *   }
     * })
     * 
     */
    delete<T extends merchantsDeleteArgs>(args: SelectSubset<T, merchantsDeleteArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Merchants.
     * @param {merchantsUpdateArgs} args - Arguments to update one Merchants.
     * @example
     * // Update one Merchants
     * const merchants = await prisma.merchants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends merchantsUpdateArgs>(args: SelectSubset<T, merchantsUpdateArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Merchants.
     * @param {merchantsDeleteManyArgs} args - Arguments to filter Merchants to delete.
     * @example
     * // Delete a few Merchants
     * const { count } = await prisma.merchants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends merchantsDeleteManyArgs>(args?: SelectSubset<T, merchantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Merchants
     * const merchants = await prisma.merchants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends merchantsUpdateManyArgs>(args: SelectSubset<T, merchantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Merchants and returns the data updated in the database.
     * @param {merchantsUpdateManyAndReturnArgs} args - Arguments to update many Merchants.
     * @example
     * // Update many Merchants
     * const merchants = await prisma.merchants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Merchants and only return the `id`
     * const merchantsWithIdOnly = await prisma.merchants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends merchantsUpdateManyAndReturnArgs>(args: SelectSubset<T, merchantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Merchants.
     * @param {merchantsUpsertArgs} args - Arguments to update or create a Merchants.
     * @example
     * // Update or create a Merchants
     * const merchants = await prisma.merchants.upsert({
     *   create: {
     *     // ... data to create a Merchants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Merchants we want to update
     *   }
     * })
     */
    upsert<T extends merchantsUpsertArgs>(args: SelectSubset<T, merchantsUpsertArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsCountArgs} args - Arguments to filter Merchants to count.
     * @example
     * // Count the number of Merchants
     * const count = await prisma.merchants.count({
     *   where: {
     *     // ... the filter for the Merchants we want to count
     *   }
     * })
    **/
    count<T extends merchantsCountArgs>(
      args?: Subset<T, merchantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MerchantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MerchantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MerchantsAggregateArgs>(args: Subset<T, MerchantsAggregateArgs>): Prisma.PrismaPromise<GetMerchantsAggregateType<T>>

    /**
     * Group by Merchants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {merchantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends merchantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: merchantsGroupByArgs['orderBy'] }
        : { orderBy?: merchantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, merchantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMerchantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the merchants model
   */
  readonly fields: merchantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for merchants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__merchantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    families<T extends merchants$familiesArgs<ExtArgs> = {}>(args?: Subset<T, merchants$familiesArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends merchants$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, merchants$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the merchants model
   */
  interface merchantsFieldRefs {
    readonly id: FieldRef<"merchants", 'String'>
    readonly name: FieldRef<"merchants", 'String'>
    readonly color: FieldRef<"merchants", 'String'>
    readonly family_id: FieldRef<"merchants", 'String'>
    readonly created_at: FieldRef<"merchants", 'DateTime'>
    readonly updated_at: FieldRef<"merchants", 'DateTime'>
    readonly logo_url: FieldRef<"merchants", 'String'>
    readonly website_url: FieldRef<"merchants", 'String'>
    readonly type: FieldRef<"merchants", 'String'>
    readonly source: FieldRef<"merchants", 'String'>
    readonly provider_merchant_id: FieldRef<"merchants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * merchants findUnique
   */
  export type merchantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where: merchantsWhereUniqueInput
  }

  /**
   * merchants findUniqueOrThrow
   */
  export type merchantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where: merchantsWhereUniqueInput
  }

  /**
   * merchants findFirst
   */
  export type merchantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where?: merchantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantsOrderByWithRelationInput | merchantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for merchants.
     */
    cursor?: merchantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of merchants.
     */
    distinct?: MerchantsScalarFieldEnum | MerchantsScalarFieldEnum[]
  }

  /**
   * merchants findFirstOrThrow
   */
  export type merchantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where?: merchantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantsOrderByWithRelationInput | merchantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for merchants.
     */
    cursor?: merchantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of merchants.
     */
    distinct?: MerchantsScalarFieldEnum | MerchantsScalarFieldEnum[]
  }

  /**
   * merchants findMany
   */
  export type merchantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter, which merchants to fetch.
     */
    where?: merchantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of merchants to fetch.
     */
    orderBy?: merchantsOrderByWithRelationInput | merchantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing merchants.
     */
    cursor?: merchantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` merchants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` merchants.
     */
    skip?: number
    distinct?: MerchantsScalarFieldEnum | MerchantsScalarFieldEnum[]
  }

  /**
   * merchants create
   */
  export type merchantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * The data needed to create a merchants.
     */
    data: XOR<merchantsCreateInput, merchantsUncheckedCreateInput>
  }

  /**
   * merchants createMany
   */
  export type merchantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many merchants.
     */
    data: merchantsCreateManyInput | merchantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * merchants createManyAndReturn
   */
  export type merchantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * The data used to create many merchants.
     */
    data: merchantsCreateManyInput | merchantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * merchants update
   */
  export type merchantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * The data needed to update a merchants.
     */
    data: XOR<merchantsUpdateInput, merchantsUncheckedUpdateInput>
    /**
     * Choose, which merchants to update.
     */
    where: merchantsWhereUniqueInput
  }

  /**
   * merchants updateMany
   */
  export type merchantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update merchants.
     */
    data: XOR<merchantsUpdateManyMutationInput, merchantsUncheckedUpdateManyInput>
    /**
     * Filter which merchants to update
     */
    where?: merchantsWhereInput
    /**
     * Limit how many merchants to update.
     */
    limit?: number
  }

  /**
   * merchants updateManyAndReturn
   */
  export type merchantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * The data used to update merchants.
     */
    data: XOR<merchantsUpdateManyMutationInput, merchantsUncheckedUpdateManyInput>
    /**
     * Filter which merchants to update
     */
    where?: merchantsWhereInput
    /**
     * Limit how many merchants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * merchants upsert
   */
  export type merchantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * The filter to search for the merchants to update in case it exists.
     */
    where: merchantsWhereUniqueInput
    /**
     * In case the merchants found by the `where` argument doesn't exist, create a new merchants with this data.
     */
    create: XOR<merchantsCreateInput, merchantsUncheckedCreateInput>
    /**
     * In case the merchants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<merchantsUpdateInput, merchantsUncheckedUpdateInput>
  }

  /**
   * merchants delete
   */
  export type merchantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    /**
     * Filter which merchants to delete.
     */
    where: merchantsWhereUniqueInput
  }

  /**
   * merchants deleteMany
   */
  export type merchantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which merchants to delete
     */
    where?: merchantsWhereInput
    /**
     * Limit how many merchants to delete.
     */
    limit?: number
  }

  /**
   * merchants.families
   */
  export type merchants$familiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the families
     */
    select?: familiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the families
     */
    omit?: familiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: familiesInclude<ExtArgs> | null
    where?: familiesWhereInput
  }

  /**
   * merchants.transactions
   */
  export type merchants$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * merchants without action
   */
  export type merchantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    chat_id: string | null
    type: string | null
    status: string | null
    content: string | null
    ai_model: string | null
    created_at: Date | null
    updated_at: Date | null
    debug: boolean | null
    provider_id: string | null
    reasoning: boolean | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    chat_id: string | null
    type: string | null
    status: string | null
    content: string | null
    ai_model: string | null
    created_at: Date | null
    updated_at: Date | null
    debug: boolean | null
    provider_id: string | null
    reasoning: boolean | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    chat_id: number
    type: number
    status: number
    content: number
    ai_model: number
    created_at: number
    updated_at: number
    debug: number
    provider_id: number
    reasoning: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    chat_id?: true
    type?: true
    status?: true
    content?: true
    ai_model?: true
    created_at?: true
    updated_at?: true
    debug?: true
    provider_id?: true
    reasoning?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    chat_id?: true
    type?: true
    status?: true
    content?: true
    ai_model?: true
    created_at?: true
    updated_at?: true
    debug?: true
    provider_id?: true
    reasoning?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    chat_id?: true
    type?: true
    status?: true
    content?: true
    ai_model?: true
    created_at?: true
    updated_at?: true
    debug?: true
    provider_id?: true
    reasoning?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    chat_id: string
    type: string
    status: string
    content: string | null
    ai_model: string | null
    created_at: Date
    updated_at: Date
    debug: boolean | null
    provider_id: string | null
    reasoning: boolean | null
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    type?: boolean
    status?: boolean
    content?: boolean
    ai_model?: boolean
    created_at?: boolean
    updated_at?: boolean
    debug?: boolean
    provider_id?: boolean
    reasoning?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    tool_calls?: boolean | messages$tool_callsArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    type?: boolean
    status?: boolean
    content?: boolean
    ai_model?: boolean
    created_at?: boolean
    updated_at?: boolean
    debug?: boolean
    provider_id?: boolean
    reasoning?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    type?: boolean
    status?: boolean
    content?: boolean
    ai_model?: boolean
    created_at?: boolean
    updated_at?: boolean
    debug?: boolean
    provider_id?: boolean
    reasoning?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectScalar = {
    id?: boolean
    chat_id?: boolean
    type?: boolean
    status?: boolean
    content?: boolean
    ai_model?: boolean
    created_at?: boolean
    updated_at?: boolean
    debug?: boolean
    provider_id?: boolean
    reasoning?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chat_id" | "type" | "status" | "content" | "ai_model" | "created_at" | "updated_at" | "debug" | "provider_id" | "reasoning", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    tool_calls?: boolean | messages$tool_callsArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }
  export type messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      chats: Prisma.$chatsPayload<ExtArgs>
      tool_calls: Prisma.$tool_callsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chat_id: string
      type: string
      status: string
      content: string | null
      ai_model: string | null
      created_at: Date
      updated_at: Date
      debug: boolean | null
      provider_id: string | null
      reasoning: boolean | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tool_calls<T extends messages$tool_callsArgs<ExtArgs> = {}>(args?: Subset<T, messages$tool_callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'String'>
    readonly chat_id: FieldRef<"messages", 'String'>
    readonly type: FieldRef<"messages", 'String'>
    readonly status: FieldRef<"messages", 'String'>
    readonly content: FieldRef<"messages", 'String'>
    readonly ai_model: FieldRef<"messages", 'String'>
    readonly created_at: FieldRef<"messages", 'DateTime'>
    readonly updated_at: FieldRef<"messages", 'DateTime'>
    readonly debug: FieldRef<"messages", 'Boolean'>
    readonly provider_id: FieldRef<"messages", 'String'>
    readonly reasoning: FieldRef<"messages", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages createManyAndReturn
   */
  export type messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * messages updateManyAndReturn
   */
  export type messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * messages.tool_calls
   */
  export type messages$tool_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    where?: tool_callsWhereInput
    orderBy?: tool_callsOrderByWithRelationInput | tool_callsOrderByWithRelationInput[]
    cursor?: tool_callsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tool_callsScalarFieldEnum | Tool_callsScalarFieldEnum[]
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model other_assets
   */

  export type AggregateOther_assets = {
    _count: Other_assetsCountAggregateOutputType | null
    _min: Other_assetsMinAggregateOutputType | null
    _max: Other_assetsMaxAggregateOutputType | null
  }

  export type Other_assetsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Other_assetsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Other_assetsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type Other_assetsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type Other_assetsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type Other_assetsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type Other_assetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_assets to aggregate.
     */
    where?: other_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_assets to fetch.
     */
    orderBy?: other_assetsOrderByWithRelationInput | other_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: other_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned other_assets
    **/
    _count?: true | Other_assetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Other_assetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Other_assetsMaxAggregateInputType
  }

  export type GetOther_assetsAggregateType<T extends Other_assetsAggregateArgs> = {
        [P in keyof T & keyof AggregateOther_assets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOther_assets[P]>
      : GetScalarType<T[P], AggregateOther_assets[P]>
  }




  export type other_assetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_assetsWhereInput
    orderBy?: other_assetsOrderByWithAggregationInput | other_assetsOrderByWithAggregationInput[]
    by: Other_assetsScalarFieldEnum[] | Other_assetsScalarFieldEnum
    having?: other_assetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Other_assetsCountAggregateInputType | true
    _min?: Other_assetsMinAggregateInputType
    _max?: Other_assetsMaxAggregateInputType
  }

  export type Other_assetsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: Other_assetsCountAggregateOutputType | null
    _min: Other_assetsMinAggregateOutputType | null
    _max: Other_assetsMaxAggregateOutputType | null
  }

  type GetOther_assetsGroupByPayload<T extends other_assetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Other_assetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Other_assetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Other_assetsGroupByOutputType[P]>
            : GetScalarType<T[P], Other_assetsGroupByOutputType[P]>
        }
      >
    >


  export type other_assetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_assets"]>

  export type other_assetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_assets"]>

  export type other_assetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_assets"]>

  export type other_assetsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type other_assetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["other_assets"]>

  export type $other_assetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "other_assets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["other_assets"]>
    composites: {}
  }

  type other_assetsGetPayload<S extends boolean | null | undefined | other_assetsDefaultArgs> = $Result.GetResult<Prisma.$other_assetsPayload, S>

  type other_assetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<other_assetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Other_assetsCountAggregateInputType | true
    }

  export interface other_assetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['other_assets'], meta: { name: 'other_assets' } }
    /**
     * Find zero or one Other_assets that matches the filter.
     * @param {other_assetsFindUniqueArgs} args - Arguments to find a Other_assets
     * @example
     * // Get one Other_assets
     * const other_assets = await prisma.other_assets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends other_assetsFindUniqueArgs>(args: SelectSubset<T, other_assetsFindUniqueArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Other_assets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {other_assetsFindUniqueOrThrowArgs} args - Arguments to find a Other_assets
     * @example
     * // Get one Other_assets
     * const other_assets = await prisma.other_assets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends other_assetsFindUniqueOrThrowArgs>(args: SelectSubset<T, other_assetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsFindFirstArgs} args - Arguments to find a Other_assets
     * @example
     * // Get one Other_assets
     * const other_assets = await prisma.other_assets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends other_assetsFindFirstArgs>(args?: SelectSubset<T, other_assetsFindFirstArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_assets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsFindFirstOrThrowArgs} args - Arguments to find a Other_assets
     * @example
     * // Get one Other_assets
     * const other_assets = await prisma.other_assets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends other_assetsFindFirstOrThrowArgs>(args?: SelectSubset<T, other_assetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Other_assets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Other_assets
     * const other_assets = await prisma.other_assets.findMany()
     * 
     * // Get first 10 Other_assets
     * const other_assets = await prisma.other_assets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const other_assetsWithIdOnly = await prisma.other_assets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends other_assetsFindManyArgs>(args?: SelectSubset<T, other_assetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Other_assets.
     * @param {other_assetsCreateArgs} args - Arguments to create a Other_assets.
     * @example
     * // Create one Other_assets
     * const Other_assets = await prisma.other_assets.create({
     *   data: {
     *     // ... data to create a Other_assets
     *   }
     * })
     * 
     */
    create<T extends other_assetsCreateArgs>(args: SelectSubset<T, other_assetsCreateArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Other_assets.
     * @param {other_assetsCreateManyArgs} args - Arguments to create many Other_assets.
     * @example
     * // Create many Other_assets
     * const other_assets = await prisma.other_assets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends other_assetsCreateManyArgs>(args?: SelectSubset<T, other_assetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Other_assets and returns the data saved in the database.
     * @param {other_assetsCreateManyAndReturnArgs} args - Arguments to create many Other_assets.
     * @example
     * // Create many Other_assets
     * const other_assets = await prisma.other_assets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Other_assets and only return the `id`
     * const other_assetsWithIdOnly = await prisma.other_assets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends other_assetsCreateManyAndReturnArgs>(args?: SelectSubset<T, other_assetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Other_assets.
     * @param {other_assetsDeleteArgs} args - Arguments to delete one Other_assets.
     * @example
     * // Delete one Other_assets
     * const Other_assets = await prisma.other_assets.delete({
     *   where: {
     *     // ... filter to delete one Other_assets
     *   }
     * })
     * 
     */
    delete<T extends other_assetsDeleteArgs>(args: SelectSubset<T, other_assetsDeleteArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Other_assets.
     * @param {other_assetsUpdateArgs} args - Arguments to update one Other_assets.
     * @example
     * // Update one Other_assets
     * const other_assets = await prisma.other_assets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends other_assetsUpdateArgs>(args: SelectSubset<T, other_assetsUpdateArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Other_assets.
     * @param {other_assetsDeleteManyArgs} args - Arguments to filter Other_assets to delete.
     * @example
     * // Delete a few Other_assets
     * const { count } = await prisma.other_assets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends other_assetsDeleteManyArgs>(args?: SelectSubset<T, other_assetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Other_assets
     * const other_assets = await prisma.other_assets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends other_assetsUpdateManyArgs>(args: SelectSubset<T, other_assetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_assets and returns the data updated in the database.
     * @param {other_assetsUpdateManyAndReturnArgs} args - Arguments to update many Other_assets.
     * @example
     * // Update many Other_assets
     * const other_assets = await prisma.other_assets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Other_assets and only return the `id`
     * const other_assetsWithIdOnly = await prisma.other_assets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends other_assetsUpdateManyAndReturnArgs>(args: SelectSubset<T, other_assetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Other_assets.
     * @param {other_assetsUpsertArgs} args - Arguments to update or create a Other_assets.
     * @example
     * // Update or create a Other_assets
     * const other_assets = await prisma.other_assets.upsert({
     *   create: {
     *     // ... data to create a Other_assets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Other_assets we want to update
     *   }
     * })
     */
    upsert<T extends other_assetsUpsertArgs>(args: SelectSubset<T, other_assetsUpsertArgs<ExtArgs>>): Prisma__other_assetsClient<$Result.GetResult<Prisma.$other_assetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Other_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsCountArgs} args - Arguments to filter Other_assets to count.
     * @example
     * // Count the number of Other_assets
     * const count = await prisma.other_assets.count({
     *   where: {
     *     // ... the filter for the Other_assets we want to count
     *   }
     * })
    **/
    count<T extends other_assetsCountArgs>(
      args?: Subset<T, other_assetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Other_assetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Other_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Other_assetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Other_assetsAggregateArgs>(args: Subset<T, Other_assetsAggregateArgs>): Prisma.PrismaPromise<GetOther_assetsAggregateType<T>>

    /**
     * Group by Other_assets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_assetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends other_assetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: other_assetsGroupByArgs['orderBy'] }
        : { orderBy?: other_assetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, other_assetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOther_assetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the other_assets model
   */
  readonly fields: other_assetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for other_assets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__other_assetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the other_assets model
   */
  interface other_assetsFieldRefs {
    readonly id: FieldRef<"other_assets", 'String'>
    readonly created_at: FieldRef<"other_assets", 'DateTime'>
    readonly updated_at: FieldRef<"other_assets", 'DateTime'>
    readonly locked_attributes: FieldRef<"other_assets", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * other_assets findUnique
   */
  export type other_assetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter, which other_assets to fetch.
     */
    where: other_assetsWhereUniqueInput
  }

  /**
   * other_assets findUniqueOrThrow
   */
  export type other_assetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter, which other_assets to fetch.
     */
    where: other_assetsWhereUniqueInput
  }

  /**
   * other_assets findFirst
   */
  export type other_assetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter, which other_assets to fetch.
     */
    where?: other_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_assets to fetch.
     */
    orderBy?: other_assetsOrderByWithRelationInput | other_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_assets.
     */
    cursor?: other_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_assets.
     */
    distinct?: Other_assetsScalarFieldEnum | Other_assetsScalarFieldEnum[]
  }

  /**
   * other_assets findFirstOrThrow
   */
  export type other_assetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter, which other_assets to fetch.
     */
    where?: other_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_assets to fetch.
     */
    orderBy?: other_assetsOrderByWithRelationInput | other_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_assets.
     */
    cursor?: other_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_assets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_assets.
     */
    distinct?: Other_assetsScalarFieldEnum | Other_assetsScalarFieldEnum[]
  }

  /**
   * other_assets findMany
   */
  export type other_assetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter, which other_assets to fetch.
     */
    where?: other_assetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_assets to fetch.
     */
    orderBy?: other_assetsOrderByWithRelationInput | other_assetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing other_assets.
     */
    cursor?: other_assetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_assets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_assets.
     */
    skip?: number
    distinct?: Other_assetsScalarFieldEnum | Other_assetsScalarFieldEnum[]
  }

  /**
   * other_assets create
   */
  export type other_assetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * The data needed to create a other_assets.
     */
    data: XOR<other_assetsCreateInput, other_assetsUncheckedCreateInput>
  }

  /**
   * other_assets createMany
   */
  export type other_assetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many other_assets.
     */
    data: other_assetsCreateManyInput | other_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_assets createManyAndReturn
   */
  export type other_assetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * The data used to create many other_assets.
     */
    data: other_assetsCreateManyInput | other_assetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_assets update
   */
  export type other_assetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * The data needed to update a other_assets.
     */
    data: XOR<other_assetsUpdateInput, other_assetsUncheckedUpdateInput>
    /**
     * Choose, which other_assets to update.
     */
    where: other_assetsWhereUniqueInput
  }

  /**
   * other_assets updateMany
   */
  export type other_assetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update other_assets.
     */
    data: XOR<other_assetsUpdateManyMutationInput, other_assetsUncheckedUpdateManyInput>
    /**
     * Filter which other_assets to update
     */
    where?: other_assetsWhereInput
    /**
     * Limit how many other_assets to update.
     */
    limit?: number
  }

  /**
   * other_assets updateManyAndReturn
   */
  export type other_assetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * The data used to update other_assets.
     */
    data: XOR<other_assetsUpdateManyMutationInput, other_assetsUncheckedUpdateManyInput>
    /**
     * Filter which other_assets to update
     */
    where?: other_assetsWhereInput
    /**
     * Limit how many other_assets to update.
     */
    limit?: number
  }

  /**
   * other_assets upsert
   */
  export type other_assetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * The filter to search for the other_assets to update in case it exists.
     */
    where: other_assetsWhereUniqueInput
    /**
     * In case the other_assets found by the `where` argument doesn't exist, create a new other_assets with this data.
     */
    create: XOR<other_assetsCreateInput, other_assetsUncheckedCreateInput>
    /**
     * In case the other_assets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<other_assetsUpdateInput, other_assetsUncheckedUpdateInput>
  }

  /**
   * other_assets delete
   */
  export type other_assetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
    /**
     * Filter which other_assets to delete.
     */
    where: other_assetsWhereUniqueInput
  }

  /**
   * other_assets deleteMany
   */
  export type other_assetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_assets to delete
     */
    where?: other_assetsWhereInput
    /**
     * Limit how many other_assets to delete.
     */
    limit?: number
  }

  /**
   * other_assets without action
   */
  export type other_assetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_assets
     */
    select?: other_assetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_assets
     */
    omit?: other_assetsOmit<ExtArgs> | null
  }


  /**
   * Model other_liabilities
   */

  export type AggregateOther_liabilities = {
    _count: Other_liabilitiesCountAggregateOutputType | null
    _min: Other_liabilitiesMinAggregateOutputType | null
    _max: Other_liabilitiesMaxAggregateOutputType | null
  }

  export type Other_liabilitiesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Other_liabilitiesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Other_liabilitiesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type Other_liabilitiesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type Other_liabilitiesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type Other_liabilitiesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type Other_liabilitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_liabilities to aggregate.
     */
    where?: other_liabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_liabilities to fetch.
     */
    orderBy?: other_liabilitiesOrderByWithRelationInput | other_liabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: other_liabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned other_liabilities
    **/
    _count?: true | Other_liabilitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Other_liabilitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Other_liabilitiesMaxAggregateInputType
  }

  export type GetOther_liabilitiesAggregateType<T extends Other_liabilitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateOther_liabilities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOther_liabilities[P]>
      : GetScalarType<T[P], AggregateOther_liabilities[P]>
  }




  export type other_liabilitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: other_liabilitiesWhereInput
    orderBy?: other_liabilitiesOrderByWithAggregationInput | other_liabilitiesOrderByWithAggregationInput[]
    by: Other_liabilitiesScalarFieldEnum[] | Other_liabilitiesScalarFieldEnum
    having?: other_liabilitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Other_liabilitiesCountAggregateInputType | true
    _min?: Other_liabilitiesMinAggregateInputType
    _max?: Other_liabilitiesMaxAggregateInputType
  }

  export type Other_liabilitiesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: Other_liabilitiesCountAggregateOutputType | null
    _min: Other_liabilitiesMinAggregateOutputType | null
    _max: Other_liabilitiesMaxAggregateOutputType | null
  }

  type GetOther_liabilitiesGroupByPayload<T extends other_liabilitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Other_liabilitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Other_liabilitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Other_liabilitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Other_liabilitiesGroupByOutputType[P]>
        }
      >
    >


  export type other_liabilitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_liabilities"]>

  export type other_liabilitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_liabilities"]>

  export type other_liabilitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["other_liabilities"]>

  export type other_liabilitiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type other_liabilitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["other_liabilities"]>

  export type $other_liabilitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "other_liabilities"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["other_liabilities"]>
    composites: {}
  }

  type other_liabilitiesGetPayload<S extends boolean | null | undefined | other_liabilitiesDefaultArgs> = $Result.GetResult<Prisma.$other_liabilitiesPayload, S>

  type other_liabilitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<other_liabilitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Other_liabilitiesCountAggregateInputType | true
    }

  export interface other_liabilitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['other_liabilities'], meta: { name: 'other_liabilities' } }
    /**
     * Find zero or one Other_liabilities that matches the filter.
     * @param {other_liabilitiesFindUniqueArgs} args - Arguments to find a Other_liabilities
     * @example
     * // Get one Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends other_liabilitiesFindUniqueArgs>(args: SelectSubset<T, other_liabilitiesFindUniqueArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Other_liabilities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {other_liabilitiesFindUniqueOrThrowArgs} args - Arguments to find a Other_liabilities
     * @example
     * // Get one Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends other_liabilitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, other_liabilitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_liabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesFindFirstArgs} args - Arguments to find a Other_liabilities
     * @example
     * // Get one Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends other_liabilitiesFindFirstArgs>(args?: SelectSubset<T, other_liabilitiesFindFirstArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Other_liabilities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesFindFirstOrThrowArgs} args - Arguments to find a Other_liabilities
     * @example
     * // Get one Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends other_liabilitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, other_liabilitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Other_liabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findMany()
     * 
     * // Get first 10 Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const other_liabilitiesWithIdOnly = await prisma.other_liabilities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends other_liabilitiesFindManyArgs>(args?: SelectSubset<T, other_liabilitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Other_liabilities.
     * @param {other_liabilitiesCreateArgs} args - Arguments to create a Other_liabilities.
     * @example
     * // Create one Other_liabilities
     * const Other_liabilities = await prisma.other_liabilities.create({
     *   data: {
     *     // ... data to create a Other_liabilities
     *   }
     * })
     * 
     */
    create<T extends other_liabilitiesCreateArgs>(args: SelectSubset<T, other_liabilitiesCreateArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Other_liabilities.
     * @param {other_liabilitiesCreateManyArgs} args - Arguments to create many Other_liabilities.
     * @example
     * // Create many Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends other_liabilitiesCreateManyArgs>(args?: SelectSubset<T, other_liabilitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Other_liabilities and returns the data saved in the database.
     * @param {other_liabilitiesCreateManyAndReturnArgs} args - Arguments to create many Other_liabilities.
     * @example
     * // Create many Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Other_liabilities and only return the `id`
     * const other_liabilitiesWithIdOnly = await prisma.other_liabilities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends other_liabilitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, other_liabilitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Other_liabilities.
     * @param {other_liabilitiesDeleteArgs} args - Arguments to delete one Other_liabilities.
     * @example
     * // Delete one Other_liabilities
     * const Other_liabilities = await prisma.other_liabilities.delete({
     *   where: {
     *     // ... filter to delete one Other_liabilities
     *   }
     * })
     * 
     */
    delete<T extends other_liabilitiesDeleteArgs>(args: SelectSubset<T, other_liabilitiesDeleteArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Other_liabilities.
     * @param {other_liabilitiesUpdateArgs} args - Arguments to update one Other_liabilities.
     * @example
     * // Update one Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends other_liabilitiesUpdateArgs>(args: SelectSubset<T, other_liabilitiesUpdateArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Other_liabilities.
     * @param {other_liabilitiesDeleteManyArgs} args - Arguments to filter Other_liabilities to delete.
     * @example
     * // Delete a few Other_liabilities
     * const { count } = await prisma.other_liabilities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends other_liabilitiesDeleteManyArgs>(args?: SelectSubset<T, other_liabilitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends other_liabilitiesUpdateManyArgs>(args: SelectSubset<T, other_liabilitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Other_liabilities and returns the data updated in the database.
     * @param {other_liabilitiesUpdateManyAndReturnArgs} args - Arguments to update many Other_liabilities.
     * @example
     * // Update many Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Other_liabilities and only return the `id`
     * const other_liabilitiesWithIdOnly = await prisma.other_liabilities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends other_liabilitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, other_liabilitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Other_liabilities.
     * @param {other_liabilitiesUpsertArgs} args - Arguments to update or create a Other_liabilities.
     * @example
     * // Update or create a Other_liabilities
     * const other_liabilities = await prisma.other_liabilities.upsert({
     *   create: {
     *     // ... data to create a Other_liabilities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Other_liabilities we want to update
     *   }
     * })
     */
    upsert<T extends other_liabilitiesUpsertArgs>(args: SelectSubset<T, other_liabilitiesUpsertArgs<ExtArgs>>): Prisma__other_liabilitiesClient<$Result.GetResult<Prisma.$other_liabilitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Other_liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesCountArgs} args - Arguments to filter Other_liabilities to count.
     * @example
     * // Count the number of Other_liabilities
     * const count = await prisma.other_liabilities.count({
     *   where: {
     *     // ... the filter for the Other_liabilities we want to count
     *   }
     * })
    **/
    count<T extends other_liabilitiesCountArgs>(
      args?: Subset<T, other_liabilitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Other_liabilitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Other_liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Other_liabilitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Other_liabilitiesAggregateArgs>(args: Subset<T, Other_liabilitiesAggregateArgs>): Prisma.PrismaPromise<GetOther_liabilitiesAggregateType<T>>

    /**
     * Group by Other_liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {other_liabilitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends other_liabilitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: other_liabilitiesGroupByArgs['orderBy'] }
        : { orderBy?: other_liabilitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, other_liabilitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOther_liabilitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the other_liabilities model
   */
  readonly fields: other_liabilitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for other_liabilities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__other_liabilitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the other_liabilities model
   */
  interface other_liabilitiesFieldRefs {
    readonly id: FieldRef<"other_liabilities", 'String'>
    readonly created_at: FieldRef<"other_liabilities", 'DateTime'>
    readonly updated_at: FieldRef<"other_liabilities", 'DateTime'>
    readonly locked_attributes: FieldRef<"other_liabilities", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * other_liabilities findUnique
   */
  export type other_liabilitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter, which other_liabilities to fetch.
     */
    where: other_liabilitiesWhereUniqueInput
  }

  /**
   * other_liabilities findUniqueOrThrow
   */
  export type other_liabilitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter, which other_liabilities to fetch.
     */
    where: other_liabilitiesWhereUniqueInput
  }

  /**
   * other_liabilities findFirst
   */
  export type other_liabilitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter, which other_liabilities to fetch.
     */
    where?: other_liabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_liabilities to fetch.
     */
    orderBy?: other_liabilitiesOrderByWithRelationInput | other_liabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_liabilities.
     */
    cursor?: other_liabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_liabilities.
     */
    distinct?: Other_liabilitiesScalarFieldEnum | Other_liabilitiesScalarFieldEnum[]
  }

  /**
   * other_liabilities findFirstOrThrow
   */
  export type other_liabilitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter, which other_liabilities to fetch.
     */
    where?: other_liabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_liabilities to fetch.
     */
    orderBy?: other_liabilitiesOrderByWithRelationInput | other_liabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for other_liabilities.
     */
    cursor?: other_liabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of other_liabilities.
     */
    distinct?: Other_liabilitiesScalarFieldEnum | Other_liabilitiesScalarFieldEnum[]
  }

  /**
   * other_liabilities findMany
   */
  export type other_liabilitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter, which other_liabilities to fetch.
     */
    where?: other_liabilitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of other_liabilities to fetch.
     */
    orderBy?: other_liabilitiesOrderByWithRelationInput | other_liabilitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing other_liabilities.
     */
    cursor?: other_liabilitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` other_liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` other_liabilities.
     */
    skip?: number
    distinct?: Other_liabilitiesScalarFieldEnum | Other_liabilitiesScalarFieldEnum[]
  }

  /**
   * other_liabilities create
   */
  export type other_liabilitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * The data needed to create a other_liabilities.
     */
    data: XOR<other_liabilitiesCreateInput, other_liabilitiesUncheckedCreateInput>
  }

  /**
   * other_liabilities createMany
   */
  export type other_liabilitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many other_liabilities.
     */
    data: other_liabilitiesCreateManyInput | other_liabilitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_liabilities createManyAndReturn
   */
  export type other_liabilitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * The data used to create many other_liabilities.
     */
    data: other_liabilitiesCreateManyInput | other_liabilitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * other_liabilities update
   */
  export type other_liabilitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * The data needed to update a other_liabilities.
     */
    data: XOR<other_liabilitiesUpdateInput, other_liabilitiesUncheckedUpdateInput>
    /**
     * Choose, which other_liabilities to update.
     */
    where: other_liabilitiesWhereUniqueInput
  }

  /**
   * other_liabilities updateMany
   */
  export type other_liabilitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update other_liabilities.
     */
    data: XOR<other_liabilitiesUpdateManyMutationInput, other_liabilitiesUncheckedUpdateManyInput>
    /**
     * Filter which other_liabilities to update
     */
    where?: other_liabilitiesWhereInput
    /**
     * Limit how many other_liabilities to update.
     */
    limit?: number
  }

  /**
   * other_liabilities updateManyAndReturn
   */
  export type other_liabilitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * The data used to update other_liabilities.
     */
    data: XOR<other_liabilitiesUpdateManyMutationInput, other_liabilitiesUncheckedUpdateManyInput>
    /**
     * Filter which other_liabilities to update
     */
    where?: other_liabilitiesWhereInput
    /**
     * Limit how many other_liabilities to update.
     */
    limit?: number
  }

  /**
   * other_liabilities upsert
   */
  export type other_liabilitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * The filter to search for the other_liabilities to update in case it exists.
     */
    where: other_liabilitiesWhereUniqueInput
    /**
     * In case the other_liabilities found by the `where` argument doesn't exist, create a new other_liabilities with this data.
     */
    create: XOR<other_liabilitiesCreateInput, other_liabilitiesUncheckedCreateInput>
    /**
     * In case the other_liabilities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<other_liabilitiesUpdateInput, other_liabilitiesUncheckedUpdateInput>
  }

  /**
   * other_liabilities delete
   */
  export type other_liabilitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
    /**
     * Filter which other_liabilities to delete.
     */
    where: other_liabilitiesWhereUniqueInput
  }

  /**
   * other_liabilities deleteMany
   */
  export type other_liabilitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which other_liabilities to delete
     */
    where?: other_liabilitiesWhereInput
    /**
     * Limit how many other_liabilities to delete.
     */
    limit?: number
  }

  /**
   * other_liabilities without action
   */
  export type other_liabilitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the other_liabilities
     */
    select?: other_liabilitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the other_liabilities
     */
    omit?: other_liabilitiesOmit<ExtArgs> | null
  }


  /**
   * Model plaid_accounts
   */

  export type AggregatePlaid_accounts = {
    _count: Plaid_accountsCountAggregateOutputType | null
    _avg: Plaid_accountsAvgAggregateOutputType | null
    _sum: Plaid_accountsSumAggregateOutputType | null
    _min: Plaid_accountsMinAggregateOutputType | null
    _max: Plaid_accountsMaxAggregateOutputType | null
  }

  export type Plaid_accountsAvgAggregateOutputType = {
    current_balance: Decimal | null
    available_balance: Decimal | null
  }

  export type Plaid_accountsSumAggregateOutputType = {
    current_balance: Decimal | null
    available_balance: Decimal | null
  }

  export type Plaid_accountsMinAggregateOutputType = {
    id: string | null
    plaid_item_id: string | null
    plaid_id: string | null
    plaid_type: string | null
    plaid_subtype: string | null
    current_balance: Decimal | null
    available_balance: Decimal | null
    currency: string | null
    name: string | null
    mask: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Plaid_accountsMaxAggregateOutputType = {
    id: string | null
    plaid_item_id: string | null
    plaid_id: string | null
    plaid_type: string | null
    plaid_subtype: string | null
    current_balance: Decimal | null
    available_balance: Decimal | null
    currency: string | null
    name: string | null
    mask: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Plaid_accountsCountAggregateOutputType = {
    id: number
    plaid_item_id: number
    plaid_id: number
    plaid_type: number
    plaid_subtype: number
    current_balance: number
    available_balance: number
    currency: number
    name: number
    mask: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Plaid_accountsAvgAggregateInputType = {
    current_balance?: true
    available_balance?: true
  }

  export type Plaid_accountsSumAggregateInputType = {
    current_balance?: true
    available_balance?: true
  }

  export type Plaid_accountsMinAggregateInputType = {
    id?: true
    plaid_item_id?: true
    plaid_id?: true
    plaid_type?: true
    plaid_subtype?: true
    current_balance?: true
    available_balance?: true
    currency?: true
    name?: true
    mask?: true
    created_at?: true
    updated_at?: true
  }

  export type Plaid_accountsMaxAggregateInputType = {
    id?: true
    plaid_item_id?: true
    plaid_id?: true
    plaid_type?: true
    plaid_subtype?: true
    current_balance?: true
    available_balance?: true
    currency?: true
    name?: true
    mask?: true
    created_at?: true
    updated_at?: true
  }

  export type Plaid_accountsCountAggregateInputType = {
    id?: true
    plaid_item_id?: true
    plaid_id?: true
    plaid_type?: true
    plaid_subtype?: true
    current_balance?: true
    available_balance?: true
    currency?: true
    name?: true
    mask?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Plaid_accountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaid_accounts to aggregate.
     */
    where?: plaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_accounts to fetch.
     */
    orderBy?: plaid_accountsOrderByWithRelationInput | plaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plaid_accounts
    **/
    _count?: true | Plaid_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plaid_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plaid_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plaid_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plaid_accountsMaxAggregateInputType
  }

  export type GetPlaid_accountsAggregateType<T extends Plaid_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaid_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaid_accounts[P]>
      : GetScalarType<T[P], AggregatePlaid_accounts[P]>
  }




  export type plaid_accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plaid_accountsWhereInput
    orderBy?: plaid_accountsOrderByWithAggregationInput | plaid_accountsOrderByWithAggregationInput[]
    by: Plaid_accountsScalarFieldEnum[] | Plaid_accountsScalarFieldEnum
    having?: plaid_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plaid_accountsCountAggregateInputType | true
    _avg?: Plaid_accountsAvgAggregateInputType
    _sum?: Plaid_accountsSumAggregateInputType
    _min?: Plaid_accountsMinAggregateInputType
    _max?: Plaid_accountsMaxAggregateInputType
  }

  export type Plaid_accountsGroupByOutputType = {
    id: string
    plaid_item_id: string
    plaid_id: string | null
    plaid_type: string | null
    plaid_subtype: string | null
    current_balance: Decimal | null
    available_balance: Decimal | null
    currency: string | null
    name: string | null
    mask: string | null
    created_at: Date
    updated_at: Date
    _count: Plaid_accountsCountAggregateOutputType | null
    _avg: Plaid_accountsAvgAggregateOutputType | null
    _sum: Plaid_accountsSumAggregateOutputType | null
    _min: Plaid_accountsMinAggregateOutputType | null
    _max: Plaid_accountsMaxAggregateOutputType | null
  }

  type GetPlaid_accountsGroupByPayload<T extends plaid_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plaid_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plaid_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plaid_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Plaid_accountsGroupByOutputType[P]>
        }
      >
    >


  export type plaid_accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plaid_item_id?: boolean
    plaid_id?: boolean
    plaid_type?: boolean
    plaid_subtype?: boolean
    current_balance?: boolean
    available_balance?: boolean
    currency?: boolean
    name?: boolean
    mask?: boolean
    created_at?: boolean
    updated_at?: boolean
    accounts?: boolean | plaid_accounts$accountsArgs<ExtArgs>
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
    _count?: boolean | Plaid_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_accounts"]>

  export type plaid_accountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plaid_item_id?: boolean
    plaid_id?: boolean
    plaid_type?: boolean
    plaid_subtype?: boolean
    current_balance?: boolean
    available_balance?: boolean
    currency?: boolean
    name?: boolean
    mask?: boolean
    created_at?: boolean
    updated_at?: boolean
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_accounts"]>

  export type plaid_accountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plaid_item_id?: boolean
    plaid_id?: boolean
    plaid_type?: boolean
    plaid_subtype?: boolean
    current_balance?: boolean
    available_balance?: boolean
    currency?: boolean
    name?: boolean
    mask?: boolean
    created_at?: boolean
    updated_at?: boolean
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_accounts"]>

  export type plaid_accountsSelectScalar = {
    id?: boolean
    plaid_item_id?: boolean
    plaid_id?: boolean
    plaid_type?: boolean
    plaid_subtype?: boolean
    current_balance?: boolean
    available_balance?: boolean
    currency?: boolean
    name?: boolean
    mask?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type plaid_accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plaid_item_id" | "plaid_id" | "plaid_type" | "plaid_subtype" | "current_balance" | "available_balance" | "currency" | "name" | "mask" | "created_at" | "updated_at", ExtArgs["result"]["plaid_accounts"]>
  export type plaid_accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | plaid_accounts$accountsArgs<ExtArgs>
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
    _count?: boolean | Plaid_accountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type plaid_accountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
  }
  export type plaid_accountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plaid_items?: boolean | plaid_itemsDefaultArgs<ExtArgs>
  }

  export type $plaid_accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plaid_accounts"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      plaid_items: Prisma.$plaid_itemsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plaid_item_id: string
      plaid_id: string | null
      plaid_type: string | null
      plaid_subtype: string | null
      current_balance: Prisma.Decimal | null
      available_balance: Prisma.Decimal | null
      currency: string | null
      name: string | null
      mask: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["plaid_accounts"]>
    composites: {}
  }

  type plaid_accountsGetPayload<S extends boolean | null | undefined | plaid_accountsDefaultArgs> = $Result.GetResult<Prisma.$plaid_accountsPayload, S>

  type plaid_accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plaid_accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plaid_accountsCountAggregateInputType | true
    }

  export interface plaid_accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plaid_accounts'], meta: { name: 'plaid_accounts' } }
    /**
     * Find zero or one Plaid_accounts that matches the filter.
     * @param {plaid_accountsFindUniqueArgs} args - Arguments to find a Plaid_accounts
     * @example
     * // Get one Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plaid_accountsFindUniqueArgs>(args: SelectSubset<T, plaid_accountsFindUniqueArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plaid_accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plaid_accountsFindUniqueOrThrowArgs} args - Arguments to find a Plaid_accounts
     * @example
     * // Get one Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plaid_accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, plaid_accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaid_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsFindFirstArgs} args - Arguments to find a Plaid_accounts
     * @example
     * // Get one Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plaid_accountsFindFirstArgs>(args?: SelectSubset<T, plaid_accountsFindFirstArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaid_accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsFindFirstOrThrowArgs} args - Arguments to find a Plaid_accounts
     * @example
     * // Get one Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plaid_accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, plaid_accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plaid_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findMany()
     * 
     * // Get first 10 Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plaid_accountsWithIdOnly = await prisma.plaid_accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plaid_accountsFindManyArgs>(args?: SelectSubset<T, plaid_accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plaid_accounts.
     * @param {plaid_accountsCreateArgs} args - Arguments to create a Plaid_accounts.
     * @example
     * // Create one Plaid_accounts
     * const Plaid_accounts = await prisma.plaid_accounts.create({
     *   data: {
     *     // ... data to create a Plaid_accounts
     *   }
     * })
     * 
     */
    create<T extends plaid_accountsCreateArgs>(args: SelectSubset<T, plaid_accountsCreateArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plaid_accounts.
     * @param {plaid_accountsCreateManyArgs} args - Arguments to create many Plaid_accounts.
     * @example
     * // Create many Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plaid_accountsCreateManyArgs>(args?: SelectSubset<T, plaid_accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plaid_accounts and returns the data saved in the database.
     * @param {plaid_accountsCreateManyAndReturnArgs} args - Arguments to create many Plaid_accounts.
     * @example
     * // Create many Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plaid_accounts and only return the `id`
     * const plaid_accountsWithIdOnly = await prisma.plaid_accounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plaid_accountsCreateManyAndReturnArgs>(args?: SelectSubset<T, plaid_accountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plaid_accounts.
     * @param {plaid_accountsDeleteArgs} args - Arguments to delete one Plaid_accounts.
     * @example
     * // Delete one Plaid_accounts
     * const Plaid_accounts = await prisma.plaid_accounts.delete({
     *   where: {
     *     // ... filter to delete one Plaid_accounts
     *   }
     * })
     * 
     */
    delete<T extends plaid_accountsDeleteArgs>(args: SelectSubset<T, plaid_accountsDeleteArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plaid_accounts.
     * @param {plaid_accountsUpdateArgs} args - Arguments to update one Plaid_accounts.
     * @example
     * // Update one Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plaid_accountsUpdateArgs>(args: SelectSubset<T, plaid_accountsUpdateArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plaid_accounts.
     * @param {plaid_accountsDeleteManyArgs} args - Arguments to filter Plaid_accounts to delete.
     * @example
     * // Delete a few Plaid_accounts
     * const { count } = await prisma.plaid_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plaid_accountsDeleteManyArgs>(args?: SelectSubset<T, plaid_accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plaid_accountsUpdateManyArgs>(args: SelectSubset<T, plaid_accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plaid_accounts and returns the data updated in the database.
     * @param {plaid_accountsUpdateManyAndReturnArgs} args - Arguments to update many Plaid_accounts.
     * @example
     * // Update many Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plaid_accounts and only return the `id`
     * const plaid_accountsWithIdOnly = await prisma.plaid_accounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plaid_accountsUpdateManyAndReturnArgs>(args: SelectSubset<T, plaid_accountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plaid_accounts.
     * @param {plaid_accountsUpsertArgs} args - Arguments to update or create a Plaid_accounts.
     * @example
     * // Update or create a Plaid_accounts
     * const plaid_accounts = await prisma.plaid_accounts.upsert({
     *   create: {
     *     // ... data to create a Plaid_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plaid_accounts we want to update
     *   }
     * })
     */
    upsert<T extends plaid_accountsUpsertArgs>(args: SelectSubset<T, plaid_accountsUpsertArgs<ExtArgs>>): Prisma__plaid_accountsClient<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsCountArgs} args - Arguments to filter Plaid_accounts to count.
     * @example
     * // Count the number of Plaid_accounts
     * const count = await prisma.plaid_accounts.count({
     *   where: {
     *     // ... the filter for the Plaid_accounts we want to count
     *   }
     * })
    **/
    count<T extends plaid_accountsCountArgs>(
      args?: Subset<T, plaid_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plaid_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plaid_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plaid_accountsAggregateArgs>(args: Subset<T, Plaid_accountsAggregateArgs>): Prisma.PrismaPromise<GetPlaid_accountsAggregateType<T>>

    /**
     * Group by Plaid_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plaid_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plaid_accountsGroupByArgs['orderBy'] }
        : { orderBy?: plaid_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plaid_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaid_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plaid_accounts model
   */
  readonly fields: plaid_accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plaid_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plaid_accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends plaid_accounts$accountsArgs<ExtArgs> = {}>(args?: Subset<T, plaid_accounts$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    plaid_items<T extends plaid_itemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, plaid_itemsDefaultArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plaid_accounts model
   */
  interface plaid_accountsFieldRefs {
    readonly id: FieldRef<"plaid_accounts", 'String'>
    readonly plaid_item_id: FieldRef<"plaid_accounts", 'String'>
    readonly plaid_id: FieldRef<"plaid_accounts", 'String'>
    readonly plaid_type: FieldRef<"plaid_accounts", 'String'>
    readonly plaid_subtype: FieldRef<"plaid_accounts", 'String'>
    readonly current_balance: FieldRef<"plaid_accounts", 'Decimal'>
    readonly available_balance: FieldRef<"plaid_accounts", 'Decimal'>
    readonly currency: FieldRef<"plaid_accounts", 'String'>
    readonly name: FieldRef<"plaid_accounts", 'String'>
    readonly mask: FieldRef<"plaid_accounts", 'String'>
    readonly created_at: FieldRef<"plaid_accounts", 'DateTime'>
    readonly updated_at: FieldRef<"plaid_accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * plaid_accounts findUnique
   */
  export type plaid_accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_accounts to fetch.
     */
    where: plaid_accountsWhereUniqueInput
  }

  /**
   * plaid_accounts findUniqueOrThrow
   */
  export type plaid_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_accounts to fetch.
     */
    where: plaid_accountsWhereUniqueInput
  }

  /**
   * plaid_accounts findFirst
   */
  export type plaid_accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_accounts to fetch.
     */
    where?: plaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_accounts to fetch.
     */
    orderBy?: plaid_accountsOrderByWithRelationInput | plaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaid_accounts.
     */
    cursor?: plaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaid_accounts.
     */
    distinct?: Plaid_accountsScalarFieldEnum | Plaid_accountsScalarFieldEnum[]
  }

  /**
   * plaid_accounts findFirstOrThrow
   */
  export type plaid_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_accounts to fetch.
     */
    where?: plaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_accounts to fetch.
     */
    orderBy?: plaid_accountsOrderByWithRelationInput | plaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaid_accounts.
     */
    cursor?: plaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaid_accounts.
     */
    distinct?: Plaid_accountsScalarFieldEnum | Plaid_accountsScalarFieldEnum[]
  }

  /**
   * plaid_accounts findMany
   */
  export type plaid_accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_accounts to fetch.
     */
    where?: plaid_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_accounts to fetch.
     */
    orderBy?: plaid_accountsOrderByWithRelationInput | plaid_accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plaid_accounts.
     */
    cursor?: plaid_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_accounts.
     */
    skip?: number
    distinct?: Plaid_accountsScalarFieldEnum | Plaid_accountsScalarFieldEnum[]
  }

  /**
   * plaid_accounts create
   */
  export type plaid_accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a plaid_accounts.
     */
    data: XOR<plaid_accountsCreateInput, plaid_accountsUncheckedCreateInput>
  }

  /**
   * plaid_accounts createMany
   */
  export type plaid_accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plaid_accounts.
     */
    data: plaid_accountsCreateManyInput | plaid_accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plaid_accounts createManyAndReturn
   */
  export type plaid_accountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * The data used to create many plaid_accounts.
     */
    data: plaid_accountsCreateManyInput | plaid_accountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plaid_accounts update
   */
  export type plaid_accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a plaid_accounts.
     */
    data: XOR<plaid_accountsUpdateInput, plaid_accountsUncheckedUpdateInput>
    /**
     * Choose, which plaid_accounts to update.
     */
    where: plaid_accountsWhereUniqueInput
  }

  /**
   * plaid_accounts updateMany
   */
  export type plaid_accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plaid_accounts.
     */
    data: XOR<plaid_accountsUpdateManyMutationInput, plaid_accountsUncheckedUpdateManyInput>
    /**
     * Filter which plaid_accounts to update
     */
    where?: plaid_accountsWhereInput
    /**
     * Limit how many plaid_accounts to update.
     */
    limit?: number
  }

  /**
   * plaid_accounts updateManyAndReturn
   */
  export type plaid_accountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * The data used to update plaid_accounts.
     */
    data: XOR<plaid_accountsUpdateManyMutationInput, plaid_accountsUncheckedUpdateManyInput>
    /**
     * Filter which plaid_accounts to update
     */
    where?: plaid_accountsWhereInput
    /**
     * Limit how many plaid_accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plaid_accounts upsert
   */
  export type plaid_accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the plaid_accounts to update in case it exists.
     */
    where: plaid_accountsWhereUniqueInput
    /**
     * In case the plaid_accounts found by the `where` argument doesn't exist, create a new plaid_accounts with this data.
     */
    create: XOR<plaid_accountsCreateInput, plaid_accountsUncheckedCreateInput>
    /**
     * In case the plaid_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plaid_accountsUpdateInput, plaid_accountsUncheckedUpdateInput>
  }

  /**
   * plaid_accounts delete
   */
  export type plaid_accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    /**
     * Filter which plaid_accounts to delete.
     */
    where: plaid_accountsWhereUniqueInput
  }

  /**
   * plaid_accounts deleteMany
   */
  export type plaid_accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaid_accounts to delete
     */
    where?: plaid_accountsWhereInput
    /**
     * Limit how many plaid_accounts to delete.
     */
    limit?: number
  }

  /**
   * plaid_accounts.accounts
   */
  export type plaid_accounts$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * plaid_accounts without action
   */
  export type plaid_accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
  }


  /**
   * Model plaid_items
   */

  export type AggregatePlaid_items = {
    _count: Plaid_itemsCountAggregateOutputType | null
    _min: Plaid_itemsMinAggregateOutputType | null
    _max: Plaid_itemsMaxAggregateOutputType | null
  }

  export type Plaid_itemsMinAggregateOutputType = {
    id: string | null
    family_id: string | null
    access_token: string | null
    plaid_id: string | null
    name: string | null
    next_cursor: string | null
    scheduled_for_deletion: boolean | null
    created_at: Date | null
    updated_at: Date | null
    last_synced_at: Date | null
    plaid_region: string | null
    institution_url: string | null
    institution_id: string | null
    institution_color: string | null
    status: string | null
  }

  export type Plaid_itemsMaxAggregateOutputType = {
    id: string | null
    family_id: string | null
    access_token: string | null
    plaid_id: string | null
    name: string | null
    next_cursor: string | null
    scheduled_for_deletion: boolean | null
    created_at: Date | null
    updated_at: Date | null
    last_synced_at: Date | null
    plaid_region: string | null
    institution_url: string | null
    institution_id: string | null
    institution_color: string | null
    status: string | null
  }

  export type Plaid_itemsCountAggregateOutputType = {
    id: number
    family_id: number
    access_token: number
    plaid_id: number
    name: number
    next_cursor: number
    scheduled_for_deletion: number
    created_at: number
    updated_at: number
    available_products: number
    billed_products: number
    last_synced_at: number
    plaid_region: number
    institution_url: number
    institution_id: number
    institution_color: number
    status: number
    _all: number
  }


  export type Plaid_itemsMinAggregateInputType = {
    id?: true
    family_id?: true
    access_token?: true
    plaid_id?: true
    name?: true
    next_cursor?: true
    scheduled_for_deletion?: true
    created_at?: true
    updated_at?: true
    last_synced_at?: true
    plaid_region?: true
    institution_url?: true
    institution_id?: true
    institution_color?: true
    status?: true
  }

  export type Plaid_itemsMaxAggregateInputType = {
    id?: true
    family_id?: true
    access_token?: true
    plaid_id?: true
    name?: true
    next_cursor?: true
    scheduled_for_deletion?: true
    created_at?: true
    updated_at?: true
    last_synced_at?: true
    plaid_region?: true
    institution_url?: true
    institution_id?: true
    institution_color?: true
    status?: true
  }

  export type Plaid_itemsCountAggregateInputType = {
    id?: true
    family_id?: true
    access_token?: true
    plaid_id?: true
    name?: true
    next_cursor?: true
    scheduled_for_deletion?: true
    created_at?: true
    updated_at?: true
    available_products?: true
    billed_products?: true
    last_synced_at?: true
    plaid_region?: true
    institution_url?: true
    institution_id?: true
    institution_color?: true
    status?: true
    _all?: true
  }

  export type Plaid_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaid_items to aggregate.
     */
    where?: plaid_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_items to fetch.
     */
    orderBy?: plaid_itemsOrderByWithRelationInput | plaid_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plaid_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plaid_items
    **/
    _count?: true | Plaid_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plaid_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plaid_itemsMaxAggregateInputType
  }

  export type GetPlaid_itemsAggregateType<T extends Plaid_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaid_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaid_items[P]>
      : GetScalarType<T[P], AggregatePlaid_items[P]>
  }




  export type plaid_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plaid_itemsWhereInput
    orderBy?: plaid_itemsOrderByWithAggregationInput | plaid_itemsOrderByWithAggregationInput[]
    by: Plaid_itemsScalarFieldEnum[] | Plaid_itemsScalarFieldEnum
    having?: plaid_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plaid_itemsCountAggregateInputType | true
    _min?: Plaid_itemsMinAggregateInputType
    _max?: Plaid_itemsMaxAggregateInputType
  }

  export type Plaid_itemsGroupByOutputType = {
    id: string
    family_id: string
    access_token: string | null
    plaid_id: string | null
    name: string | null
    next_cursor: string | null
    scheduled_for_deletion: boolean | null
    created_at: Date
    updated_at: Date
    available_products: string[]
    billed_products: string[]
    last_synced_at: Date | null
    plaid_region: string
    institution_url: string | null
    institution_id: string | null
    institution_color: string | null
    status: string
    _count: Plaid_itemsCountAggregateOutputType | null
    _min: Plaid_itemsMinAggregateOutputType | null
    _max: Plaid_itemsMaxAggregateOutputType | null
  }

  type GetPlaid_itemsGroupByPayload<T extends plaid_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Plaid_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plaid_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plaid_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Plaid_itemsGroupByOutputType[P]>
        }
      >
    >


  export type plaid_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    access_token?: boolean
    plaid_id?: boolean
    name?: boolean
    next_cursor?: boolean
    scheduled_for_deletion?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_products?: boolean
    billed_products?: boolean
    last_synced_at?: boolean
    plaid_region?: boolean
    institution_url?: boolean
    institution_id?: boolean
    institution_color?: boolean
    status?: boolean
    plaid_accounts?: boolean | plaid_items$plaid_accountsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | Plaid_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_items"]>

  export type plaid_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    access_token?: boolean
    plaid_id?: boolean
    name?: boolean
    next_cursor?: boolean
    scheduled_for_deletion?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_products?: boolean
    billed_products?: boolean
    last_synced_at?: boolean
    plaid_region?: boolean
    institution_url?: boolean
    institution_id?: boolean
    institution_color?: boolean
    status?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_items"]>

  export type plaid_itemsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    access_token?: boolean
    plaid_id?: boolean
    name?: boolean
    next_cursor?: boolean
    scheduled_for_deletion?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_products?: boolean
    billed_products?: boolean
    last_synced_at?: boolean
    plaid_region?: boolean
    institution_url?: boolean
    institution_id?: boolean
    institution_color?: boolean
    status?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plaid_items"]>

  export type plaid_itemsSelectScalar = {
    id?: boolean
    family_id?: boolean
    access_token?: boolean
    plaid_id?: boolean
    name?: boolean
    next_cursor?: boolean
    scheduled_for_deletion?: boolean
    created_at?: boolean
    updated_at?: boolean
    available_products?: boolean
    billed_products?: boolean
    last_synced_at?: boolean
    plaid_region?: boolean
    institution_url?: boolean
    institution_id?: boolean
    institution_color?: boolean
    status?: boolean
  }

  export type plaid_itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "family_id" | "access_token" | "plaid_id" | "name" | "next_cursor" | "scheduled_for_deletion" | "created_at" | "updated_at" | "available_products" | "billed_products" | "last_synced_at" | "plaid_region" | "institution_url" | "institution_id" | "institution_color" | "status", ExtArgs["result"]["plaid_items"]>
  export type plaid_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plaid_accounts?: boolean | plaid_items$plaid_accountsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | Plaid_itemsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type plaid_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type plaid_itemsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $plaid_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plaid_items"
    objects: {
      plaid_accounts: Prisma.$plaid_accountsPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      family_id: string
      access_token: string | null
      plaid_id: string | null
      name: string | null
      next_cursor: string | null
      scheduled_for_deletion: boolean | null
      created_at: Date
      updated_at: Date
      available_products: string[]
      billed_products: string[]
      last_synced_at: Date | null
      plaid_region: string
      institution_url: string | null
      institution_id: string | null
      institution_color: string | null
      status: string
    }, ExtArgs["result"]["plaid_items"]>
    composites: {}
  }

  type plaid_itemsGetPayload<S extends boolean | null | undefined | plaid_itemsDefaultArgs> = $Result.GetResult<Prisma.$plaid_itemsPayload, S>

  type plaid_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plaid_itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Plaid_itemsCountAggregateInputType | true
    }

  export interface plaid_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plaid_items'], meta: { name: 'plaid_items' } }
    /**
     * Find zero or one Plaid_items that matches the filter.
     * @param {plaid_itemsFindUniqueArgs} args - Arguments to find a Plaid_items
     * @example
     * // Get one Plaid_items
     * const plaid_items = await prisma.plaid_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plaid_itemsFindUniqueArgs>(args: SelectSubset<T, plaid_itemsFindUniqueArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plaid_items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plaid_itemsFindUniqueOrThrowArgs} args - Arguments to find a Plaid_items
     * @example
     * // Get one Plaid_items
     * const plaid_items = await prisma.plaid_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plaid_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, plaid_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaid_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsFindFirstArgs} args - Arguments to find a Plaid_items
     * @example
     * // Get one Plaid_items
     * const plaid_items = await prisma.plaid_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plaid_itemsFindFirstArgs>(args?: SelectSubset<T, plaid_itemsFindFirstArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plaid_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsFindFirstOrThrowArgs} args - Arguments to find a Plaid_items
     * @example
     * // Get one Plaid_items
     * const plaid_items = await prisma.plaid_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plaid_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, plaid_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plaid_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plaid_items
     * const plaid_items = await prisma.plaid_items.findMany()
     * 
     * // Get first 10 Plaid_items
     * const plaid_items = await prisma.plaid_items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plaid_itemsWithIdOnly = await prisma.plaid_items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plaid_itemsFindManyArgs>(args?: SelectSubset<T, plaid_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plaid_items.
     * @param {plaid_itemsCreateArgs} args - Arguments to create a Plaid_items.
     * @example
     * // Create one Plaid_items
     * const Plaid_items = await prisma.plaid_items.create({
     *   data: {
     *     // ... data to create a Plaid_items
     *   }
     * })
     * 
     */
    create<T extends plaid_itemsCreateArgs>(args: SelectSubset<T, plaid_itemsCreateArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plaid_items.
     * @param {plaid_itemsCreateManyArgs} args - Arguments to create many Plaid_items.
     * @example
     * // Create many Plaid_items
     * const plaid_items = await prisma.plaid_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plaid_itemsCreateManyArgs>(args?: SelectSubset<T, plaid_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plaid_items and returns the data saved in the database.
     * @param {plaid_itemsCreateManyAndReturnArgs} args - Arguments to create many Plaid_items.
     * @example
     * // Create many Plaid_items
     * const plaid_items = await prisma.plaid_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plaid_items and only return the `id`
     * const plaid_itemsWithIdOnly = await prisma.plaid_items.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plaid_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, plaid_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plaid_items.
     * @param {plaid_itemsDeleteArgs} args - Arguments to delete one Plaid_items.
     * @example
     * // Delete one Plaid_items
     * const Plaid_items = await prisma.plaid_items.delete({
     *   where: {
     *     // ... filter to delete one Plaid_items
     *   }
     * })
     * 
     */
    delete<T extends plaid_itemsDeleteArgs>(args: SelectSubset<T, plaid_itemsDeleteArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plaid_items.
     * @param {plaid_itemsUpdateArgs} args - Arguments to update one Plaid_items.
     * @example
     * // Update one Plaid_items
     * const plaid_items = await prisma.plaid_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plaid_itemsUpdateArgs>(args: SelectSubset<T, plaid_itemsUpdateArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plaid_items.
     * @param {plaid_itemsDeleteManyArgs} args - Arguments to filter Plaid_items to delete.
     * @example
     * // Delete a few Plaid_items
     * const { count } = await prisma.plaid_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plaid_itemsDeleteManyArgs>(args?: SelectSubset<T, plaid_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plaid_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plaid_items
     * const plaid_items = await prisma.plaid_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plaid_itemsUpdateManyArgs>(args: SelectSubset<T, plaid_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plaid_items and returns the data updated in the database.
     * @param {plaid_itemsUpdateManyAndReturnArgs} args - Arguments to update many Plaid_items.
     * @example
     * // Update many Plaid_items
     * const plaid_items = await prisma.plaid_items.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plaid_items and only return the `id`
     * const plaid_itemsWithIdOnly = await prisma.plaid_items.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plaid_itemsUpdateManyAndReturnArgs>(args: SelectSubset<T, plaid_itemsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plaid_items.
     * @param {plaid_itemsUpsertArgs} args - Arguments to update or create a Plaid_items.
     * @example
     * // Update or create a Plaid_items
     * const plaid_items = await prisma.plaid_items.upsert({
     *   create: {
     *     // ... data to create a Plaid_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plaid_items we want to update
     *   }
     * })
     */
    upsert<T extends plaid_itemsUpsertArgs>(args: SelectSubset<T, plaid_itemsUpsertArgs<ExtArgs>>): Prisma__plaid_itemsClient<$Result.GetResult<Prisma.$plaid_itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plaid_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsCountArgs} args - Arguments to filter Plaid_items to count.
     * @example
     * // Count the number of Plaid_items
     * const count = await prisma.plaid_items.count({
     *   where: {
     *     // ... the filter for the Plaid_items we want to count
     *   }
     * })
    **/
    count<T extends plaid_itemsCountArgs>(
      args?: Subset<T, plaid_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plaid_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plaid_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plaid_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plaid_itemsAggregateArgs>(args: Subset<T, Plaid_itemsAggregateArgs>): Prisma.PrismaPromise<GetPlaid_itemsAggregateType<T>>

    /**
     * Group by Plaid_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plaid_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plaid_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plaid_itemsGroupByArgs['orderBy'] }
        : { orderBy?: plaid_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plaid_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaid_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plaid_items model
   */
  readonly fields: plaid_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plaid_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plaid_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plaid_accounts<T extends plaid_items$plaid_accountsArgs<ExtArgs> = {}>(args?: Subset<T, plaid_items$plaid_accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plaid_accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plaid_items model
   */
  interface plaid_itemsFieldRefs {
    readonly id: FieldRef<"plaid_items", 'String'>
    readonly family_id: FieldRef<"plaid_items", 'String'>
    readonly access_token: FieldRef<"plaid_items", 'String'>
    readonly plaid_id: FieldRef<"plaid_items", 'String'>
    readonly name: FieldRef<"plaid_items", 'String'>
    readonly next_cursor: FieldRef<"plaid_items", 'String'>
    readonly scheduled_for_deletion: FieldRef<"plaid_items", 'Boolean'>
    readonly created_at: FieldRef<"plaid_items", 'DateTime'>
    readonly updated_at: FieldRef<"plaid_items", 'DateTime'>
    readonly available_products: FieldRef<"plaid_items", 'String[]'>
    readonly billed_products: FieldRef<"plaid_items", 'String[]'>
    readonly last_synced_at: FieldRef<"plaid_items", 'DateTime'>
    readonly plaid_region: FieldRef<"plaid_items", 'String'>
    readonly institution_url: FieldRef<"plaid_items", 'String'>
    readonly institution_id: FieldRef<"plaid_items", 'String'>
    readonly institution_color: FieldRef<"plaid_items", 'String'>
    readonly status: FieldRef<"plaid_items", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plaid_items findUnique
   */
  export type plaid_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_items to fetch.
     */
    where: plaid_itemsWhereUniqueInput
  }

  /**
   * plaid_items findUniqueOrThrow
   */
  export type plaid_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_items to fetch.
     */
    where: plaid_itemsWhereUniqueInput
  }

  /**
   * plaid_items findFirst
   */
  export type plaid_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_items to fetch.
     */
    where?: plaid_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_items to fetch.
     */
    orderBy?: plaid_itemsOrderByWithRelationInput | plaid_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaid_items.
     */
    cursor?: plaid_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaid_items.
     */
    distinct?: Plaid_itemsScalarFieldEnum | Plaid_itemsScalarFieldEnum[]
  }

  /**
   * plaid_items findFirstOrThrow
   */
  export type plaid_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_items to fetch.
     */
    where?: plaid_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_items to fetch.
     */
    orderBy?: plaid_itemsOrderByWithRelationInput | plaid_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plaid_items.
     */
    cursor?: plaid_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plaid_items.
     */
    distinct?: Plaid_itemsScalarFieldEnum | Plaid_itemsScalarFieldEnum[]
  }

  /**
   * plaid_items findMany
   */
  export type plaid_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter, which plaid_items to fetch.
     */
    where?: plaid_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plaid_items to fetch.
     */
    orderBy?: plaid_itemsOrderByWithRelationInput | plaid_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plaid_items.
     */
    cursor?: plaid_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plaid_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plaid_items.
     */
    skip?: number
    distinct?: Plaid_itemsScalarFieldEnum | Plaid_itemsScalarFieldEnum[]
  }

  /**
   * plaid_items create
   */
  export type plaid_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a plaid_items.
     */
    data: XOR<plaid_itemsCreateInput, plaid_itemsUncheckedCreateInput>
  }

  /**
   * plaid_items createMany
   */
  export type plaid_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plaid_items.
     */
    data: plaid_itemsCreateManyInput | plaid_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plaid_items createManyAndReturn
   */
  export type plaid_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * The data used to create many plaid_items.
     */
    data: plaid_itemsCreateManyInput | plaid_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * plaid_items update
   */
  export type plaid_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a plaid_items.
     */
    data: XOR<plaid_itemsUpdateInput, plaid_itemsUncheckedUpdateInput>
    /**
     * Choose, which plaid_items to update.
     */
    where: plaid_itemsWhereUniqueInput
  }

  /**
   * plaid_items updateMany
   */
  export type plaid_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plaid_items.
     */
    data: XOR<plaid_itemsUpdateManyMutationInput, plaid_itemsUncheckedUpdateManyInput>
    /**
     * Filter which plaid_items to update
     */
    where?: plaid_itemsWhereInput
    /**
     * Limit how many plaid_items to update.
     */
    limit?: number
  }

  /**
   * plaid_items updateManyAndReturn
   */
  export type plaid_itemsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * The data used to update plaid_items.
     */
    data: XOR<plaid_itemsUpdateManyMutationInput, plaid_itemsUncheckedUpdateManyInput>
    /**
     * Filter which plaid_items to update
     */
    where?: plaid_itemsWhereInput
    /**
     * Limit how many plaid_items to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * plaid_items upsert
   */
  export type plaid_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the plaid_items to update in case it exists.
     */
    where: plaid_itemsWhereUniqueInput
    /**
     * In case the plaid_items found by the `where` argument doesn't exist, create a new plaid_items with this data.
     */
    create: XOR<plaid_itemsCreateInput, plaid_itemsUncheckedCreateInput>
    /**
     * In case the plaid_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plaid_itemsUpdateInput, plaid_itemsUncheckedUpdateInput>
  }

  /**
   * plaid_items delete
   */
  export type plaid_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
    /**
     * Filter which plaid_items to delete.
     */
    where: plaid_itemsWhereUniqueInput
  }

  /**
   * plaid_items deleteMany
   */
  export type plaid_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plaid_items to delete
     */
    where?: plaid_itemsWhereInput
    /**
     * Limit how many plaid_items to delete.
     */
    limit?: number
  }

  /**
   * plaid_items.plaid_accounts
   */
  export type plaid_items$plaid_accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_accounts
     */
    select?: plaid_accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_accounts
     */
    omit?: plaid_accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_accountsInclude<ExtArgs> | null
    where?: plaid_accountsWhereInput
    orderBy?: plaid_accountsOrderByWithRelationInput | plaid_accountsOrderByWithRelationInput[]
    cursor?: plaid_accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Plaid_accountsScalarFieldEnum | Plaid_accountsScalarFieldEnum[]
  }

  /**
   * plaid_items without action
   */
  export type plaid_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plaid_items
     */
    select?: plaid_itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plaid_items
     */
    omit?: plaid_itemsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plaid_itemsInclude<ExtArgs> | null
  }


  /**
   * Model properties
   */

  export type AggregateProperties = {
    _count: PropertiesCountAggregateOutputType | null
    _avg: PropertiesAvgAggregateOutputType | null
    _sum: PropertiesSumAggregateOutputType | null
    _min: PropertiesMinAggregateOutputType | null
    _max: PropertiesMaxAggregateOutputType | null
  }

  export type PropertiesAvgAggregateOutputType = {
    year_built: number | null
    area_value: number | null
  }

  export type PropertiesSumAggregateOutputType = {
    year_built: number | null
    area_value: number | null
  }

  export type PropertiesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    year_built: number | null
    area_value: number | null
    area_unit: string | null
  }

  export type PropertiesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    year_built: number | null
    area_value: number | null
    area_unit: string | null
  }

  export type PropertiesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    year_built: number
    area_value: number
    area_unit: number
    locked_attributes: number
    _all: number
  }


  export type PropertiesAvgAggregateInputType = {
    year_built?: true
    area_value?: true
  }

  export type PropertiesSumAggregateInputType = {
    year_built?: true
    area_value?: true
  }

  export type PropertiesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year_built?: true
    area_value?: true
    area_unit?: true
  }

  export type PropertiesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year_built?: true
    area_value?: true
    area_unit?: true
  }

  export type PropertiesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year_built?: true
    area_value?: true
    area_unit?: true
    locked_attributes?: true
    _all?: true
  }

  export type PropertiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which properties to aggregate.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned properties
    **/
    _count?: true | PropertiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertiesMaxAggregateInputType
  }

  export type GetPropertiesAggregateType<T extends PropertiesAggregateArgs> = {
        [P in keyof T & keyof AggregateProperties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperties[P]>
      : GetScalarType<T[P], AggregateProperties[P]>
  }




  export type propertiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: propertiesWhereInput
    orderBy?: propertiesOrderByWithAggregationInput | propertiesOrderByWithAggregationInput[]
    by: PropertiesScalarFieldEnum[] | PropertiesScalarFieldEnum
    having?: propertiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertiesCountAggregateInputType | true
    _avg?: PropertiesAvgAggregateInputType
    _sum?: PropertiesSumAggregateInputType
    _min?: PropertiesMinAggregateInputType
    _max?: PropertiesMaxAggregateInputType
  }

  export type PropertiesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    year_built: number | null
    area_value: number | null
    area_unit: string | null
    locked_attributes: JsonValue | null
    _count: PropertiesCountAggregateOutputType | null
    _avg: PropertiesAvgAggregateOutputType | null
    _sum: PropertiesSumAggregateOutputType | null
    _min: PropertiesMinAggregateOutputType | null
    _max: PropertiesMaxAggregateOutputType | null
  }

  type GetPropertiesGroupByPayload<T extends propertiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertiesGroupByOutputType[P]>
            : GetScalarType<T[P], PropertiesGroupByOutputType[P]>
        }
      >
    >


  export type propertiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year_built?: boolean
    area_value?: boolean
    area_unit?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["properties"]>

  export type propertiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year_built?: boolean
    area_value?: boolean
    area_unit?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["properties"]>

  export type propertiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year_built?: boolean
    area_value?: boolean
    area_unit?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["properties"]>

  export type propertiesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year_built?: boolean
    area_value?: boolean
    area_unit?: boolean
    locked_attributes?: boolean
  }

  export type propertiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "year_built" | "area_value" | "area_unit" | "locked_attributes", ExtArgs["result"]["properties"]>

  export type $propertiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "properties"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      year_built: number | null
      area_value: number | null
      area_unit: string | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["properties"]>
    composites: {}
  }

  type propertiesGetPayload<S extends boolean | null | undefined | propertiesDefaultArgs> = $Result.GetResult<Prisma.$propertiesPayload, S>

  type propertiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<propertiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertiesCountAggregateInputType | true
    }

  export interface propertiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['properties'], meta: { name: 'properties' } }
    /**
     * Find zero or one Properties that matches the filter.
     * @param {propertiesFindUniqueArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends propertiesFindUniqueArgs>(args: SelectSubset<T, propertiesFindUniqueArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Properties that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {propertiesFindUniqueOrThrowArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends propertiesFindUniqueOrThrowArgs>(args: SelectSubset<T, propertiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindFirstArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends propertiesFindFirstArgs>(args?: SelectSubset<T, propertiesFindFirstArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Properties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindFirstOrThrowArgs} args - Arguments to find a Properties
     * @example
     * // Get one Properties
     * const properties = await prisma.properties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends propertiesFindFirstOrThrowArgs>(args?: SelectSubset<T, propertiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.properties.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.properties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertiesWithIdOnly = await prisma.properties.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends propertiesFindManyArgs>(args?: SelectSubset<T, propertiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Properties.
     * @param {propertiesCreateArgs} args - Arguments to create a Properties.
     * @example
     * // Create one Properties
     * const Properties = await prisma.properties.create({
     *   data: {
     *     // ... data to create a Properties
     *   }
     * })
     * 
     */
    create<T extends propertiesCreateArgs>(args: SelectSubset<T, propertiesCreateArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {propertiesCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const properties = await prisma.properties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends propertiesCreateManyArgs>(args?: SelectSubset<T, propertiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {propertiesCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const properties = await prisma.properties.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertiesWithIdOnly = await prisma.properties.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends propertiesCreateManyAndReturnArgs>(args?: SelectSubset<T, propertiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Properties.
     * @param {propertiesDeleteArgs} args - Arguments to delete one Properties.
     * @example
     * // Delete one Properties
     * const Properties = await prisma.properties.delete({
     *   where: {
     *     // ... filter to delete one Properties
     *   }
     * })
     * 
     */
    delete<T extends propertiesDeleteArgs>(args: SelectSubset<T, propertiesDeleteArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Properties.
     * @param {propertiesUpdateArgs} args - Arguments to update one Properties.
     * @example
     * // Update one Properties
     * const properties = await prisma.properties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends propertiesUpdateArgs>(args: SelectSubset<T, propertiesUpdateArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {propertiesDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.properties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends propertiesDeleteManyArgs>(args?: SelectSubset<T, propertiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const properties = await prisma.properties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends propertiesUpdateManyArgs>(args: SelectSubset<T, propertiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {propertiesUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const properties = await prisma.properties.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertiesWithIdOnly = await prisma.properties.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends propertiesUpdateManyAndReturnArgs>(args: SelectSubset<T, propertiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Properties.
     * @param {propertiesUpsertArgs} args - Arguments to update or create a Properties.
     * @example
     * // Update or create a Properties
     * const properties = await prisma.properties.upsert({
     *   create: {
     *     // ... data to create a Properties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Properties we want to update
     *   }
     * })
     */
    upsert<T extends propertiesUpsertArgs>(args: SelectSubset<T, propertiesUpsertArgs<ExtArgs>>): Prisma__propertiesClient<$Result.GetResult<Prisma.$propertiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.properties.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends propertiesCountArgs>(
      args?: Subset<T, propertiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertiesAggregateArgs>(args: Subset<T, PropertiesAggregateArgs>): Prisma.PrismaPromise<GetPropertiesAggregateType<T>>

    /**
     * Group by Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {propertiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends propertiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: propertiesGroupByArgs['orderBy'] }
        : { orderBy?: propertiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, propertiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the properties model
   */
  readonly fields: propertiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for properties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__propertiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the properties model
   */
  interface propertiesFieldRefs {
    readonly id: FieldRef<"properties", 'String'>
    readonly created_at: FieldRef<"properties", 'DateTime'>
    readonly updated_at: FieldRef<"properties", 'DateTime'>
    readonly year_built: FieldRef<"properties", 'Int'>
    readonly area_value: FieldRef<"properties", 'Int'>
    readonly area_unit: FieldRef<"properties", 'String'>
    readonly locked_attributes: FieldRef<"properties", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * properties findUnique
   */
  export type propertiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties findUniqueOrThrow
   */
  export type propertiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties findFirst
   */
  export type propertiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of properties.
     */
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties findFirstOrThrow
   */
  export type propertiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of properties.
     */
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties findMany
   */
  export type propertiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter, which properties to fetch.
     */
    where?: propertiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of properties to fetch.
     */
    orderBy?: propertiesOrderByWithRelationInput | propertiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing properties.
     */
    cursor?: propertiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` properties.
     */
    skip?: number
    distinct?: PropertiesScalarFieldEnum | PropertiesScalarFieldEnum[]
  }

  /**
   * properties create
   */
  export type propertiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * The data needed to create a properties.
     */
    data: XOR<propertiesCreateInput, propertiesUncheckedCreateInput>
  }

  /**
   * properties createMany
   */
  export type propertiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many properties.
     */
    data: propertiesCreateManyInput | propertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * properties createManyAndReturn
   */
  export type propertiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * The data used to create many properties.
     */
    data: propertiesCreateManyInput | propertiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * properties update
   */
  export type propertiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * The data needed to update a properties.
     */
    data: XOR<propertiesUpdateInput, propertiesUncheckedUpdateInput>
    /**
     * Choose, which properties to update.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties updateMany
   */
  export type propertiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update properties.
     */
    data: XOR<propertiesUpdateManyMutationInput, propertiesUncheckedUpdateManyInput>
    /**
     * Filter which properties to update
     */
    where?: propertiesWhereInput
    /**
     * Limit how many properties to update.
     */
    limit?: number
  }

  /**
   * properties updateManyAndReturn
   */
  export type propertiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * The data used to update properties.
     */
    data: XOR<propertiesUpdateManyMutationInput, propertiesUncheckedUpdateManyInput>
    /**
     * Filter which properties to update
     */
    where?: propertiesWhereInput
    /**
     * Limit how many properties to update.
     */
    limit?: number
  }

  /**
   * properties upsert
   */
  export type propertiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * The filter to search for the properties to update in case it exists.
     */
    where: propertiesWhereUniqueInput
    /**
     * In case the properties found by the `where` argument doesn't exist, create a new properties with this data.
     */
    create: XOR<propertiesCreateInput, propertiesUncheckedCreateInput>
    /**
     * In case the properties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<propertiesUpdateInput, propertiesUncheckedUpdateInput>
  }

  /**
   * properties delete
   */
  export type propertiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
    /**
     * Filter which properties to delete.
     */
    where: propertiesWhereUniqueInput
  }

  /**
   * properties deleteMany
   */
  export type propertiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which properties to delete
     */
    where?: propertiesWhereInput
    /**
     * Limit how many properties to delete.
     */
    limit?: number
  }

  /**
   * properties without action
   */
  export type propertiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the properties
     */
    select?: propertiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the properties
     */
    omit?: propertiesOmit<ExtArgs> | null
  }


  /**
   * Model rejected_transfers
   */

  export type AggregateRejected_transfers = {
    _count: Rejected_transfersCountAggregateOutputType | null
    _min: Rejected_transfersMinAggregateOutputType | null
    _max: Rejected_transfersMaxAggregateOutputType | null
  }

  export type Rejected_transfersMinAggregateOutputType = {
    id: string | null
    inflow_transaction_id: string | null
    outflow_transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rejected_transfersMaxAggregateOutputType = {
    id: string | null
    inflow_transaction_id: string | null
    outflow_transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rejected_transfersCountAggregateOutputType = {
    id: number
    inflow_transaction_id: number
    outflow_transaction_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Rejected_transfersMinAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Rejected_transfersMaxAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Rejected_transfersCountAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Rejected_transfersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rejected_transfers to aggregate.
     */
    where?: rejected_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejected_transfers to fetch.
     */
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rejected_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejected_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejected_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rejected_transfers
    **/
    _count?: true | Rejected_transfersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rejected_transfersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rejected_transfersMaxAggregateInputType
  }

  export type GetRejected_transfersAggregateType<T extends Rejected_transfersAggregateArgs> = {
        [P in keyof T & keyof AggregateRejected_transfers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRejected_transfers[P]>
      : GetScalarType<T[P], AggregateRejected_transfers[P]>
  }




  export type rejected_transfersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rejected_transfersWhereInput
    orderBy?: rejected_transfersOrderByWithAggregationInput | rejected_transfersOrderByWithAggregationInput[]
    by: Rejected_transfersScalarFieldEnum[] | Rejected_transfersScalarFieldEnum
    having?: rejected_transfersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rejected_transfersCountAggregateInputType | true
    _min?: Rejected_transfersMinAggregateInputType
    _max?: Rejected_transfersMaxAggregateInputType
  }

  export type Rejected_transfersGroupByOutputType = {
    id: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    created_at: Date
    updated_at: Date
    _count: Rejected_transfersCountAggregateOutputType | null
    _min: Rejected_transfersMinAggregateOutputType | null
    _max: Rejected_transfersMaxAggregateOutputType | null
  }

  type GetRejected_transfersGroupByPayload<T extends rejected_transfersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rejected_transfersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rejected_transfersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rejected_transfersGroupByOutputType[P]>
            : GetScalarType<T[P], Rejected_transfersGroupByOutputType[P]>
        }
      >
    >


  export type rejected_transfersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejected_transfers"]>

  export type rejected_transfersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejected_transfers"]>

  export type rejected_transfersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rejected_transfers"]>

  export type rejected_transfersSelectScalar = {
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rejected_transfersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inflow_transaction_id" | "outflow_transaction_id" | "created_at" | "updated_at", ExtArgs["result"]["rejected_transfers"]>
  export type rejected_transfersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }
  export type rejected_transfersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }
  export type rejected_transfersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }

  export type $rejected_transfersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rejected_transfers"
    objects: {
      transactions_rejected_transfers_outflow_transaction_idTotransactions: Prisma.$transactionsPayload<ExtArgs>
      transactions_rejected_transfers_inflow_transaction_idTotransactions: Prisma.$transactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inflow_transaction_id: string
      outflow_transaction_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["rejected_transfers"]>
    composites: {}
  }

  type rejected_transfersGetPayload<S extends boolean | null | undefined | rejected_transfersDefaultArgs> = $Result.GetResult<Prisma.$rejected_transfersPayload, S>

  type rejected_transfersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rejected_transfersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rejected_transfersCountAggregateInputType | true
    }

  export interface rejected_transfersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rejected_transfers'], meta: { name: 'rejected_transfers' } }
    /**
     * Find zero or one Rejected_transfers that matches the filter.
     * @param {rejected_transfersFindUniqueArgs} args - Arguments to find a Rejected_transfers
     * @example
     * // Get one Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rejected_transfersFindUniqueArgs>(args: SelectSubset<T, rejected_transfersFindUniqueArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rejected_transfers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rejected_transfersFindUniqueOrThrowArgs} args - Arguments to find a Rejected_transfers
     * @example
     * // Get one Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rejected_transfersFindUniqueOrThrowArgs>(args: SelectSubset<T, rejected_transfersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rejected_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersFindFirstArgs} args - Arguments to find a Rejected_transfers
     * @example
     * // Get one Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rejected_transfersFindFirstArgs>(args?: SelectSubset<T, rejected_transfersFindFirstArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rejected_transfers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersFindFirstOrThrowArgs} args - Arguments to find a Rejected_transfers
     * @example
     * // Get one Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rejected_transfersFindFirstOrThrowArgs>(args?: SelectSubset<T, rejected_transfersFindFirstOrThrowArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rejected_transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findMany()
     * 
     * // Get first 10 Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rejected_transfersWithIdOnly = await prisma.rejected_transfers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rejected_transfersFindManyArgs>(args?: SelectSubset<T, rejected_transfersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rejected_transfers.
     * @param {rejected_transfersCreateArgs} args - Arguments to create a Rejected_transfers.
     * @example
     * // Create one Rejected_transfers
     * const Rejected_transfers = await prisma.rejected_transfers.create({
     *   data: {
     *     // ... data to create a Rejected_transfers
     *   }
     * })
     * 
     */
    create<T extends rejected_transfersCreateArgs>(args: SelectSubset<T, rejected_transfersCreateArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rejected_transfers.
     * @param {rejected_transfersCreateManyArgs} args - Arguments to create many Rejected_transfers.
     * @example
     * // Create many Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rejected_transfersCreateManyArgs>(args?: SelectSubset<T, rejected_transfersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rejected_transfers and returns the data saved in the database.
     * @param {rejected_transfersCreateManyAndReturnArgs} args - Arguments to create many Rejected_transfers.
     * @example
     * // Create many Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rejected_transfers and only return the `id`
     * const rejected_transfersWithIdOnly = await prisma.rejected_transfers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rejected_transfersCreateManyAndReturnArgs>(args?: SelectSubset<T, rejected_transfersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rejected_transfers.
     * @param {rejected_transfersDeleteArgs} args - Arguments to delete one Rejected_transfers.
     * @example
     * // Delete one Rejected_transfers
     * const Rejected_transfers = await prisma.rejected_transfers.delete({
     *   where: {
     *     // ... filter to delete one Rejected_transfers
     *   }
     * })
     * 
     */
    delete<T extends rejected_transfersDeleteArgs>(args: SelectSubset<T, rejected_transfersDeleteArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rejected_transfers.
     * @param {rejected_transfersUpdateArgs} args - Arguments to update one Rejected_transfers.
     * @example
     * // Update one Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rejected_transfersUpdateArgs>(args: SelectSubset<T, rejected_transfersUpdateArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rejected_transfers.
     * @param {rejected_transfersDeleteManyArgs} args - Arguments to filter Rejected_transfers to delete.
     * @example
     * // Delete a few Rejected_transfers
     * const { count } = await prisma.rejected_transfers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rejected_transfersDeleteManyArgs>(args?: SelectSubset<T, rejected_transfersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rejected_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rejected_transfersUpdateManyArgs>(args: SelectSubset<T, rejected_transfersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rejected_transfers and returns the data updated in the database.
     * @param {rejected_transfersUpdateManyAndReturnArgs} args - Arguments to update many Rejected_transfers.
     * @example
     * // Update many Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rejected_transfers and only return the `id`
     * const rejected_transfersWithIdOnly = await prisma.rejected_transfers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rejected_transfersUpdateManyAndReturnArgs>(args: SelectSubset<T, rejected_transfersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rejected_transfers.
     * @param {rejected_transfersUpsertArgs} args - Arguments to update or create a Rejected_transfers.
     * @example
     * // Update or create a Rejected_transfers
     * const rejected_transfers = await prisma.rejected_transfers.upsert({
     *   create: {
     *     // ... data to create a Rejected_transfers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rejected_transfers we want to update
     *   }
     * })
     */
    upsert<T extends rejected_transfersUpsertArgs>(args: SelectSubset<T, rejected_transfersUpsertArgs<ExtArgs>>): Prisma__rejected_transfersClient<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rejected_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersCountArgs} args - Arguments to filter Rejected_transfers to count.
     * @example
     * // Count the number of Rejected_transfers
     * const count = await prisma.rejected_transfers.count({
     *   where: {
     *     // ... the filter for the Rejected_transfers we want to count
     *   }
     * })
    **/
    count<T extends rejected_transfersCountArgs>(
      args?: Subset<T, rejected_transfersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rejected_transfersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rejected_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rejected_transfersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rejected_transfersAggregateArgs>(args: Subset<T, Rejected_transfersAggregateArgs>): Prisma.PrismaPromise<GetRejected_transfersAggregateType<T>>

    /**
     * Group by Rejected_transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rejected_transfersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rejected_transfersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rejected_transfersGroupByArgs['orderBy'] }
        : { orderBy?: rejected_transfersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rejected_transfersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRejected_transfersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rejected_transfers model
   */
  readonly fields: rejected_transfersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rejected_transfers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rejected_transfersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions_rejected_transfers_outflow_transaction_idTotransactions<T extends transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transactionsDefaultArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions_rejected_transfers_inflow_transaction_idTotransactions<T extends transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transactionsDefaultArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rejected_transfers model
   */
  interface rejected_transfersFieldRefs {
    readonly id: FieldRef<"rejected_transfers", 'String'>
    readonly inflow_transaction_id: FieldRef<"rejected_transfers", 'String'>
    readonly outflow_transaction_id: FieldRef<"rejected_transfers", 'String'>
    readonly created_at: FieldRef<"rejected_transfers", 'DateTime'>
    readonly updated_at: FieldRef<"rejected_transfers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rejected_transfers findUnique
   */
  export type rejected_transfersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter, which rejected_transfers to fetch.
     */
    where: rejected_transfersWhereUniqueInput
  }

  /**
   * rejected_transfers findUniqueOrThrow
   */
  export type rejected_transfersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter, which rejected_transfers to fetch.
     */
    where: rejected_transfersWhereUniqueInput
  }

  /**
   * rejected_transfers findFirst
   */
  export type rejected_transfersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter, which rejected_transfers to fetch.
     */
    where?: rejected_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejected_transfers to fetch.
     */
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rejected_transfers.
     */
    cursor?: rejected_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejected_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejected_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rejected_transfers.
     */
    distinct?: Rejected_transfersScalarFieldEnum | Rejected_transfersScalarFieldEnum[]
  }

  /**
   * rejected_transfers findFirstOrThrow
   */
  export type rejected_transfersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter, which rejected_transfers to fetch.
     */
    where?: rejected_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejected_transfers to fetch.
     */
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rejected_transfers.
     */
    cursor?: rejected_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejected_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejected_transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rejected_transfers.
     */
    distinct?: Rejected_transfersScalarFieldEnum | Rejected_transfersScalarFieldEnum[]
  }

  /**
   * rejected_transfers findMany
   */
  export type rejected_transfersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter, which rejected_transfers to fetch.
     */
    where?: rejected_transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rejected_transfers to fetch.
     */
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rejected_transfers.
     */
    cursor?: rejected_transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rejected_transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rejected_transfers.
     */
    skip?: number
    distinct?: Rejected_transfersScalarFieldEnum | Rejected_transfersScalarFieldEnum[]
  }

  /**
   * rejected_transfers create
   */
  export type rejected_transfersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * The data needed to create a rejected_transfers.
     */
    data: XOR<rejected_transfersCreateInput, rejected_transfersUncheckedCreateInput>
  }

  /**
   * rejected_transfers createMany
   */
  export type rejected_transfersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rejected_transfers.
     */
    data: rejected_transfersCreateManyInput | rejected_transfersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rejected_transfers createManyAndReturn
   */
  export type rejected_transfersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * The data used to create many rejected_transfers.
     */
    data: rejected_transfersCreateManyInput | rejected_transfersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rejected_transfers update
   */
  export type rejected_transfersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * The data needed to update a rejected_transfers.
     */
    data: XOR<rejected_transfersUpdateInput, rejected_transfersUncheckedUpdateInput>
    /**
     * Choose, which rejected_transfers to update.
     */
    where: rejected_transfersWhereUniqueInput
  }

  /**
   * rejected_transfers updateMany
   */
  export type rejected_transfersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rejected_transfers.
     */
    data: XOR<rejected_transfersUpdateManyMutationInput, rejected_transfersUncheckedUpdateManyInput>
    /**
     * Filter which rejected_transfers to update
     */
    where?: rejected_transfersWhereInput
    /**
     * Limit how many rejected_transfers to update.
     */
    limit?: number
  }

  /**
   * rejected_transfers updateManyAndReturn
   */
  export type rejected_transfersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * The data used to update rejected_transfers.
     */
    data: XOR<rejected_transfersUpdateManyMutationInput, rejected_transfersUncheckedUpdateManyInput>
    /**
     * Filter which rejected_transfers to update
     */
    where?: rejected_transfersWhereInput
    /**
     * Limit how many rejected_transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rejected_transfers upsert
   */
  export type rejected_transfersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * The filter to search for the rejected_transfers to update in case it exists.
     */
    where: rejected_transfersWhereUniqueInput
    /**
     * In case the rejected_transfers found by the `where` argument doesn't exist, create a new rejected_transfers with this data.
     */
    create: XOR<rejected_transfersCreateInput, rejected_transfersUncheckedCreateInput>
    /**
     * In case the rejected_transfers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rejected_transfersUpdateInput, rejected_transfersUncheckedUpdateInput>
  }

  /**
   * rejected_transfers delete
   */
  export type rejected_transfersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    /**
     * Filter which rejected_transfers to delete.
     */
    where: rejected_transfersWhereUniqueInput
  }

  /**
   * rejected_transfers deleteMany
   */
  export type rejected_transfersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rejected_transfers to delete
     */
    where?: rejected_transfersWhereInput
    /**
     * Limit how many rejected_transfers to delete.
     */
    limit?: number
  }

  /**
   * rejected_transfers without action
   */
  export type rejected_transfersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
  }


  /**
   * Model rule_actions
   */

  export type AggregateRule_actions = {
    _count: Rule_actionsCountAggregateOutputType | null
    _min: Rule_actionsMinAggregateOutputType | null
    _max: Rule_actionsMaxAggregateOutputType | null
  }

  export type Rule_actionsMinAggregateOutputType = {
    id: string | null
    rule_id: string | null
    action_type: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rule_actionsMaxAggregateOutputType = {
    id: string | null
    rule_id: string | null
    action_type: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rule_actionsCountAggregateOutputType = {
    id: number
    rule_id: number
    action_type: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Rule_actionsMinAggregateInputType = {
    id?: true
    rule_id?: true
    action_type?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Rule_actionsMaxAggregateInputType = {
    id?: true
    rule_id?: true
    action_type?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Rule_actionsCountAggregateInputType = {
    id?: true
    rule_id?: true
    action_type?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Rule_actionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rule_actions to aggregate.
     */
    where?: rule_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_actions to fetch.
     */
    orderBy?: rule_actionsOrderByWithRelationInput | rule_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rule_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rule_actions
    **/
    _count?: true | Rule_actionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rule_actionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rule_actionsMaxAggregateInputType
  }

  export type GetRule_actionsAggregateType<T extends Rule_actionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRule_actions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRule_actions[P]>
      : GetScalarType<T[P], AggregateRule_actions[P]>
  }




  export type rule_actionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rule_actionsWhereInput
    orderBy?: rule_actionsOrderByWithAggregationInput | rule_actionsOrderByWithAggregationInput[]
    by: Rule_actionsScalarFieldEnum[] | Rule_actionsScalarFieldEnum
    having?: rule_actionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rule_actionsCountAggregateInputType | true
    _min?: Rule_actionsMinAggregateInputType
    _max?: Rule_actionsMaxAggregateInputType
  }

  export type Rule_actionsGroupByOutputType = {
    id: string
    rule_id: string
    action_type: string
    value: string | null
    created_at: Date
    updated_at: Date
    _count: Rule_actionsCountAggregateOutputType | null
    _min: Rule_actionsMinAggregateOutputType | null
    _max: Rule_actionsMaxAggregateOutputType | null
  }

  type GetRule_actionsGroupByPayload<T extends rule_actionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rule_actionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rule_actionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rule_actionsGroupByOutputType[P]>
            : GetScalarType<T[P], Rule_actionsGroupByOutputType[P]>
        }
      >
    >


  export type rule_actionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    action_type?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rule_actions"]>

  export type rule_actionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    action_type?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rule_actions"]>

  export type rule_actionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    action_type?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rule_actions"]>

  export type rule_actionsSelectScalar = {
    id?: boolean
    rule_id?: boolean
    action_type?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rule_actionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rule_id" | "action_type" | "value" | "created_at" | "updated_at", ExtArgs["result"]["rule_actions"]>
  export type rule_actionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }
  export type rule_actionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }
  export type rule_actionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | rulesDefaultArgs<ExtArgs>
  }

  export type $rule_actionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rule_actions"
    objects: {
      rules: Prisma.$rulesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rule_id: string
      action_type: string
      value: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["rule_actions"]>
    composites: {}
  }

  type rule_actionsGetPayload<S extends boolean | null | undefined | rule_actionsDefaultArgs> = $Result.GetResult<Prisma.$rule_actionsPayload, S>

  type rule_actionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rule_actionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rule_actionsCountAggregateInputType | true
    }

  export interface rule_actionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rule_actions'], meta: { name: 'rule_actions' } }
    /**
     * Find zero or one Rule_actions that matches the filter.
     * @param {rule_actionsFindUniqueArgs} args - Arguments to find a Rule_actions
     * @example
     * // Get one Rule_actions
     * const rule_actions = await prisma.rule_actions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rule_actionsFindUniqueArgs>(args: SelectSubset<T, rule_actionsFindUniqueArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rule_actions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rule_actionsFindUniqueOrThrowArgs} args - Arguments to find a Rule_actions
     * @example
     * // Get one Rule_actions
     * const rule_actions = await prisma.rule_actions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rule_actionsFindUniqueOrThrowArgs>(args: SelectSubset<T, rule_actionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rule_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsFindFirstArgs} args - Arguments to find a Rule_actions
     * @example
     * // Get one Rule_actions
     * const rule_actions = await prisma.rule_actions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rule_actionsFindFirstArgs>(args?: SelectSubset<T, rule_actionsFindFirstArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rule_actions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsFindFirstOrThrowArgs} args - Arguments to find a Rule_actions
     * @example
     * // Get one Rule_actions
     * const rule_actions = await prisma.rule_actions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rule_actionsFindFirstOrThrowArgs>(args?: SelectSubset<T, rule_actionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rule_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rule_actions
     * const rule_actions = await prisma.rule_actions.findMany()
     * 
     * // Get first 10 Rule_actions
     * const rule_actions = await prisma.rule_actions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rule_actionsWithIdOnly = await prisma.rule_actions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rule_actionsFindManyArgs>(args?: SelectSubset<T, rule_actionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rule_actions.
     * @param {rule_actionsCreateArgs} args - Arguments to create a Rule_actions.
     * @example
     * // Create one Rule_actions
     * const Rule_actions = await prisma.rule_actions.create({
     *   data: {
     *     // ... data to create a Rule_actions
     *   }
     * })
     * 
     */
    create<T extends rule_actionsCreateArgs>(args: SelectSubset<T, rule_actionsCreateArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rule_actions.
     * @param {rule_actionsCreateManyArgs} args - Arguments to create many Rule_actions.
     * @example
     * // Create many Rule_actions
     * const rule_actions = await prisma.rule_actions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rule_actionsCreateManyArgs>(args?: SelectSubset<T, rule_actionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rule_actions and returns the data saved in the database.
     * @param {rule_actionsCreateManyAndReturnArgs} args - Arguments to create many Rule_actions.
     * @example
     * // Create many Rule_actions
     * const rule_actions = await prisma.rule_actions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rule_actions and only return the `id`
     * const rule_actionsWithIdOnly = await prisma.rule_actions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rule_actionsCreateManyAndReturnArgs>(args?: SelectSubset<T, rule_actionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rule_actions.
     * @param {rule_actionsDeleteArgs} args - Arguments to delete one Rule_actions.
     * @example
     * // Delete one Rule_actions
     * const Rule_actions = await prisma.rule_actions.delete({
     *   where: {
     *     // ... filter to delete one Rule_actions
     *   }
     * })
     * 
     */
    delete<T extends rule_actionsDeleteArgs>(args: SelectSubset<T, rule_actionsDeleteArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rule_actions.
     * @param {rule_actionsUpdateArgs} args - Arguments to update one Rule_actions.
     * @example
     * // Update one Rule_actions
     * const rule_actions = await prisma.rule_actions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rule_actionsUpdateArgs>(args: SelectSubset<T, rule_actionsUpdateArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rule_actions.
     * @param {rule_actionsDeleteManyArgs} args - Arguments to filter Rule_actions to delete.
     * @example
     * // Delete a few Rule_actions
     * const { count } = await prisma.rule_actions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rule_actionsDeleteManyArgs>(args?: SelectSubset<T, rule_actionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rule_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rule_actions
     * const rule_actions = await prisma.rule_actions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rule_actionsUpdateManyArgs>(args: SelectSubset<T, rule_actionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rule_actions and returns the data updated in the database.
     * @param {rule_actionsUpdateManyAndReturnArgs} args - Arguments to update many Rule_actions.
     * @example
     * // Update many Rule_actions
     * const rule_actions = await prisma.rule_actions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rule_actions and only return the `id`
     * const rule_actionsWithIdOnly = await prisma.rule_actions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rule_actionsUpdateManyAndReturnArgs>(args: SelectSubset<T, rule_actionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rule_actions.
     * @param {rule_actionsUpsertArgs} args - Arguments to update or create a Rule_actions.
     * @example
     * // Update or create a Rule_actions
     * const rule_actions = await prisma.rule_actions.upsert({
     *   create: {
     *     // ... data to create a Rule_actions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rule_actions we want to update
     *   }
     * })
     */
    upsert<T extends rule_actionsUpsertArgs>(args: SelectSubset<T, rule_actionsUpsertArgs<ExtArgs>>): Prisma__rule_actionsClient<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rule_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsCountArgs} args - Arguments to filter Rule_actions to count.
     * @example
     * // Count the number of Rule_actions
     * const count = await prisma.rule_actions.count({
     *   where: {
     *     // ... the filter for the Rule_actions we want to count
     *   }
     * })
    **/
    count<T extends rule_actionsCountArgs>(
      args?: Subset<T, rule_actionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rule_actionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rule_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rule_actionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rule_actionsAggregateArgs>(args: Subset<T, Rule_actionsAggregateArgs>): Prisma.PrismaPromise<GetRule_actionsAggregateType<T>>

    /**
     * Group by Rule_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_actionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rule_actionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rule_actionsGroupByArgs['orderBy'] }
        : { orderBy?: rule_actionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rule_actionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRule_actionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rule_actions model
   */
  readonly fields: rule_actionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rule_actions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rule_actionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rules<T extends rulesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rulesDefaultArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rule_actions model
   */
  interface rule_actionsFieldRefs {
    readonly id: FieldRef<"rule_actions", 'String'>
    readonly rule_id: FieldRef<"rule_actions", 'String'>
    readonly action_type: FieldRef<"rule_actions", 'String'>
    readonly value: FieldRef<"rule_actions", 'String'>
    readonly created_at: FieldRef<"rule_actions", 'DateTime'>
    readonly updated_at: FieldRef<"rule_actions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rule_actions findUnique
   */
  export type rule_actionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_actions to fetch.
     */
    where: rule_actionsWhereUniqueInput
  }

  /**
   * rule_actions findUniqueOrThrow
   */
  export type rule_actionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_actions to fetch.
     */
    where: rule_actionsWhereUniqueInput
  }

  /**
   * rule_actions findFirst
   */
  export type rule_actionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_actions to fetch.
     */
    where?: rule_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_actions to fetch.
     */
    orderBy?: rule_actionsOrderByWithRelationInput | rule_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rule_actions.
     */
    cursor?: rule_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rule_actions.
     */
    distinct?: Rule_actionsScalarFieldEnum | Rule_actionsScalarFieldEnum[]
  }

  /**
   * rule_actions findFirstOrThrow
   */
  export type rule_actionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_actions to fetch.
     */
    where?: rule_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_actions to fetch.
     */
    orderBy?: rule_actionsOrderByWithRelationInput | rule_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rule_actions.
     */
    cursor?: rule_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rule_actions.
     */
    distinct?: Rule_actionsScalarFieldEnum | Rule_actionsScalarFieldEnum[]
  }

  /**
   * rule_actions findMany
   */
  export type rule_actionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_actions to fetch.
     */
    where?: rule_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_actions to fetch.
     */
    orderBy?: rule_actionsOrderByWithRelationInput | rule_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rule_actions.
     */
    cursor?: rule_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_actions.
     */
    skip?: number
    distinct?: Rule_actionsScalarFieldEnum | Rule_actionsScalarFieldEnum[]
  }

  /**
   * rule_actions create
   */
  export type rule_actionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * The data needed to create a rule_actions.
     */
    data: XOR<rule_actionsCreateInput, rule_actionsUncheckedCreateInput>
  }

  /**
   * rule_actions createMany
   */
  export type rule_actionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rule_actions.
     */
    data: rule_actionsCreateManyInput | rule_actionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rule_actions createManyAndReturn
   */
  export type rule_actionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * The data used to create many rule_actions.
     */
    data: rule_actionsCreateManyInput | rule_actionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rule_actions update
   */
  export type rule_actionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * The data needed to update a rule_actions.
     */
    data: XOR<rule_actionsUpdateInput, rule_actionsUncheckedUpdateInput>
    /**
     * Choose, which rule_actions to update.
     */
    where: rule_actionsWhereUniqueInput
  }

  /**
   * rule_actions updateMany
   */
  export type rule_actionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rule_actions.
     */
    data: XOR<rule_actionsUpdateManyMutationInput, rule_actionsUncheckedUpdateManyInput>
    /**
     * Filter which rule_actions to update
     */
    where?: rule_actionsWhereInput
    /**
     * Limit how many rule_actions to update.
     */
    limit?: number
  }

  /**
   * rule_actions updateManyAndReturn
   */
  export type rule_actionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * The data used to update rule_actions.
     */
    data: XOR<rule_actionsUpdateManyMutationInput, rule_actionsUncheckedUpdateManyInput>
    /**
     * Filter which rule_actions to update
     */
    where?: rule_actionsWhereInput
    /**
     * Limit how many rule_actions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rule_actions upsert
   */
  export type rule_actionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * The filter to search for the rule_actions to update in case it exists.
     */
    where: rule_actionsWhereUniqueInput
    /**
     * In case the rule_actions found by the `where` argument doesn't exist, create a new rule_actions with this data.
     */
    create: XOR<rule_actionsCreateInput, rule_actionsUncheckedCreateInput>
    /**
     * In case the rule_actions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rule_actionsUpdateInput, rule_actionsUncheckedUpdateInput>
  }

  /**
   * rule_actions delete
   */
  export type rule_actionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    /**
     * Filter which rule_actions to delete.
     */
    where: rule_actionsWhereUniqueInput
  }

  /**
   * rule_actions deleteMany
   */
  export type rule_actionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rule_actions to delete
     */
    where?: rule_actionsWhereInput
    /**
     * Limit how many rule_actions to delete.
     */
    limit?: number
  }

  /**
   * rule_actions without action
   */
  export type rule_actionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
  }


  /**
   * Model rule_conditions
   */

  export type AggregateRule_conditions = {
    _count: Rule_conditionsCountAggregateOutputType | null
    _min: Rule_conditionsMinAggregateOutputType | null
    _max: Rule_conditionsMaxAggregateOutputType | null
  }

  export type Rule_conditionsMinAggregateOutputType = {
    id: string | null
    rule_id: string | null
    parent_id: string | null
    condition_type: string | null
    operator: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rule_conditionsMaxAggregateOutputType = {
    id: string | null
    rule_id: string | null
    parent_id: string | null
    condition_type: string | null
    operator: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Rule_conditionsCountAggregateOutputType = {
    id: number
    rule_id: number
    parent_id: number
    condition_type: number
    operator: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Rule_conditionsMinAggregateInputType = {
    id?: true
    rule_id?: true
    parent_id?: true
    condition_type?: true
    operator?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Rule_conditionsMaxAggregateInputType = {
    id?: true
    rule_id?: true
    parent_id?: true
    condition_type?: true
    operator?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type Rule_conditionsCountAggregateInputType = {
    id?: true
    rule_id?: true
    parent_id?: true
    condition_type?: true
    operator?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Rule_conditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rule_conditions to aggregate.
     */
    where?: rule_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_conditions to fetch.
     */
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rule_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rule_conditions
    **/
    _count?: true | Rule_conditionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rule_conditionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rule_conditionsMaxAggregateInputType
  }

  export type GetRule_conditionsAggregateType<T extends Rule_conditionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRule_conditions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRule_conditions[P]>
      : GetScalarType<T[P], AggregateRule_conditions[P]>
  }




  export type rule_conditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rule_conditionsWhereInput
    orderBy?: rule_conditionsOrderByWithAggregationInput | rule_conditionsOrderByWithAggregationInput[]
    by: Rule_conditionsScalarFieldEnum[] | Rule_conditionsScalarFieldEnum
    having?: rule_conditionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rule_conditionsCountAggregateInputType | true
    _min?: Rule_conditionsMinAggregateInputType
    _max?: Rule_conditionsMaxAggregateInputType
  }

  export type Rule_conditionsGroupByOutputType = {
    id: string
    rule_id: string | null
    parent_id: string | null
    condition_type: string
    operator: string
    value: string | null
    created_at: Date
    updated_at: Date
    _count: Rule_conditionsCountAggregateOutputType | null
    _min: Rule_conditionsMinAggregateOutputType | null
    _max: Rule_conditionsMaxAggregateOutputType | null
  }

  type GetRule_conditionsGroupByPayload<T extends rule_conditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rule_conditionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rule_conditionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rule_conditionsGroupByOutputType[P]>
            : GetScalarType<T[P], Rule_conditionsGroupByOutputType[P]>
        }
      >
    >


  export type rule_conditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    parent_id?: boolean
    condition_type?: boolean
    operator?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    other_rule_conditions?: boolean | rule_conditions$other_rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
    _count?: boolean | Rule_conditionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rule_conditions"]>

  export type rule_conditionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    parent_id?: boolean
    condition_type?: boolean
    operator?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
  }, ExtArgs["result"]["rule_conditions"]>

  export type rule_conditionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rule_id?: boolean
    parent_id?: boolean
    condition_type?: boolean
    operator?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
  }, ExtArgs["result"]["rule_conditions"]>

  export type rule_conditionsSelectScalar = {
    id?: boolean
    rule_id?: boolean
    parent_id?: boolean
    condition_type?: boolean
    operator?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rule_conditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rule_id" | "parent_id" | "condition_type" | "operator" | "value" | "created_at" | "updated_at", ExtArgs["result"]["rule_conditions"]>
  export type rule_conditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    other_rule_conditions?: boolean | rule_conditions$other_rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
    _count?: boolean | Rule_conditionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rule_conditionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
  }
  export type rule_conditionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule_conditions?: boolean | rule_conditions$rule_conditionsArgs<ExtArgs>
    rules?: boolean | rule_conditions$rulesArgs<ExtArgs>
  }

  export type $rule_conditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rule_conditions"
    objects: {
      rule_conditions: Prisma.$rule_conditionsPayload<ExtArgs> | null
      other_rule_conditions: Prisma.$rule_conditionsPayload<ExtArgs>[]
      rules: Prisma.$rulesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rule_id: string | null
      parent_id: string | null
      condition_type: string
      operator: string
      value: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["rule_conditions"]>
    composites: {}
  }

  type rule_conditionsGetPayload<S extends boolean | null | undefined | rule_conditionsDefaultArgs> = $Result.GetResult<Prisma.$rule_conditionsPayload, S>

  type rule_conditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rule_conditionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rule_conditionsCountAggregateInputType | true
    }

  export interface rule_conditionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rule_conditions'], meta: { name: 'rule_conditions' } }
    /**
     * Find zero or one Rule_conditions that matches the filter.
     * @param {rule_conditionsFindUniqueArgs} args - Arguments to find a Rule_conditions
     * @example
     * // Get one Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rule_conditionsFindUniqueArgs>(args: SelectSubset<T, rule_conditionsFindUniqueArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rule_conditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rule_conditionsFindUniqueOrThrowArgs} args - Arguments to find a Rule_conditions
     * @example
     * // Get one Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rule_conditionsFindUniqueOrThrowArgs>(args: SelectSubset<T, rule_conditionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rule_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsFindFirstArgs} args - Arguments to find a Rule_conditions
     * @example
     * // Get one Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rule_conditionsFindFirstArgs>(args?: SelectSubset<T, rule_conditionsFindFirstArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rule_conditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsFindFirstOrThrowArgs} args - Arguments to find a Rule_conditions
     * @example
     * // Get one Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rule_conditionsFindFirstOrThrowArgs>(args?: SelectSubset<T, rule_conditionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rule_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findMany()
     * 
     * // Get first 10 Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rule_conditionsWithIdOnly = await prisma.rule_conditions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rule_conditionsFindManyArgs>(args?: SelectSubset<T, rule_conditionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rule_conditions.
     * @param {rule_conditionsCreateArgs} args - Arguments to create a Rule_conditions.
     * @example
     * // Create one Rule_conditions
     * const Rule_conditions = await prisma.rule_conditions.create({
     *   data: {
     *     // ... data to create a Rule_conditions
     *   }
     * })
     * 
     */
    create<T extends rule_conditionsCreateArgs>(args: SelectSubset<T, rule_conditionsCreateArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rule_conditions.
     * @param {rule_conditionsCreateManyArgs} args - Arguments to create many Rule_conditions.
     * @example
     * // Create many Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rule_conditionsCreateManyArgs>(args?: SelectSubset<T, rule_conditionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rule_conditions and returns the data saved in the database.
     * @param {rule_conditionsCreateManyAndReturnArgs} args - Arguments to create many Rule_conditions.
     * @example
     * // Create many Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rule_conditions and only return the `id`
     * const rule_conditionsWithIdOnly = await prisma.rule_conditions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rule_conditionsCreateManyAndReturnArgs>(args?: SelectSubset<T, rule_conditionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rule_conditions.
     * @param {rule_conditionsDeleteArgs} args - Arguments to delete one Rule_conditions.
     * @example
     * // Delete one Rule_conditions
     * const Rule_conditions = await prisma.rule_conditions.delete({
     *   where: {
     *     // ... filter to delete one Rule_conditions
     *   }
     * })
     * 
     */
    delete<T extends rule_conditionsDeleteArgs>(args: SelectSubset<T, rule_conditionsDeleteArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rule_conditions.
     * @param {rule_conditionsUpdateArgs} args - Arguments to update one Rule_conditions.
     * @example
     * // Update one Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rule_conditionsUpdateArgs>(args: SelectSubset<T, rule_conditionsUpdateArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rule_conditions.
     * @param {rule_conditionsDeleteManyArgs} args - Arguments to filter Rule_conditions to delete.
     * @example
     * // Delete a few Rule_conditions
     * const { count } = await prisma.rule_conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rule_conditionsDeleteManyArgs>(args?: SelectSubset<T, rule_conditionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rule_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rule_conditionsUpdateManyArgs>(args: SelectSubset<T, rule_conditionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rule_conditions and returns the data updated in the database.
     * @param {rule_conditionsUpdateManyAndReturnArgs} args - Arguments to update many Rule_conditions.
     * @example
     * // Update many Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rule_conditions and only return the `id`
     * const rule_conditionsWithIdOnly = await prisma.rule_conditions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rule_conditionsUpdateManyAndReturnArgs>(args: SelectSubset<T, rule_conditionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rule_conditions.
     * @param {rule_conditionsUpsertArgs} args - Arguments to update or create a Rule_conditions.
     * @example
     * // Update or create a Rule_conditions
     * const rule_conditions = await prisma.rule_conditions.upsert({
     *   create: {
     *     // ... data to create a Rule_conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rule_conditions we want to update
     *   }
     * })
     */
    upsert<T extends rule_conditionsUpsertArgs>(args: SelectSubset<T, rule_conditionsUpsertArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rule_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsCountArgs} args - Arguments to filter Rule_conditions to count.
     * @example
     * // Count the number of Rule_conditions
     * const count = await prisma.rule_conditions.count({
     *   where: {
     *     // ... the filter for the Rule_conditions we want to count
     *   }
     * })
    **/
    count<T extends rule_conditionsCountArgs>(
      args?: Subset<T, rule_conditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rule_conditionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rule_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rule_conditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rule_conditionsAggregateArgs>(args: Subset<T, Rule_conditionsAggregateArgs>): Prisma.PrismaPromise<GetRule_conditionsAggregateType<T>>

    /**
     * Group by Rule_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rule_conditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rule_conditionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rule_conditionsGroupByArgs['orderBy'] }
        : { orderBy?: rule_conditionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rule_conditionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRule_conditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rule_conditions model
   */
  readonly fields: rule_conditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rule_conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rule_conditionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule_conditions<T extends rule_conditions$rule_conditionsArgs<ExtArgs> = {}>(args?: Subset<T, rule_conditions$rule_conditionsArgs<ExtArgs>>): Prisma__rule_conditionsClient<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_rule_conditions<T extends rule_conditions$other_rule_conditionsArgs<ExtArgs> = {}>(args?: Subset<T, rule_conditions$other_rule_conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rules<T extends rule_conditions$rulesArgs<ExtArgs> = {}>(args?: Subset<T, rule_conditions$rulesArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rule_conditions model
   */
  interface rule_conditionsFieldRefs {
    readonly id: FieldRef<"rule_conditions", 'String'>
    readonly rule_id: FieldRef<"rule_conditions", 'String'>
    readonly parent_id: FieldRef<"rule_conditions", 'String'>
    readonly condition_type: FieldRef<"rule_conditions", 'String'>
    readonly operator: FieldRef<"rule_conditions", 'String'>
    readonly value: FieldRef<"rule_conditions", 'String'>
    readonly created_at: FieldRef<"rule_conditions", 'DateTime'>
    readonly updated_at: FieldRef<"rule_conditions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rule_conditions findUnique
   */
  export type rule_conditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_conditions to fetch.
     */
    where: rule_conditionsWhereUniqueInput
  }

  /**
   * rule_conditions findUniqueOrThrow
   */
  export type rule_conditionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_conditions to fetch.
     */
    where: rule_conditionsWhereUniqueInput
  }

  /**
   * rule_conditions findFirst
   */
  export type rule_conditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_conditions to fetch.
     */
    where?: rule_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_conditions to fetch.
     */
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rule_conditions.
     */
    cursor?: rule_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rule_conditions.
     */
    distinct?: Rule_conditionsScalarFieldEnum | Rule_conditionsScalarFieldEnum[]
  }

  /**
   * rule_conditions findFirstOrThrow
   */
  export type rule_conditionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_conditions to fetch.
     */
    where?: rule_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_conditions to fetch.
     */
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rule_conditions.
     */
    cursor?: rule_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rule_conditions.
     */
    distinct?: Rule_conditionsScalarFieldEnum | Rule_conditionsScalarFieldEnum[]
  }

  /**
   * rule_conditions findMany
   */
  export type rule_conditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter, which rule_conditions to fetch.
     */
    where?: rule_conditionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rule_conditions to fetch.
     */
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rule_conditions.
     */
    cursor?: rule_conditionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rule_conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rule_conditions.
     */
    skip?: number
    distinct?: Rule_conditionsScalarFieldEnum | Rule_conditionsScalarFieldEnum[]
  }

  /**
   * rule_conditions create
   */
  export type rule_conditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to create a rule_conditions.
     */
    data: XOR<rule_conditionsCreateInput, rule_conditionsUncheckedCreateInput>
  }

  /**
   * rule_conditions createMany
   */
  export type rule_conditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rule_conditions.
     */
    data: rule_conditionsCreateManyInput | rule_conditionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rule_conditions createManyAndReturn
   */
  export type rule_conditionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * The data used to create many rule_conditions.
     */
    data: rule_conditionsCreateManyInput | rule_conditionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rule_conditions update
   */
  export type rule_conditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * The data needed to update a rule_conditions.
     */
    data: XOR<rule_conditionsUpdateInput, rule_conditionsUncheckedUpdateInput>
    /**
     * Choose, which rule_conditions to update.
     */
    where: rule_conditionsWhereUniqueInput
  }

  /**
   * rule_conditions updateMany
   */
  export type rule_conditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rule_conditions.
     */
    data: XOR<rule_conditionsUpdateManyMutationInput, rule_conditionsUncheckedUpdateManyInput>
    /**
     * Filter which rule_conditions to update
     */
    where?: rule_conditionsWhereInput
    /**
     * Limit how many rule_conditions to update.
     */
    limit?: number
  }

  /**
   * rule_conditions updateManyAndReturn
   */
  export type rule_conditionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * The data used to update rule_conditions.
     */
    data: XOR<rule_conditionsUpdateManyMutationInput, rule_conditionsUncheckedUpdateManyInput>
    /**
     * Filter which rule_conditions to update
     */
    where?: rule_conditionsWhereInput
    /**
     * Limit how many rule_conditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rule_conditions upsert
   */
  export type rule_conditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * The filter to search for the rule_conditions to update in case it exists.
     */
    where: rule_conditionsWhereUniqueInput
    /**
     * In case the rule_conditions found by the `where` argument doesn't exist, create a new rule_conditions with this data.
     */
    create: XOR<rule_conditionsCreateInput, rule_conditionsUncheckedCreateInput>
    /**
     * In case the rule_conditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rule_conditionsUpdateInput, rule_conditionsUncheckedUpdateInput>
  }

  /**
   * rule_conditions delete
   */
  export type rule_conditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    /**
     * Filter which rule_conditions to delete.
     */
    where: rule_conditionsWhereUniqueInput
  }

  /**
   * rule_conditions deleteMany
   */
  export type rule_conditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rule_conditions to delete
     */
    where?: rule_conditionsWhereInput
    /**
     * Limit how many rule_conditions to delete.
     */
    limit?: number
  }

  /**
   * rule_conditions.rule_conditions
   */
  export type rule_conditions$rule_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    where?: rule_conditionsWhereInput
  }

  /**
   * rule_conditions.other_rule_conditions
   */
  export type rule_conditions$other_rule_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    where?: rule_conditionsWhereInput
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    cursor?: rule_conditionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rule_conditionsScalarFieldEnum | Rule_conditionsScalarFieldEnum[]
  }

  /**
   * rule_conditions.rules
   */
  export type rule_conditions$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    where?: rulesWhereInput
  }

  /**
   * rule_conditions without action
   */
  export type rule_conditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
  }


  /**
   * Model rules
   */

  export type AggregateRules = {
    _count: RulesCountAggregateOutputType | null
    _min: RulesMinAggregateOutputType | null
    _max: RulesMaxAggregateOutputType | null
  }

  export type RulesMinAggregateOutputType = {
    id: string | null
    family_id: string | null
    resource_type: string | null
    effective_date: Date | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RulesMaxAggregateOutputType = {
    id: string | null
    family_id: string | null
    resource_type: string | null
    effective_date: Date | null
    active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RulesCountAggregateOutputType = {
    id: number
    family_id: number
    resource_type: number
    effective_date: number
    active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RulesMinAggregateInputType = {
    id?: true
    family_id?: true
    resource_type?: true
    effective_date?: true
    active?: true
    created_at?: true
    updated_at?: true
  }

  export type RulesMaxAggregateInputType = {
    id?: true
    family_id?: true
    resource_type?: true
    effective_date?: true
    active?: true
    created_at?: true
    updated_at?: true
  }

  export type RulesCountAggregateInputType = {
    id?: true
    family_id?: true
    resource_type?: true
    effective_date?: true
    active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rules to aggregate.
     */
    where?: rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rules to fetch.
     */
    orderBy?: rulesOrderByWithRelationInput | rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rules
    **/
    _count?: true | RulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RulesMaxAggregateInputType
  }

  export type GetRulesAggregateType<T extends RulesAggregateArgs> = {
        [P in keyof T & keyof AggregateRules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRules[P]>
      : GetScalarType<T[P], AggregateRules[P]>
  }




  export type rulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rulesWhereInput
    orderBy?: rulesOrderByWithAggregationInput | rulesOrderByWithAggregationInput[]
    by: RulesScalarFieldEnum[] | RulesScalarFieldEnum
    having?: rulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RulesCountAggregateInputType | true
    _min?: RulesMinAggregateInputType
    _max?: RulesMaxAggregateInputType
  }

  export type RulesGroupByOutputType = {
    id: string
    family_id: string
    resource_type: string
    effective_date: Date | null
    active: boolean
    created_at: Date
    updated_at: Date
    _count: RulesCountAggregateOutputType | null
    _min: RulesMinAggregateOutputType | null
    _max: RulesMaxAggregateOutputType | null
  }

  type GetRulesGroupByPayload<T extends rulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RulesGroupByOutputType[P]>
            : GetScalarType<T[P], RulesGroupByOutputType[P]>
        }
      >
    >


  export type rulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    resource_type?: boolean
    effective_date?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    rule_actions?: boolean | rules$rule_actionsArgs<ExtArgs>
    rule_conditions?: boolean | rules$rule_conditionsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | RulesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rules"]>

  export type rulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    resource_type?: boolean
    effective_date?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rules"]>

  export type rulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    resource_type?: boolean
    effective_date?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rules"]>

  export type rulesSelectScalar = {
    id?: boolean
    family_id?: boolean
    resource_type?: boolean
    effective_date?: boolean
    active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "family_id" | "resource_type" | "effective_date" | "active" | "created_at" | "updated_at", ExtArgs["result"]["rules"]>
  export type rulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule_actions?: boolean | rules$rule_actionsArgs<ExtArgs>
    rule_conditions?: boolean | rules$rule_conditionsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | RulesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type rulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $rulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rules"
    objects: {
      rule_actions: Prisma.$rule_actionsPayload<ExtArgs>[]
      rule_conditions: Prisma.$rule_conditionsPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      family_id: string
      resource_type: string
      effective_date: Date | null
      active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["rules"]>
    composites: {}
  }

  type rulesGetPayload<S extends boolean | null | undefined | rulesDefaultArgs> = $Result.GetResult<Prisma.$rulesPayload, S>

  type rulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RulesCountAggregateInputType | true
    }

  export interface rulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rules'], meta: { name: 'rules' } }
    /**
     * Find zero or one Rules that matches the filter.
     * @param {rulesFindUniqueArgs} args - Arguments to find a Rules
     * @example
     * // Get one Rules
     * const rules = await prisma.rules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rulesFindUniqueArgs>(args: SelectSubset<T, rulesFindUniqueArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rulesFindUniqueOrThrowArgs} args - Arguments to find a Rules
     * @example
     * // Get one Rules
     * const rules = await prisma.rules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rulesFindUniqueOrThrowArgs>(args: SelectSubset<T, rulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesFindFirstArgs} args - Arguments to find a Rules
     * @example
     * // Get one Rules
     * const rules = await prisma.rules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rulesFindFirstArgs>(args?: SelectSubset<T, rulesFindFirstArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesFindFirstOrThrowArgs} args - Arguments to find a Rules
     * @example
     * // Get one Rules
     * const rules = await prisma.rules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rulesFindFirstOrThrowArgs>(args?: SelectSubset<T, rulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rules
     * const rules = await prisma.rules.findMany()
     * 
     * // Get first 10 Rules
     * const rules = await prisma.rules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rulesWithIdOnly = await prisma.rules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rulesFindManyArgs>(args?: SelectSubset<T, rulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rules.
     * @param {rulesCreateArgs} args - Arguments to create a Rules.
     * @example
     * // Create one Rules
     * const Rules = await prisma.rules.create({
     *   data: {
     *     // ... data to create a Rules
     *   }
     * })
     * 
     */
    create<T extends rulesCreateArgs>(args: SelectSubset<T, rulesCreateArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rules.
     * @param {rulesCreateManyArgs} args - Arguments to create many Rules.
     * @example
     * // Create many Rules
     * const rules = await prisma.rules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rulesCreateManyArgs>(args?: SelectSubset<T, rulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rules and returns the data saved in the database.
     * @param {rulesCreateManyAndReturnArgs} args - Arguments to create many Rules.
     * @example
     * // Create many Rules
     * const rules = await prisma.rules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rules and only return the `id`
     * const rulesWithIdOnly = await prisma.rules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rulesCreateManyAndReturnArgs>(args?: SelectSubset<T, rulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rules.
     * @param {rulesDeleteArgs} args - Arguments to delete one Rules.
     * @example
     * // Delete one Rules
     * const Rules = await prisma.rules.delete({
     *   where: {
     *     // ... filter to delete one Rules
     *   }
     * })
     * 
     */
    delete<T extends rulesDeleteArgs>(args: SelectSubset<T, rulesDeleteArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rules.
     * @param {rulesUpdateArgs} args - Arguments to update one Rules.
     * @example
     * // Update one Rules
     * const rules = await prisma.rules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rulesUpdateArgs>(args: SelectSubset<T, rulesUpdateArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rules.
     * @param {rulesDeleteManyArgs} args - Arguments to filter Rules to delete.
     * @example
     * // Delete a few Rules
     * const { count } = await prisma.rules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rulesDeleteManyArgs>(args?: SelectSubset<T, rulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rules
     * const rules = await prisma.rules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rulesUpdateManyArgs>(args: SelectSubset<T, rulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rules and returns the data updated in the database.
     * @param {rulesUpdateManyAndReturnArgs} args - Arguments to update many Rules.
     * @example
     * // Update many Rules
     * const rules = await prisma.rules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rules and only return the `id`
     * const rulesWithIdOnly = await prisma.rules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rulesUpdateManyAndReturnArgs>(args: SelectSubset<T, rulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rules.
     * @param {rulesUpsertArgs} args - Arguments to update or create a Rules.
     * @example
     * // Update or create a Rules
     * const rules = await prisma.rules.upsert({
     *   create: {
     *     // ... data to create a Rules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rules we want to update
     *   }
     * })
     */
    upsert<T extends rulesUpsertArgs>(args: SelectSubset<T, rulesUpsertArgs<ExtArgs>>): Prisma__rulesClient<$Result.GetResult<Prisma.$rulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesCountArgs} args - Arguments to filter Rules to count.
     * @example
     * // Count the number of Rules
     * const count = await prisma.rules.count({
     *   where: {
     *     // ... the filter for the Rules we want to count
     *   }
     * })
    **/
    count<T extends rulesCountArgs>(
      args?: Subset<T, rulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RulesAggregateArgs>(args: Subset<T, RulesAggregateArgs>): Prisma.PrismaPromise<GetRulesAggregateType<T>>

    /**
     * Group by Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rulesGroupByArgs['orderBy'] }
        : { orderBy?: rulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rules model
   */
  readonly fields: rulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule_actions<T extends rules$rule_actionsArgs<ExtArgs> = {}>(args?: Subset<T, rules$rule_actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_actionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rule_conditions<T extends rules$rule_conditionsArgs<ExtArgs> = {}>(args?: Subset<T, rules$rule_conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rule_conditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rules model
   */
  interface rulesFieldRefs {
    readonly id: FieldRef<"rules", 'String'>
    readonly family_id: FieldRef<"rules", 'String'>
    readonly resource_type: FieldRef<"rules", 'String'>
    readonly effective_date: FieldRef<"rules", 'DateTime'>
    readonly active: FieldRef<"rules", 'Boolean'>
    readonly created_at: FieldRef<"rules", 'DateTime'>
    readonly updated_at: FieldRef<"rules", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rules findUnique
   */
  export type rulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter, which rules to fetch.
     */
    where: rulesWhereUniqueInput
  }

  /**
   * rules findUniqueOrThrow
   */
  export type rulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter, which rules to fetch.
     */
    where: rulesWhereUniqueInput
  }

  /**
   * rules findFirst
   */
  export type rulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter, which rules to fetch.
     */
    where?: rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rules to fetch.
     */
    orderBy?: rulesOrderByWithRelationInput | rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rules.
     */
    cursor?: rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rules.
     */
    distinct?: RulesScalarFieldEnum | RulesScalarFieldEnum[]
  }

  /**
   * rules findFirstOrThrow
   */
  export type rulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter, which rules to fetch.
     */
    where?: rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rules to fetch.
     */
    orderBy?: rulesOrderByWithRelationInput | rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rules.
     */
    cursor?: rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rules.
     */
    distinct?: RulesScalarFieldEnum | RulesScalarFieldEnum[]
  }

  /**
   * rules findMany
   */
  export type rulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter, which rules to fetch.
     */
    where?: rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rules to fetch.
     */
    orderBy?: rulesOrderByWithRelationInput | rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rules.
     */
    cursor?: rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rules.
     */
    skip?: number
    distinct?: RulesScalarFieldEnum | RulesScalarFieldEnum[]
  }

  /**
   * rules create
   */
  export type rulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * The data needed to create a rules.
     */
    data: XOR<rulesCreateInput, rulesUncheckedCreateInput>
  }

  /**
   * rules createMany
   */
  export type rulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rules.
     */
    data: rulesCreateManyInput | rulesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rules createManyAndReturn
   */
  export type rulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * The data used to create many rules.
     */
    data: rulesCreateManyInput | rulesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rules update
   */
  export type rulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * The data needed to update a rules.
     */
    data: XOR<rulesUpdateInput, rulesUncheckedUpdateInput>
    /**
     * Choose, which rules to update.
     */
    where: rulesWhereUniqueInput
  }

  /**
   * rules updateMany
   */
  export type rulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rules.
     */
    data: XOR<rulesUpdateManyMutationInput, rulesUncheckedUpdateManyInput>
    /**
     * Filter which rules to update
     */
    where?: rulesWhereInput
    /**
     * Limit how many rules to update.
     */
    limit?: number
  }

  /**
   * rules updateManyAndReturn
   */
  export type rulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * The data used to update rules.
     */
    data: XOR<rulesUpdateManyMutationInput, rulesUncheckedUpdateManyInput>
    /**
     * Filter which rules to update
     */
    where?: rulesWhereInput
    /**
     * Limit how many rules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rules upsert
   */
  export type rulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * The filter to search for the rules to update in case it exists.
     */
    where: rulesWhereUniqueInput
    /**
     * In case the rules found by the `where` argument doesn't exist, create a new rules with this data.
     */
    create: XOR<rulesCreateInput, rulesUncheckedCreateInput>
    /**
     * In case the rules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rulesUpdateInput, rulesUncheckedUpdateInput>
  }

  /**
   * rules delete
   */
  export type rulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
    /**
     * Filter which rules to delete.
     */
    where: rulesWhereUniqueInput
  }

  /**
   * rules deleteMany
   */
  export type rulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rules to delete
     */
    where?: rulesWhereInput
    /**
     * Limit how many rules to delete.
     */
    limit?: number
  }

  /**
   * rules.rule_actions
   */
  export type rules$rule_actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_actions
     */
    select?: rule_actionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_actions
     */
    omit?: rule_actionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_actionsInclude<ExtArgs> | null
    where?: rule_actionsWhereInput
    orderBy?: rule_actionsOrderByWithRelationInput | rule_actionsOrderByWithRelationInput[]
    cursor?: rule_actionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rule_actionsScalarFieldEnum | Rule_actionsScalarFieldEnum[]
  }

  /**
   * rules.rule_conditions
   */
  export type rules$rule_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rule_conditions
     */
    select?: rule_conditionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rule_conditions
     */
    omit?: rule_conditionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rule_conditionsInclude<ExtArgs> | null
    where?: rule_conditionsWhereInput
    orderBy?: rule_conditionsOrderByWithRelationInput | rule_conditionsOrderByWithRelationInput[]
    cursor?: rule_conditionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rule_conditionsScalarFieldEnum | Rule_conditionsScalarFieldEnum[]
  }

  /**
   * rules without action
   */
  export type rulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rules
     */
    select?: rulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rules
     */
    omit?: rulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rulesInclude<ExtArgs> | null
  }


  /**
   * Model schema_migrations
   */

  export type AggregateSchema_migrations = {
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  export type Schema_migrationsMinAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsMaxAggregateOutputType = {
    version: string | null
  }

  export type Schema_migrationsCountAggregateOutputType = {
    version: number
    _all: number
  }


  export type Schema_migrationsMinAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsMaxAggregateInputType = {
    version?: true
  }

  export type Schema_migrationsCountAggregateInputType = {
    version?: true
    _all?: true
  }

  export type Schema_migrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to aggregate.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schema_migrations
    **/
    _count?: true | Schema_migrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Schema_migrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type GetSchema_migrationsAggregateType<T extends Schema_migrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateSchema_migrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchema_migrations[P]>
      : GetScalarType<T[P], AggregateSchema_migrations[P]>
  }




  export type schema_migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schema_migrationsWhereInput
    orderBy?: schema_migrationsOrderByWithAggregationInput | schema_migrationsOrderByWithAggregationInput[]
    by: Schema_migrationsScalarFieldEnum[] | Schema_migrationsScalarFieldEnum
    having?: schema_migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Schema_migrationsCountAggregateInputType | true
    _min?: Schema_migrationsMinAggregateInputType
    _max?: Schema_migrationsMaxAggregateInputType
  }

  export type Schema_migrationsGroupByOutputType = {
    version: string
    _count: Schema_migrationsCountAggregateOutputType | null
    _min: Schema_migrationsMinAggregateOutputType | null
    _max: Schema_migrationsMaxAggregateOutputType | null
  }

  type GetSchema_migrationsGroupByPayload<T extends schema_migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Schema_migrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Schema_migrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Schema_migrationsGroupByOutputType[P]>
        }
      >
    >


  export type schema_migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    version?: boolean
  }, ExtArgs["result"]["schema_migrations"]>

  export type schema_migrationsSelectScalar = {
    version?: boolean
  }

  export type schema_migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"version", ExtArgs["result"]["schema_migrations"]>

  export type $schema_migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "schema_migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      version: string
    }, ExtArgs["result"]["schema_migrations"]>
    composites: {}
  }

  type schema_migrationsGetPayload<S extends boolean | null | undefined | schema_migrationsDefaultArgs> = $Result.GetResult<Prisma.$schema_migrationsPayload, S>

  type schema_migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<schema_migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Schema_migrationsCountAggregateInputType | true
    }

  export interface schema_migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['schema_migrations'], meta: { name: 'schema_migrations' } }
    /**
     * Find zero or one Schema_migrations that matches the filter.
     * @param {schema_migrationsFindUniqueArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends schema_migrationsFindUniqueArgs>(args: SelectSubset<T, schema_migrationsFindUniqueArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schema_migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {schema_migrationsFindUniqueOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends schema_migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, schema_migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends schema_migrationsFindFirstArgs>(args?: SelectSubset<T, schema_migrationsFindFirstArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schema_migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindFirstOrThrowArgs} args - Arguments to find a Schema_migrations
     * @example
     * // Get one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends schema_migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, schema_migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schema_migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany()
     * 
     * // Get first 10 Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.findMany({ take: 10 })
     * 
     * // Only select the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.findMany({ select: { version: true } })
     * 
     */
    findMany<T extends schema_migrationsFindManyArgs>(args?: SelectSubset<T, schema_migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schema_migrations.
     * @param {schema_migrationsCreateArgs} args - Arguments to create a Schema_migrations.
     * @example
     * // Create one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.create({
     *   data: {
     *     // ... data to create a Schema_migrations
     *   }
     * })
     * 
     */
    create<T extends schema_migrationsCreateArgs>(args: SelectSubset<T, schema_migrationsCreateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schema_migrations.
     * @param {schema_migrationsCreateManyArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends schema_migrationsCreateManyArgs>(args?: SelectSubset<T, schema_migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schema_migrations and returns the data saved in the database.
     * @param {schema_migrationsCreateManyAndReturnArgs} args - Arguments to create many Schema_migrations.
     * @example
     * // Create many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schema_migrations and only return the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.createManyAndReturn({
     *   select: { version: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends schema_migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, schema_migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schema_migrations.
     * @param {schema_migrationsDeleteArgs} args - Arguments to delete one Schema_migrations.
     * @example
     * // Delete one Schema_migrations
     * const Schema_migrations = await prisma.schema_migrations.delete({
     *   where: {
     *     // ... filter to delete one Schema_migrations
     *   }
     * })
     * 
     */
    delete<T extends schema_migrationsDeleteArgs>(args: SelectSubset<T, schema_migrationsDeleteArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schema_migrations.
     * @param {schema_migrationsUpdateArgs} args - Arguments to update one Schema_migrations.
     * @example
     * // Update one Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends schema_migrationsUpdateArgs>(args: SelectSubset<T, schema_migrationsUpdateArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schema_migrations.
     * @param {schema_migrationsDeleteManyArgs} args - Arguments to filter Schema_migrations to delete.
     * @example
     * // Delete a few Schema_migrations
     * const { count } = await prisma.schema_migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends schema_migrationsDeleteManyArgs>(args?: SelectSubset<T, schema_migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends schema_migrationsUpdateManyArgs>(args: SelectSubset<T, schema_migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schema_migrations and returns the data updated in the database.
     * @param {schema_migrationsUpdateManyAndReturnArgs} args - Arguments to update many Schema_migrations.
     * @example
     * // Update many Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schema_migrations and only return the `version`
     * const schema_migrationsWithVersionOnly = await prisma.schema_migrations.updateManyAndReturn({
     *   select: { version: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends schema_migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, schema_migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schema_migrations.
     * @param {schema_migrationsUpsertArgs} args - Arguments to update or create a Schema_migrations.
     * @example
     * // Update or create a Schema_migrations
     * const schema_migrations = await prisma.schema_migrations.upsert({
     *   create: {
     *     // ... data to create a Schema_migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schema_migrations we want to update
     *   }
     * })
     */
    upsert<T extends schema_migrationsUpsertArgs>(args: SelectSubset<T, schema_migrationsUpsertArgs<ExtArgs>>): Prisma__schema_migrationsClient<$Result.GetResult<Prisma.$schema_migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsCountArgs} args - Arguments to filter Schema_migrations to count.
     * @example
     * // Count the number of Schema_migrations
     * const count = await prisma.schema_migrations.count({
     *   where: {
     *     // ... the filter for the Schema_migrations we want to count
     *   }
     * })
    **/
    count<T extends schema_migrationsCountArgs>(
      args?: Subset<T, schema_migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Schema_migrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Schema_migrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Schema_migrationsAggregateArgs>(args: Subset<T, Schema_migrationsAggregateArgs>): Prisma.PrismaPromise<GetSchema_migrationsAggregateType<T>>

    /**
     * Group by Schema_migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schema_migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schema_migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schema_migrationsGroupByArgs['orderBy'] }
        : { orderBy?: schema_migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schema_migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchema_migrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the schema_migrations model
   */
  readonly fields: schema_migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for schema_migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schema_migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the schema_migrations model
   */
  interface schema_migrationsFieldRefs {
    readonly version: FieldRef<"schema_migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * schema_migrations findUnique
   */
  export type schema_migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findUniqueOrThrow
   */
  export type schema_migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations findFirst
   */
  export type schema_migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findFirstOrThrow
   */
  export type schema_migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schema_migrations.
     */
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations findMany
   */
  export type schema_migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter, which schema_migrations to fetch.
     */
    where?: schema_migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schema_migrations to fetch.
     */
    orderBy?: schema_migrationsOrderByWithRelationInput | schema_migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schema_migrations.
     */
    cursor?: schema_migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schema_migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schema_migrations.
     */
    skip?: number
    distinct?: Schema_migrationsScalarFieldEnum | Schema_migrationsScalarFieldEnum[]
  }

  /**
   * schema_migrations create
   */
  export type schema_migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a schema_migrations.
     */
    data: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
  }

  /**
   * schema_migrations createMany
   */
  export type schema_migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations createManyAndReturn
   */
  export type schema_migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many schema_migrations.
     */
    data: schema_migrationsCreateManyInput | schema_migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * schema_migrations update
   */
  export type schema_migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a schema_migrations.
     */
    data: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
    /**
     * Choose, which schema_migrations to update.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations updateMany
   */
  export type schema_migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schema_migrations.
     */
    data: XOR<schema_migrationsUpdateManyMutationInput, schema_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which schema_migrations to update
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to update.
     */
    limit?: number
  }

  /**
   * schema_migrations updateManyAndReturn
   */
  export type schema_migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The data used to update schema_migrations.
     */
    data: XOR<schema_migrationsUpdateManyMutationInput, schema_migrationsUncheckedUpdateManyInput>
    /**
     * Filter which schema_migrations to update
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to update.
     */
    limit?: number
  }

  /**
   * schema_migrations upsert
   */
  export type schema_migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the schema_migrations to update in case it exists.
     */
    where: schema_migrationsWhereUniqueInput
    /**
     * In case the schema_migrations found by the `where` argument doesn't exist, create a new schema_migrations with this data.
     */
    create: XOR<schema_migrationsCreateInput, schema_migrationsUncheckedCreateInput>
    /**
     * In case the schema_migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schema_migrationsUpdateInput, schema_migrationsUncheckedUpdateInput>
  }

  /**
   * schema_migrations delete
   */
  export type schema_migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
    /**
     * Filter which schema_migrations to delete.
     */
    where: schema_migrationsWhereUniqueInput
  }

  /**
   * schema_migrations deleteMany
   */
  export type schema_migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schema_migrations to delete
     */
    where?: schema_migrationsWhereInput
    /**
     * Limit how many schema_migrations to delete.
     */
    limit?: number
  }

  /**
   * schema_migrations without action
   */
  export type schema_migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the schema_migrations
     */
    select?: schema_migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the schema_migrations
     */
    omit?: schema_migrationsOmit<ExtArgs> | null
  }


  /**
   * Model securities
   */

  export type AggregateSecurities = {
    _count: SecuritiesCountAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  export type SecuritiesMinAggregateOutputType = {
    id: string | null
    ticker: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    country_code: string | null
    exchange_mic: string | null
    exchange_acronym: string | null
    logo_url: string | null
    exchange_operating_mic: string | null
  }

  export type SecuritiesMaxAggregateOutputType = {
    id: string | null
    ticker: string | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
    country_code: string | null
    exchange_mic: string | null
    exchange_acronym: string | null
    logo_url: string | null
    exchange_operating_mic: string | null
  }

  export type SecuritiesCountAggregateOutputType = {
    id: number
    ticker: number
    name: number
    created_at: number
    updated_at: number
    country_code: number
    exchange_mic: number
    exchange_acronym: number
    logo_url: number
    exchange_operating_mic: number
    _all: number
  }


  export type SecuritiesMinAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    created_at?: true
    updated_at?: true
    country_code?: true
    exchange_mic?: true
    exchange_acronym?: true
    logo_url?: true
    exchange_operating_mic?: true
  }

  export type SecuritiesMaxAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    created_at?: true
    updated_at?: true
    country_code?: true
    exchange_mic?: true
    exchange_acronym?: true
    logo_url?: true
    exchange_operating_mic?: true
  }

  export type SecuritiesCountAggregateInputType = {
    id?: true
    ticker?: true
    name?: true
    created_at?: true
    updated_at?: true
    country_code?: true
    exchange_mic?: true
    exchange_acronym?: true
    logo_url?: true
    exchange_operating_mic?: true
    _all?: true
  }

  export type SecuritiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which securities to aggregate.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned securities
    **/
    _count?: true | SecuritiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritiesMaxAggregateInputType
  }

  export type GetSecuritiesAggregateType<T extends SecuritiesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurities[P]>
      : GetScalarType<T[P], AggregateSecurities[P]>
  }




  export type securitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: securitiesWhereInput
    orderBy?: securitiesOrderByWithAggregationInput | securitiesOrderByWithAggregationInput[]
    by: SecuritiesScalarFieldEnum[] | SecuritiesScalarFieldEnum
    having?: securitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritiesCountAggregateInputType | true
    _min?: SecuritiesMinAggregateInputType
    _max?: SecuritiesMaxAggregateInputType
  }

  export type SecuritiesGroupByOutputType = {
    id: string
    ticker: string
    name: string | null
    created_at: Date
    updated_at: Date
    country_code: string | null
    exchange_mic: string | null
    exchange_acronym: string | null
    logo_url: string | null
    exchange_operating_mic: string | null
    _count: SecuritiesCountAggregateOutputType | null
    _min: SecuritiesMinAggregateOutputType | null
    _max: SecuritiesMaxAggregateOutputType | null
  }

  type GetSecuritiesGroupByPayload<T extends securitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecuritiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritiesGroupByOutputType[P]>
        }
      >
    >


  export type securitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    country_code?: boolean
    exchange_mic?: boolean
    exchange_acronym?: boolean
    logo_url?: boolean
    exchange_operating_mic?: boolean
    holdings?: boolean | securities$holdingsArgs<ExtArgs>
    security_prices?: boolean | securities$security_pricesArgs<ExtArgs>
    trades?: boolean | securities$tradesArgs<ExtArgs>
    _count?: boolean | SecuritiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["securities"]>

  export type securitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    country_code?: boolean
    exchange_mic?: boolean
    exchange_acronym?: boolean
    logo_url?: boolean
    exchange_operating_mic?: boolean
  }, ExtArgs["result"]["securities"]>

  export type securitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticker?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    country_code?: boolean
    exchange_mic?: boolean
    exchange_acronym?: boolean
    logo_url?: boolean
    exchange_operating_mic?: boolean
  }, ExtArgs["result"]["securities"]>

  export type securitiesSelectScalar = {
    id?: boolean
    ticker?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    country_code?: boolean
    exchange_mic?: boolean
    exchange_acronym?: boolean
    logo_url?: boolean
    exchange_operating_mic?: boolean
  }

  export type securitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticker" | "name" | "created_at" | "updated_at" | "country_code" | "exchange_mic" | "exchange_acronym" | "logo_url" | "exchange_operating_mic", ExtArgs["result"]["securities"]>
  export type securitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    holdings?: boolean | securities$holdingsArgs<ExtArgs>
    security_prices?: boolean | securities$security_pricesArgs<ExtArgs>
    trades?: boolean | securities$tradesArgs<ExtArgs>
    _count?: boolean | SecuritiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type securitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type securitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $securitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "securities"
    objects: {
      holdings: Prisma.$holdingsPayload<ExtArgs>[]
      security_prices: Prisma.$security_pricesPayload<ExtArgs>[]
      trades: Prisma.$tradesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticker: string
      name: string | null
      created_at: Date
      updated_at: Date
      country_code: string | null
      exchange_mic: string | null
      exchange_acronym: string | null
      logo_url: string | null
      exchange_operating_mic: string | null
    }, ExtArgs["result"]["securities"]>
    composites: {}
  }

  type securitiesGetPayload<S extends boolean | null | undefined | securitiesDefaultArgs> = $Result.GetResult<Prisma.$securitiesPayload, S>

  type securitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<securitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecuritiesCountAggregateInputType | true
    }

  export interface securitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['securities'], meta: { name: 'securities' } }
    /**
     * Find zero or one Securities that matches the filter.
     * @param {securitiesFindUniqueArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends securitiesFindUniqueArgs>(args: SelectSubset<T, securitiesFindUniqueArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Securities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {securitiesFindUniqueOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends securitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, securitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindFirstArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends securitiesFindFirstArgs>(args?: SelectSubset<T, securitiesFindFirstArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Securities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindFirstOrThrowArgs} args - Arguments to find a Securities
     * @example
     * // Get one Securities
     * const securities = await prisma.securities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends securitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, securitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Securities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Securities
     * const securities = await prisma.securities.findMany()
     * 
     * // Get first 10 Securities
     * const securities = await prisma.securities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitiesWithIdOnly = await prisma.securities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends securitiesFindManyArgs>(args?: SelectSubset<T, securitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Securities.
     * @param {securitiesCreateArgs} args - Arguments to create a Securities.
     * @example
     * // Create one Securities
     * const Securities = await prisma.securities.create({
     *   data: {
     *     // ... data to create a Securities
     *   }
     * })
     * 
     */
    create<T extends securitiesCreateArgs>(args: SelectSubset<T, securitiesCreateArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Securities.
     * @param {securitiesCreateManyArgs} args - Arguments to create many Securities.
     * @example
     * // Create many Securities
     * const securities = await prisma.securities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends securitiesCreateManyArgs>(args?: SelectSubset<T, securitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Securities and returns the data saved in the database.
     * @param {securitiesCreateManyAndReturnArgs} args - Arguments to create many Securities.
     * @example
     * // Create many Securities
     * const securities = await prisma.securities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Securities and only return the `id`
     * const securitiesWithIdOnly = await prisma.securities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends securitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, securitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Securities.
     * @param {securitiesDeleteArgs} args - Arguments to delete one Securities.
     * @example
     * // Delete one Securities
     * const Securities = await prisma.securities.delete({
     *   where: {
     *     // ... filter to delete one Securities
     *   }
     * })
     * 
     */
    delete<T extends securitiesDeleteArgs>(args: SelectSubset<T, securitiesDeleteArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Securities.
     * @param {securitiesUpdateArgs} args - Arguments to update one Securities.
     * @example
     * // Update one Securities
     * const securities = await prisma.securities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends securitiesUpdateArgs>(args: SelectSubset<T, securitiesUpdateArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Securities.
     * @param {securitiesDeleteManyArgs} args - Arguments to filter Securities to delete.
     * @example
     * // Delete a few Securities
     * const { count } = await prisma.securities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends securitiesDeleteManyArgs>(args?: SelectSubset<T, securitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Securities
     * const securities = await prisma.securities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends securitiesUpdateManyArgs>(args: SelectSubset<T, securitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Securities and returns the data updated in the database.
     * @param {securitiesUpdateManyAndReturnArgs} args - Arguments to update many Securities.
     * @example
     * // Update many Securities
     * const securities = await prisma.securities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Securities and only return the `id`
     * const securitiesWithIdOnly = await prisma.securities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends securitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, securitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Securities.
     * @param {securitiesUpsertArgs} args - Arguments to update or create a Securities.
     * @example
     * // Update or create a Securities
     * const securities = await prisma.securities.upsert({
     *   create: {
     *     // ... data to create a Securities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Securities we want to update
     *   }
     * })
     */
    upsert<T extends securitiesUpsertArgs>(args: SelectSubset<T, securitiesUpsertArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesCountArgs} args - Arguments to filter Securities to count.
     * @example
     * // Count the number of Securities
     * const count = await prisma.securities.count({
     *   where: {
     *     // ... the filter for the Securities we want to count
     *   }
     * })
    **/
    count<T extends securitiesCountArgs>(
      args?: Subset<T, securitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritiesAggregateArgs>(args: Subset<T, SecuritiesAggregateArgs>): Prisma.PrismaPromise<GetSecuritiesAggregateType<T>>

    /**
     * Group by Securities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {securitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends securitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: securitiesGroupByArgs['orderBy'] }
        : { orderBy?: securitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, securitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the securities model
   */
  readonly fields: securitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for securities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__securitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    holdings<T extends securities$holdingsArgs<ExtArgs> = {}>(args?: Subset<T, securities$holdingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holdingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    security_prices<T extends securities$security_pricesArgs<ExtArgs> = {}>(args?: Subset<T, securities$security_pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trades<T extends securities$tradesArgs<ExtArgs> = {}>(args?: Subset<T, securities$tradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the securities model
   */
  interface securitiesFieldRefs {
    readonly id: FieldRef<"securities", 'String'>
    readonly ticker: FieldRef<"securities", 'String'>
    readonly name: FieldRef<"securities", 'String'>
    readonly created_at: FieldRef<"securities", 'DateTime'>
    readonly updated_at: FieldRef<"securities", 'DateTime'>
    readonly country_code: FieldRef<"securities", 'String'>
    readonly exchange_mic: FieldRef<"securities", 'String'>
    readonly exchange_acronym: FieldRef<"securities", 'String'>
    readonly logo_url: FieldRef<"securities", 'String'>
    readonly exchange_operating_mic: FieldRef<"securities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * securities findUnique
   */
  export type securitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities findUniqueOrThrow
   */
  export type securitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities findFirst
   */
  export type securitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of securities.
     */
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities findFirstOrThrow
   */
  export type securitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of securities.
     */
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities findMany
   */
  export type securitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter, which securities to fetch.
     */
    where?: securitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of securities to fetch.
     */
    orderBy?: securitiesOrderByWithRelationInput | securitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing securities.
     */
    cursor?: securitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` securities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` securities.
     */
    skip?: number
    distinct?: SecuritiesScalarFieldEnum | SecuritiesScalarFieldEnum[]
  }

  /**
   * securities create
   */
  export type securitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a securities.
     */
    data: XOR<securitiesCreateInput, securitiesUncheckedCreateInput>
  }

  /**
   * securities createMany
   */
  export type securitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many securities.
     */
    data: securitiesCreateManyInput | securitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * securities createManyAndReturn
   */
  export type securitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * The data used to create many securities.
     */
    data: securitiesCreateManyInput | securitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * securities update
   */
  export type securitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a securities.
     */
    data: XOR<securitiesUpdateInput, securitiesUncheckedUpdateInput>
    /**
     * Choose, which securities to update.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities updateMany
   */
  export type securitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update securities.
     */
    data: XOR<securitiesUpdateManyMutationInput, securitiesUncheckedUpdateManyInput>
    /**
     * Filter which securities to update
     */
    where?: securitiesWhereInput
    /**
     * Limit how many securities to update.
     */
    limit?: number
  }

  /**
   * securities updateManyAndReturn
   */
  export type securitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * The data used to update securities.
     */
    data: XOR<securitiesUpdateManyMutationInput, securitiesUncheckedUpdateManyInput>
    /**
     * Filter which securities to update
     */
    where?: securitiesWhereInput
    /**
     * Limit how many securities to update.
     */
    limit?: number
  }

  /**
   * securities upsert
   */
  export type securitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the securities to update in case it exists.
     */
    where: securitiesWhereUniqueInput
    /**
     * In case the securities found by the `where` argument doesn't exist, create a new securities with this data.
     */
    create: XOR<securitiesCreateInput, securitiesUncheckedCreateInput>
    /**
     * In case the securities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<securitiesUpdateInput, securitiesUncheckedUpdateInput>
  }

  /**
   * securities delete
   */
  export type securitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    /**
     * Filter which securities to delete.
     */
    where: securitiesWhereUniqueInput
  }

  /**
   * securities deleteMany
   */
  export type securitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which securities to delete
     */
    where?: securitiesWhereInput
    /**
     * Limit how many securities to delete.
     */
    limit?: number
  }

  /**
   * securities.holdings
   */
  export type securities$holdingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holdings
     */
    select?: holdingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the holdings
     */
    omit?: holdingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: holdingsInclude<ExtArgs> | null
    where?: holdingsWhereInput
    orderBy?: holdingsOrderByWithRelationInput | holdingsOrderByWithRelationInput[]
    cursor?: holdingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HoldingsScalarFieldEnum | HoldingsScalarFieldEnum[]
  }

  /**
   * securities.security_prices
   */
  export type securities$security_pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    where?: security_pricesWhereInput
    orderBy?: security_pricesOrderByWithRelationInput | security_pricesOrderByWithRelationInput[]
    cursor?: security_pricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Security_pricesScalarFieldEnum | Security_pricesScalarFieldEnum[]
  }

  /**
   * securities.trades
   */
  export type securities$tradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    where?: tradesWhereInput
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    cursor?: tradesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * securities without action
   */
  export type securitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
  }


  /**
   * Model security_prices
   */

  export type AggregateSecurity_prices = {
    _count: Security_pricesCountAggregateOutputType | null
    _avg: Security_pricesAvgAggregateOutputType | null
    _sum: Security_pricesSumAggregateOutputType | null
    _min: Security_pricesMinAggregateOutputType | null
    _max: Security_pricesMaxAggregateOutputType | null
  }

  export type Security_pricesAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type Security_pricesSumAggregateOutputType = {
    price: Decimal | null
  }

  export type Security_pricesMinAggregateOutputType = {
    id: string | null
    date: Date | null
    price: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    security_id: string | null
  }

  export type Security_pricesMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    price: Decimal | null
    currency: string | null
    created_at: Date | null
    updated_at: Date | null
    security_id: string | null
  }

  export type Security_pricesCountAggregateOutputType = {
    id: number
    date: number
    price: number
    currency: number
    created_at: number
    updated_at: number
    security_id: number
    _all: number
  }


  export type Security_pricesAvgAggregateInputType = {
    price?: true
  }

  export type Security_pricesSumAggregateInputType = {
    price?: true
  }

  export type Security_pricesMinAggregateInputType = {
    id?: true
    date?: true
    price?: true
    currency?: true
    created_at?: true
    updated_at?: true
    security_id?: true
  }

  export type Security_pricesMaxAggregateInputType = {
    id?: true
    date?: true
    price?: true
    currency?: true
    created_at?: true
    updated_at?: true
    security_id?: true
  }

  export type Security_pricesCountAggregateInputType = {
    id?: true
    date?: true
    price?: true
    currency?: true
    created_at?: true
    updated_at?: true
    security_id?: true
    _all?: true
  }

  export type Security_pricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which security_prices to aggregate.
     */
    where?: security_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_prices to fetch.
     */
    orderBy?: security_pricesOrderByWithRelationInput | security_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: security_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned security_prices
    **/
    _count?: true | Security_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Security_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Security_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Security_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Security_pricesMaxAggregateInputType
  }

  export type GetSecurity_pricesAggregateType<T extends Security_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurity_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurity_prices[P]>
      : GetScalarType<T[P], AggregateSecurity_prices[P]>
  }




  export type security_pricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: security_pricesWhereInput
    orderBy?: security_pricesOrderByWithAggregationInput | security_pricesOrderByWithAggregationInput[]
    by: Security_pricesScalarFieldEnum[] | Security_pricesScalarFieldEnum
    having?: security_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Security_pricesCountAggregateInputType | true
    _avg?: Security_pricesAvgAggregateInputType
    _sum?: Security_pricesSumAggregateInputType
    _min?: Security_pricesMinAggregateInputType
    _max?: Security_pricesMaxAggregateInputType
  }

  export type Security_pricesGroupByOutputType = {
    id: string
    date: Date
    price: Decimal
    currency: string
    created_at: Date
    updated_at: Date
    security_id: string | null
    _count: Security_pricesCountAggregateOutputType | null
    _avg: Security_pricesAvgAggregateOutputType | null
    _sum: Security_pricesSumAggregateOutputType | null
    _min: Security_pricesMinAggregateOutputType | null
    _max: Security_pricesMaxAggregateOutputType | null
  }

  type GetSecurity_pricesGroupByPayload<T extends security_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Security_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Security_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Security_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Security_pricesGroupByOutputType[P]>
        }
      >
    >


  export type security_pricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    security_id?: boolean
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }, ExtArgs["result"]["security_prices"]>

  export type security_pricesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    security_id?: boolean
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }, ExtArgs["result"]["security_prices"]>

  export type security_pricesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    security_id?: boolean
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }, ExtArgs["result"]["security_prices"]>

  export type security_pricesSelectScalar = {
    id?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    created_at?: boolean
    updated_at?: boolean
    security_id?: boolean
  }

  export type security_pricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "price" | "currency" | "created_at" | "updated_at" | "security_id", ExtArgs["result"]["security_prices"]>
  export type security_pricesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }
  export type security_pricesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }
  export type security_pricesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | security_prices$securitiesArgs<ExtArgs>
  }

  export type $security_pricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "security_prices"
    objects: {
      securities: Prisma.$securitiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      price: Prisma.Decimal
      currency: string
      created_at: Date
      updated_at: Date
      security_id: string | null
    }, ExtArgs["result"]["security_prices"]>
    composites: {}
  }

  type security_pricesGetPayload<S extends boolean | null | undefined | security_pricesDefaultArgs> = $Result.GetResult<Prisma.$security_pricesPayload, S>

  type security_pricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<security_pricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Security_pricesCountAggregateInputType | true
    }

  export interface security_pricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['security_prices'], meta: { name: 'security_prices' } }
    /**
     * Find zero or one Security_prices that matches the filter.
     * @param {security_pricesFindUniqueArgs} args - Arguments to find a Security_prices
     * @example
     * // Get one Security_prices
     * const security_prices = await prisma.security_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends security_pricesFindUniqueArgs>(args: SelectSubset<T, security_pricesFindUniqueArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Security_prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {security_pricesFindUniqueOrThrowArgs} args - Arguments to find a Security_prices
     * @example
     * // Get one Security_prices
     * const security_prices = await prisma.security_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends security_pricesFindUniqueOrThrowArgs>(args: SelectSubset<T, security_pricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Security_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesFindFirstArgs} args - Arguments to find a Security_prices
     * @example
     * // Get one Security_prices
     * const security_prices = await prisma.security_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends security_pricesFindFirstArgs>(args?: SelectSubset<T, security_pricesFindFirstArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Security_prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesFindFirstOrThrowArgs} args - Arguments to find a Security_prices
     * @example
     * // Get one Security_prices
     * const security_prices = await prisma.security_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends security_pricesFindFirstOrThrowArgs>(args?: SelectSubset<T, security_pricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Security_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Security_prices
     * const security_prices = await prisma.security_prices.findMany()
     * 
     * // Get first 10 Security_prices
     * const security_prices = await prisma.security_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const security_pricesWithIdOnly = await prisma.security_prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends security_pricesFindManyArgs>(args?: SelectSubset<T, security_pricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Security_prices.
     * @param {security_pricesCreateArgs} args - Arguments to create a Security_prices.
     * @example
     * // Create one Security_prices
     * const Security_prices = await prisma.security_prices.create({
     *   data: {
     *     // ... data to create a Security_prices
     *   }
     * })
     * 
     */
    create<T extends security_pricesCreateArgs>(args: SelectSubset<T, security_pricesCreateArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Security_prices.
     * @param {security_pricesCreateManyArgs} args - Arguments to create many Security_prices.
     * @example
     * // Create many Security_prices
     * const security_prices = await prisma.security_prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends security_pricesCreateManyArgs>(args?: SelectSubset<T, security_pricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Security_prices and returns the data saved in the database.
     * @param {security_pricesCreateManyAndReturnArgs} args - Arguments to create many Security_prices.
     * @example
     * // Create many Security_prices
     * const security_prices = await prisma.security_prices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Security_prices and only return the `id`
     * const security_pricesWithIdOnly = await prisma.security_prices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends security_pricesCreateManyAndReturnArgs>(args?: SelectSubset<T, security_pricesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Security_prices.
     * @param {security_pricesDeleteArgs} args - Arguments to delete one Security_prices.
     * @example
     * // Delete one Security_prices
     * const Security_prices = await prisma.security_prices.delete({
     *   where: {
     *     // ... filter to delete one Security_prices
     *   }
     * })
     * 
     */
    delete<T extends security_pricesDeleteArgs>(args: SelectSubset<T, security_pricesDeleteArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Security_prices.
     * @param {security_pricesUpdateArgs} args - Arguments to update one Security_prices.
     * @example
     * // Update one Security_prices
     * const security_prices = await prisma.security_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends security_pricesUpdateArgs>(args: SelectSubset<T, security_pricesUpdateArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Security_prices.
     * @param {security_pricesDeleteManyArgs} args - Arguments to filter Security_prices to delete.
     * @example
     * // Delete a few Security_prices
     * const { count } = await prisma.security_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends security_pricesDeleteManyArgs>(args?: SelectSubset<T, security_pricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Security_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Security_prices
     * const security_prices = await prisma.security_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends security_pricesUpdateManyArgs>(args: SelectSubset<T, security_pricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Security_prices and returns the data updated in the database.
     * @param {security_pricesUpdateManyAndReturnArgs} args - Arguments to update many Security_prices.
     * @example
     * // Update many Security_prices
     * const security_prices = await prisma.security_prices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Security_prices and only return the `id`
     * const security_pricesWithIdOnly = await prisma.security_prices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends security_pricesUpdateManyAndReturnArgs>(args: SelectSubset<T, security_pricesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Security_prices.
     * @param {security_pricesUpsertArgs} args - Arguments to update or create a Security_prices.
     * @example
     * // Update or create a Security_prices
     * const security_prices = await prisma.security_prices.upsert({
     *   create: {
     *     // ... data to create a Security_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Security_prices we want to update
     *   }
     * })
     */
    upsert<T extends security_pricesUpsertArgs>(args: SelectSubset<T, security_pricesUpsertArgs<ExtArgs>>): Prisma__security_pricesClient<$Result.GetResult<Prisma.$security_pricesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Security_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesCountArgs} args - Arguments to filter Security_prices to count.
     * @example
     * // Count the number of Security_prices
     * const count = await prisma.security_prices.count({
     *   where: {
     *     // ... the filter for the Security_prices we want to count
     *   }
     * })
    **/
    count<T extends security_pricesCountArgs>(
      args?: Subset<T, security_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Security_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Security_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Security_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Security_pricesAggregateArgs>(args: Subset<T, Security_pricesAggregateArgs>): Prisma.PrismaPromise<GetSecurity_pricesAggregateType<T>>

    /**
     * Group by Security_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {security_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends security_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: security_pricesGroupByArgs['orderBy'] }
        : { orderBy?: security_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, security_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurity_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the security_prices model
   */
  readonly fields: security_pricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for security_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__security_pricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    securities<T extends security_prices$securitiesArgs<ExtArgs> = {}>(args?: Subset<T, security_prices$securitiesArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the security_prices model
   */
  interface security_pricesFieldRefs {
    readonly id: FieldRef<"security_prices", 'String'>
    readonly date: FieldRef<"security_prices", 'DateTime'>
    readonly price: FieldRef<"security_prices", 'Decimal'>
    readonly currency: FieldRef<"security_prices", 'String'>
    readonly created_at: FieldRef<"security_prices", 'DateTime'>
    readonly updated_at: FieldRef<"security_prices", 'DateTime'>
    readonly security_id: FieldRef<"security_prices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * security_prices findUnique
   */
  export type security_pricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter, which security_prices to fetch.
     */
    where: security_pricesWhereUniqueInput
  }

  /**
   * security_prices findUniqueOrThrow
   */
  export type security_pricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter, which security_prices to fetch.
     */
    where: security_pricesWhereUniqueInput
  }

  /**
   * security_prices findFirst
   */
  export type security_pricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter, which security_prices to fetch.
     */
    where?: security_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_prices to fetch.
     */
    orderBy?: security_pricesOrderByWithRelationInput | security_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for security_prices.
     */
    cursor?: security_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of security_prices.
     */
    distinct?: Security_pricesScalarFieldEnum | Security_pricesScalarFieldEnum[]
  }

  /**
   * security_prices findFirstOrThrow
   */
  export type security_pricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter, which security_prices to fetch.
     */
    where?: security_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_prices to fetch.
     */
    orderBy?: security_pricesOrderByWithRelationInput | security_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for security_prices.
     */
    cursor?: security_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of security_prices.
     */
    distinct?: Security_pricesScalarFieldEnum | Security_pricesScalarFieldEnum[]
  }

  /**
   * security_prices findMany
   */
  export type security_pricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter, which security_prices to fetch.
     */
    where?: security_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of security_prices to fetch.
     */
    orderBy?: security_pricesOrderByWithRelationInput | security_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing security_prices.
     */
    cursor?: security_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` security_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` security_prices.
     */
    skip?: number
    distinct?: Security_pricesScalarFieldEnum | Security_pricesScalarFieldEnum[]
  }

  /**
   * security_prices create
   */
  export type security_pricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * The data needed to create a security_prices.
     */
    data: XOR<security_pricesCreateInput, security_pricesUncheckedCreateInput>
  }

  /**
   * security_prices createMany
   */
  export type security_pricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many security_prices.
     */
    data: security_pricesCreateManyInput | security_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * security_prices createManyAndReturn
   */
  export type security_pricesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * The data used to create many security_prices.
     */
    data: security_pricesCreateManyInput | security_pricesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * security_prices update
   */
  export type security_pricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * The data needed to update a security_prices.
     */
    data: XOR<security_pricesUpdateInput, security_pricesUncheckedUpdateInput>
    /**
     * Choose, which security_prices to update.
     */
    where: security_pricesWhereUniqueInput
  }

  /**
   * security_prices updateMany
   */
  export type security_pricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update security_prices.
     */
    data: XOR<security_pricesUpdateManyMutationInput, security_pricesUncheckedUpdateManyInput>
    /**
     * Filter which security_prices to update
     */
    where?: security_pricesWhereInput
    /**
     * Limit how many security_prices to update.
     */
    limit?: number
  }

  /**
   * security_prices updateManyAndReturn
   */
  export type security_pricesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * The data used to update security_prices.
     */
    data: XOR<security_pricesUpdateManyMutationInput, security_pricesUncheckedUpdateManyInput>
    /**
     * Filter which security_prices to update
     */
    where?: security_pricesWhereInput
    /**
     * Limit how many security_prices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * security_prices upsert
   */
  export type security_pricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * The filter to search for the security_prices to update in case it exists.
     */
    where: security_pricesWhereUniqueInput
    /**
     * In case the security_prices found by the `where` argument doesn't exist, create a new security_prices with this data.
     */
    create: XOR<security_pricesCreateInput, security_pricesUncheckedCreateInput>
    /**
     * In case the security_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<security_pricesUpdateInput, security_pricesUncheckedUpdateInput>
  }

  /**
   * security_prices delete
   */
  export type security_pricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
    /**
     * Filter which security_prices to delete.
     */
    where: security_pricesWhereUniqueInput
  }

  /**
   * security_prices deleteMany
   */
  export type security_pricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which security_prices to delete
     */
    where?: security_pricesWhereInput
    /**
     * Limit how many security_prices to delete.
     */
    limit?: number
  }

  /**
   * security_prices.securities
   */
  export type security_prices$securitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the securities
     */
    select?: securitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the securities
     */
    omit?: securitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: securitiesInclude<ExtArgs> | null
    where?: securitiesWhereInput
  }

  /**
   * security_prices without action
   */
  export type security_pricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the security_prices
     */
    select?: security_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the security_prices
     */
    omit?: security_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: security_pricesInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    user_agent: string | null
    ip_address: string | null
    created_at: Date | null
    updated_at: Date | null
    active_impersonator_session_id: string | null
    subscribed_at: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    user_agent: string | null
    ip_address: string | null
    created_at: Date | null
    updated_at: Date | null
    active_impersonator_session_id: string | null
    subscribed_at: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    user_agent: number
    ip_address: number
    created_at: number
    updated_at: number
    active_impersonator_session_id: number
    subscribed_at: number
    prev_transaction_page_params: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    updated_at?: true
    active_impersonator_session_id?: true
    subscribed_at?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    updated_at?: true
    active_impersonator_session_id?: true
    subscribed_at?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    user_agent?: true
    ip_address?: true
    created_at?: true
    updated_at?: true
    active_impersonator_session_id?: true
    subscribed_at?: true
    prev_transaction_page_params?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    user_id: string
    user_agent: string | null
    ip_address: string | null
    created_at: Date
    updated_at: Date
    active_impersonator_session_id: string | null
    subscribed_at: Date | null
    prev_transaction_page_params: JsonValue | null
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    active_impersonator_session_id?: boolean
    subscribed_at?: boolean
    prev_transaction_page_params?: boolean
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    active_impersonator_session_id?: boolean
    subscribed_at?: boolean
    prev_transaction_page_params?: boolean
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    active_impersonator_session_id?: boolean
    subscribed_at?: boolean
    prev_transaction_page_params?: boolean
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    user_agent?: boolean
    ip_address?: boolean
    created_at?: boolean
    updated_at?: boolean
    active_impersonator_session_id?: boolean
    subscribed_at?: boolean
    prev_transaction_page_params?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "user_agent" | "ip_address" | "created_at" | "updated_at" | "active_impersonator_session_id" | "subscribed_at" | "prev_transaction_page_params", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    impersonation_sessions?: boolean | sessions$impersonation_sessionsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      impersonation_sessions: Prisma.$impersonation_sessionsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      user_agent: string | null
      ip_address: string | null
      created_at: Date
      updated_at: Date
      active_impersonator_session_id: string | null
      subscribed_at: Date | null
      prev_transaction_page_params: Prisma.JsonValue | null
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    impersonation_sessions<T extends sessions$impersonation_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, sessions$impersonation_sessionsArgs<ExtArgs>>): Prisma__impersonation_sessionsClient<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'String'>
    readonly user_agent: FieldRef<"sessions", 'String'>
    readonly ip_address: FieldRef<"sessions", 'String'>
    readonly created_at: FieldRef<"sessions", 'DateTime'>
    readonly updated_at: FieldRef<"sessions", 'DateTime'>
    readonly active_impersonator_session_id: FieldRef<"sessions", 'String'>
    readonly subscribed_at: FieldRef<"sessions", 'DateTime'>
    readonly prev_transaction_page_params: FieldRef<"sessions", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions createManyAndReturn
   */
  export type sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions updateManyAndReturn
   */
  export type sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions.impersonation_sessions
   */
  export type sessions$impersonation_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    where?: impersonation_sessionsWhereInput
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: bigint | null
  }

  export type SettingsMinAggregateOutputType = {
    id: bigint | null
    var: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: bigint | null
    var: string | null
    value: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    var: number
    value: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    var?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    var?: true
    value?: true
    created_at?: true
    updated_at?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    var?: true
    value?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: bigint
    var: string
    value: string | null
    created_at: Date
    updated_at: Date
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    var?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    var?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    var?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["settings"]>

  export type settingsSelectScalar = {
    id?: boolean
    var?: boolean
    value?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "var" | "value" | "created_at" | "updated_at", ExtArgs["result"]["settings"]>

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      var: string
      value: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<Prisma.$settingsPayload, S>

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settings'], meta: { name: 'settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends settingsFindManyArgs>(args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends settingsCreateArgs>(args: SelectSubset<T, settingsCreateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingsCreateManyArgs>(args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {settingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends settingsDeleteArgs>(args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingsUpdateArgs>(args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingsDeleteManyArgs>(args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingsUpdateManyArgs>(args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {settingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends settingsUpdateManyAndReturnArgs>(args: SelectSubset<T, settingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>): Prisma__settingsClient<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs['orderBy'] }
        : { orderBy?: settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settings model
   */
  readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settings model
   */
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", 'BigInt'>
    readonly var: FieldRef<"settings", 'String'>
    readonly value: FieldRef<"settings", 'String'>
    readonly created_at: FieldRef<"settings", 'DateTime'>
    readonly updated_at: FieldRef<"settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settings createManyAndReturn
   */
  export type settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings updateManyAndReturn
   */
  export type settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to update.
     */
    limit?: number
  }

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
    /**
     * Limit how many settings to delete.
     */
    limit?: number
  }

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null
  }


  /**
   * Model stock_exchanges
   */

  export type AggregateStock_exchanges = {
    _count: Stock_exchangesCountAggregateOutputType | null
    _min: Stock_exchangesMinAggregateOutputType | null
    _max: Stock_exchangesMaxAggregateOutputType | null
  }

  export type Stock_exchangesMinAggregateOutputType = {
    id: string | null
    name: string | null
    acronym: string | null
    mic: string | null
    country: string | null
    country_code: string | null
    city: string | null
    website: string | null
    timezone_name: string | null
    timezone_abbr: string | null
    timezone_abbr_dst: string | null
    currency_code: string | null
    currency_symbol: string | null
    currency_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Stock_exchangesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    acronym: string | null
    mic: string | null
    country: string | null
    country_code: string | null
    city: string | null
    website: string | null
    timezone_name: string | null
    timezone_abbr: string | null
    timezone_abbr_dst: string | null
    currency_code: string | null
    currency_symbol: string | null
    currency_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Stock_exchangesCountAggregateOutputType = {
    id: number
    name: number
    acronym: number
    mic: number
    country: number
    country_code: number
    city: number
    website: number
    timezone_name: number
    timezone_abbr: number
    timezone_abbr_dst: number
    currency_code: number
    currency_symbol: number
    currency_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Stock_exchangesMinAggregateInputType = {
    id?: true
    name?: true
    acronym?: true
    mic?: true
    country?: true
    country_code?: true
    city?: true
    website?: true
    timezone_name?: true
    timezone_abbr?: true
    timezone_abbr_dst?: true
    currency_code?: true
    currency_symbol?: true
    currency_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Stock_exchangesMaxAggregateInputType = {
    id?: true
    name?: true
    acronym?: true
    mic?: true
    country?: true
    country_code?: true
    city?: true
    website?: true
    timezone_name?: true
    timezone_abbr?: true
    timezone_abbr_dst?: true
    currency_code?: true
    currency_symbol?: true
    currency_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Stock_exchangesCountAggregateInputType = {
    id?: true
    name?: true
    acronym?: true
    mic?: true
    country?: true
    country_code?: true
    city?: true
    website?: true
    timezone_name?: true
    timezone_abbr?: true
    timezone_abbr_dst?: true
    currency_code?: true
    currency_symbol?: true
    currency_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Stock_exchangesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stock_exchanges to aggregate.
     */
    where?: stock_exchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_exchanges to fetch.
     */
    orderBy?: stock_exchangesOrderByWithRelationInput | stock_exchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stock_exchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stock_exchanges
    **/
    _count?: true | Stock_exchangesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stock_exchangesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stock_exchangesMaxAggregateInputType
  }

  export type GetStock_exchangesAggregateType<T extends Stock_exchangesAggregateArgs> = {
        [P in keyof T & keyof AggregateStock_exchanges]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_exchanges[P]>
      : GetScalarType<T[P], AggregateStock_exchanges[P]>
  }




  export type stock_exchangesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stock_exchangesWhereInput
    orderBy?: stock_exchangesOrderByWithAggregationInput | stock_exchangesOrderByWithAggregationInput[]
    by: Stock_exchangesScalarFieldEnum[] | Stock_exchangesScalarFieldEnum
    having?: stock_exchangesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stock_exchangesCountAggregateInputType | true
    _min?: Stock_exchangesMinAggregateInputType
    _max?: Stock_exchangesMaxAggregateInputType
  }

  export type Stock_exchangesGroupByOutputType = {
    id: string
    name: string
    acronym: string | null
    mic: string
    country: string
    country_code: string
    city: string | null
    website: string | null
    timezone_name: string | null
    timezone_abbr: string | null
    timezone_abbr_dst: string | null
    currency_code: string | null
    currency_symbol: string | null
    currency_name: string | null
    created_at: Date
    updated_at: Date
    _count: Stock_exchangesCountAggregateOutputType | null
    _min: Stock_exchangesMinAggregateOutputType | null
    _max: Stock_exchangesMaxAggregateOutputType | null
  }

  type GetStock_exchangesGroupByPayload<T extends stock_exchangesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stock_exchangesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stock_exchangesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stock_exchangesGroupByOutputType[P]>
            : GetScalarType<T[P], Stock_exchangesGroupByOutputType[P]>
        }
      >
    >


  export type stock_exchangesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    acronym?: boolean
    mic?: boolean
    country?: boolean
    country_code?: boolean
    city?: boolean
    website?: boolean
    timezone_name?: boolean
    timezone_abbr?: boolean
    timezone_abbr_dst?: boolean
    currency_code?: boolean
    currency_symbol?: boolean
    currency_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["stock_exchanges"]>

  export type stock_exchangesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    acronym?: boolean
    mic?: boolean
    country?: boolean
    country_code?: boolean
    city?: boolean
    website?: boolean
    timezone_name?: boolean
    timezone_abbr?: boolean
    timezone_abbr_dst?: boolean
    currency_code?: boolean
    currency_symbol?: boolean
    currency_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["stock_exchanges"]>

  export type stock_exchangesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    acronym?: boolean
    mic?: boolean
    country?: boolean
    country_code?: boolean
    city?: boolean
    website?: boolean
    timezone_name?: boolean
    timezone_abbr?: boolean
    timezone_abbr_dst?: boolean
    currency_code?: boolean
    currency_symbol?: boolean
    currency_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["stock_exchanges"]>

  export type stock_exchangesSelectScalar = {
    id?: boolean
    name?: boolean
    acronym?: boolean
    mic?: boolean
    country?: boolean
    country_code?: boolean
    city?: boolean
    website?: boolean
    timezone_name?: boolean
    timezone_abbr?: boolean
    timezone_abbr_dst?: boolean
    currency_code?: boolean
    currency_symbol?: boolean
    currency_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type stock_exchangesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "acronym" | "mic" | "country" | "country_code" | "city" | "website" | "timezone_name" | "timezone_abbr" | "timezone_abbr_dst" | "currency_code" | "currency_symbol" | "currency_name" | "created_at" | "updated_at", ExtArgs["result"]["stock_exchanges"]>

  export type $stock_exchangesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stock_exchanges"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      acronym: string | null
      mic: string
      country: string
      country_code: string
      city: string | null
      website: string | null
      timezone_name: string | null
      timezone_abbr: string | null
      timezone_abbr_dst: string | null
      currency_code: string | null
      currency_symbol: string | null
      currency_name: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stock_exchanges"]>
    composites: {}
  }

  type stock_exchangesGetPayload<S extends boolean | null | undefined | stock_exchangesDefaultArgs> = $Result.GetResult<Prisma.$stock_exchangesPayload, S>

  type stock_exchangesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stock_exchangesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stock_exchangesCountAggregateInputType | true
    }

  export interface stock_exchangesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stock_exchanges'], meta: { name: 'stock_exchanges' } }
    /**
     * Find zero or one Stock_exchanges that matches the filter.
     * @param {stock_exchangesFindUniqueArgs} args - Arguments to find a Stock_exchanges
     * @example
     * // Get one Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_exchangesFindUniqueArgs>(args: SelectSubset<T, stock_exchangesFindUniqueArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock_exchanges that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_exchangesFindUniqueOrThrowArgs} args - Arguments to find a Stock_exchanges
     * @example
     * // Get one Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stock_exchangesFindUniqueOrThrowArgs>(args: SelectSubset<T, stock_exchangesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock_exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesFindFirstArgs} args - Arguments to find a Stock_exchanges
     * @example
     * // Get one Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_exchangesFindFirstArgs>(args?: SelectSubset<T, stock_exchangesFindFirstArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock_exchanges that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesFindFirstOrThrowArgs} args - Arguments to find a Stock_exchanges
     * @example
     * // Get one Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_exchangesFindFirstOrThrowArgs>(args?: SelectSubset<T, stock_exchangesFindFirstOrThrowArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stock_exchanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findMany()
     * 
     * // Get first 10 Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stock_exchangesWithIdOnly = await prisma.stock_exchanges.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stock_exchangesFindManyArgs>(args?: SelectSubset<T, stock_exchangesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock_exchanges.
     * @param {stock_exchangesCreateArgs} args - Arguments to create a Stock_exchanges.
     * @example
     * // Create one Stock_exchanges
     * const Stock_exchanges = await prisma.stock_exchanges.create({
     *   data: {
     *     // ... data to create a Stock_exchanges
     *   }
     * })
     * 
     */
    create<T extends stock_exchangesCreateArgs>(args: SelectSubset<T, stock_exchangesCreateArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stock_exchanges.
     * @param {stock_exchangesCreateManyArgs} args - Arguments to create many Stock_exchanges.
     * @example
     * // Create many Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stock_exchangesCreateManyArgs>(args?: SelectSubset<T, stock_exchangesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stock_exchanges and returns the data saved in the database.
     * @param {stock_exchangesCreateManyAndReturnArgs} args - Arguments to create many Stock_exchanges.
     * @example
     * // Create many Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stock_exchanges and only return the `id`
     * const stock_exchangesWithIdOnly = await prisma.stock_exchanges.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends stock_exchangesCreateManyAndReturnArgs>(args?: SelectSubset<T, stock_exchangesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stock_exchanges.
     * @param {stock_exchangesDeleteArgs} args - Arguments to delete one Stock_exchanges.
     * @example
     * // Delete one Stock_exchanges
     * const Stock_exchanges = await prisma.stock_exchanges.delete({
     *   where: {
     *     // ... filter to delete one Stock_exchanges
     *   }
     * })
     * 
     */
    delete<T extends stock_exchangesDeleteArgs>(args: SelectSubset<T, stock_exchangesDeleteArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock_exchanges.
     * @param {stock_exchangesUpdateArgs} args - Arguments to update one Stock_exchanges.
     * @example
     * // Update one Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stock_exchangesUpdateArgs>(args: SelectSubset<T, stock_exchangesUpdateArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stock_exchanges.
     * @param {stock_exchangesDeleteManyArgs} args - Arguments to filter Stock_exchanges to delete.
     * @example
     * // Delete a few Stock_exchanges
     * const { count } = await prisma.stock_exchanges.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stock_exchangesDeleteManyArgs>(args?: SelectSubset<T, stock_exchangesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stock_exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stock_exchangesUpdateManyArgs>(args: SelectSubset<T, stock_exchangesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stock_exchanges and returns the data updated in the database.
     * @param {stock_exchangesUpdateManyAndReturnArgs} args - Arguments to update many Stock_exchanges.
     * @example
     * // Update many Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stock_exchanges and only return the `id`
     * const stock_exchangesWithIdOnly = await prisma.stock_exchanges.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends stock_exchangesUpdateManyAndReturnArgs>(args: SelectSubset<T, stock_exchangesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stock_exchanges.
     * @param {stock_exchangesUpsertArgs} args - Arguments to update or create a Stock_exchanges.
     * @example
     * // Update or create a Stock_exchanges
     * const stock_exchanges = await prisma.stock_exchanges.upsert({
     *   create: {
     *     // ... data to create a Stock_exchanges
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_exchanges we want to update
     *   }
     * })
     */
    upsert<T extends stock_exchangesUpsertArgs>(args: SelectSubset<T, stock_exchangesUpsertArgs<ExtArgs>>): Prisma__stock_exchangesClient<$Result.GetResult<Prisma.$stock_exchangesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stock_exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesCountArgs} args - Arguments to filter Stock_exchanges to count.
     * @example
     * // Count the number of Stock_exchanges
     * const count = await prisma.stock_exchanges.count({
     *   where: {
     *     // ... the filter for the Stock_exchanges we want to count
     *   }
     * })
    **/
    count<T extends stock_exchangesCountArgs>(
      args?: Subset<T, stock_exchangesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stock_exchangesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock_exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_exchangesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stock_exchangesAggregateArgs>(args: Subset<T, Stock_exchangesAggregateArgs>): Prisma.PrismaPromise<GetStock_exchangesAggregateType<T>>

    /**
     * Group by Stock_exchanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_exchangesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stock_exchangesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_exchangesGroupByArgs['orderBy'] }
        : { orderBy?: stock_exchangesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stock_exchangesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStock_exchangesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stock_exchanges model
   */
  readonly fields: stock_exchangesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_exchanges.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_exchangesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stock_exchanges model
   */
  interface stock_exchangesFieldRefs {
    readonly id: FieldRef<"stock_exchanges", 'String'>
    readonly name: FieldRef<"stock_exchanges", 'String'>
    readonly acronym: FieldRef<"stock_exchanges", 'String'>
    readonly mic: FieldRef<"stock_exchanges", 'String'>
    readonly country: FieldRef<"stock_exchanges", 'String'>
    readonly country_code: FieldRef<"stock_exchanges", 'String'>
    readonly city: FieldRef<"stock_exchanges", 'String'>
    readonly website: FieldRef<"stock_exchanges", 'String'>
    readonly timezone_name: FieldRef<"stock_exchanges", 'String'>
    readonly timezone_abbr: FieldRef<"stock_exchanges", 'String'>
    readonly timezone_abbr_dst: FieldRef<"stock_exchanges", 'String'>
    readonly currency_code: FieldRef<"stock_exchanges", 'String'>
    readonly currency_symbol: FieldRef<"stock_exchanges", 'String'>
    readonly currency_name: FieldRef<"stock_exchanges", 'String'>
    readonly created_at: FieldRef<"stock_exchanges", 'DateTime'>
    readonly updated_at: FieldRef<"stock_exchanges", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * stock_exchanges findUnique
   */
  export type stock_exchangesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter, which stock_exchanges to fetch.
     */
    where: stock_exchangesWhereUniqueInput
  }

  /**
   * stock_exchanges findUniqueOrThrow
   */
  export type stock_exchangesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter, which stock_exchanges to fetch.
     */
    where: stock_exchangesWhereUniqueInput
  }

  /**
   * stock_exchanges findFirst
   */
  export type stock_exchangesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter, which stock_exchanges to fetch.
     */
    where?: stock_exchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_exchanges to fetch.
     */
    orderBy?: stock_exchangesOrderByWithRelationInput | stock_exchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stock_exchanges.
     */
    cursor?: stock_exchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stock_exchanges.
     */
    distinct?: Stock_exchangesScalarFieldEnum | Stock_exchangesScalarFieldEnum[]
  }

  /**
   * stock_exchanges findFirstOrThrow
   */
  export type stock_exchangesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter, which stock_exchanges to fetch.
     */
    where?: stock_exchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_exchanges to fetch.
     */
    orderBy?: stock_exchangesOrderByWithRelationInput | stock_exchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stock_exchanges.
     */
    cursor?: stock_exchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_exchanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stock_exchanges.
     */
    distinct?: Stock_exchangesScalarFieldEnum | Stock_exchangesScalarFieldEnum[]
  }

  /**
   * stock_exchanges findMany
   */
  export type stock_exchangesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter, which stock_exchanges to fetch.
     */
    where?: stock_exchangesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_exchanges to fetch.
     */
    orderBy?: stock_exchangesOrderByWithRelationInput | stock_exchangesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stock_exchanges.
     */
    cursor?: stock_exchangesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_exchanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_exchanges.
     */
    skip?: number
    distinct?: Stock_exchangesScalarFieldEnum | Stock_exchangesScalarFieldEnum[]
  }

  /**
   * stock_exchanges create
   */
  export type stock_exchangesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * The data needed to create a stock_exchanges.
     */
    data: XOR<stock_exchangesCreateInput, stock_exchangesUncheckedCreateInput>
  }

  /**
   * stock_exchanges createMany
   */
  export type stock_exchangesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stock_exchanges.
     */
    data: stock_exchangesCreateManyInput | stock_exchangesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stock_exchanges createManyAndReturn
   */
  export type stock_exchangesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * The data used to create many stock_exchanges.
     */
    data: stock_exchangesCreateManyInput | stock_exchangesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stock_exchanges update
   */
  export type stock_exchangesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * The data needed to update a stock_exchanges.
     */
    data: XOR<stock_exchangesUpdateInput, stock_exchangesUncheckedUpdateInput>
    /**
     * Choose, which stock_exchanges to update.
     */
    where: stock_exchangesWhereUniqueInput
  }

  /**
   * stock_exchanges updateMany
   */
  export type stock_exchangesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stock_exchanges.
     */
    data: XOR<stock_exchangesUpdateManyMutationInput, stock_exchangesUncheckedUpdateManyInput>
    /**
     * Filter which stock_exchanges to update
     */
    where?: stock_exchangesWhereInput
    /**
     * Limit how many stock_exchanges to update.
     */
    limit?: number
  }

  /**
   * stock_exchanges updateManyAndReturn
   */
  export type stock_exchangesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * The data used to update stock_exchanges.
     */
    data: XOR<stock_exchangesUpdateManyMutationInput, stock_exchangesUncheckedUpdateManyInput>
    /**
     * Filter which stock_exchanges to update
     */
    where?: stock_exchangesWhereInput
    /**
     * Limit how many stock_exchanges to update.
     */
    limit?: number
  }

  /**
   * stock_exchanges upsert
   */
  export type stock_exchangesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * The filter to search for the stock_exchanges to update in case it exists.
     */
    where: stock_exchangesWhereUniqueInput
    /**
     * In case the stock_exchanges found by the `where` argument doesn't exist, create a new stock_exchanges with this data.
     */
    create: XOR<stock_exchangesCreateInput, stock_exchangesUncheckedCreateInput>
    /**
     * In case the stock_exchanges was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stock_exchangesUpdateInput, stock_exchangesUncheckedUpdateInput>
  }

  /**
   * stock_exchanges delete
   */
  export type stock_exchangesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
    /**
     * Filter which stock_exchanges to delete.
     */
    where: stock_exchangesWhereUniqueInput
  }

  /**
   * stock_exchanges deleteMany
   */
  export type stock_exchangesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stock_exchanges to delete
     */
    where?: stock_exchangesWhereInput
    /**
     * Limit how many stock_exchanges to delete.
     */
    limit?: number
  }

  /**
   * stock_exchanges without action
   */
  export type stock_exchangesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_exchanges
     */
    select?: stock_exchangesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_exchanges
     */
    omit?: stock_exchangesOmit<ExtArgs> | null
  }


  /**
   * Model syncs
   */

  export type AggregateSyncs = {
    _count: SyncsCountAggregateOutputType | null
    _min: SyncsMinAggregateOutputType | null
    _max: SyncsMaxAggregateOutputType | null
  }

  export type SyncsMinAggregateOutputType = {
    id: string | null
    syncable_type: string | null
    syncable_id: string | null
    last_ran_at: Date | null
    start_date: Date | null
    status: string | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
    parent_id: string | null
  }

  export type SyncsMaxAggregateOutputType = {
    id: string | null
    syncable_type: string | null
    syncable_id: string | null
    last_ran_at: Date | null
    start_date: Date | null
    status: string | null
    error: string | null
    created_at: Date | null
    updated_at: Date | null
    parent_id: string | null
  }

  export type SyncsCountAggregateOutputType = {
    id: number
    syncable_type: number
    syncable_id: number
    last_ran_at: number
    start_date: number
    status: number
    error: number
    data: number
    created_at: number
    updated_at: number
    error_backtrace: number
    parent_id: number
    _all: number
  }


  export type SyncsMinAggregateInputType = {
    id?: true
    syncable_type?: true
    syncable_id?: true
    last_ran_at?: true
    start_date?: true
    status?: true
    error?: true
    created_at?: true
    updated_at?: true
    parent_id?: true
  }

  export type SyncsMaxAggregateInputType = {
    id?: true
    syncable_type?: true
    syncable_id?: true
    last_ran_at?: true
    start_date?: true
    status?: true
    error?: true
    created_at?: true
    updated_at?: true
    parent_id?: true
  }

  export type SyncsCountAggregateInputType = {
    id?: true
    syncable_type?: true
    syncable_id?: true
    last_ran_at?: true
    start_date?: true
    status?: true
    error?: true
    data?: true
    created_at?: true
    updated_at?: true
    error_backtrace?: true
    parent_id?: true
    _all?: true
  }

  export type SyncsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which syncs to aggregate.
     */
    where?: syncsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of syncs to fetch.
     */
    orderBy?: syncsOrderByWithRelationInput | syncsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: syncsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` syncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` syncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned syncs
    **/
    _count?: true | SyncsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncsMaxAggregateInputType
  }

  export type GetSyncsAggregateType<T extends SyncsAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncs[P]>
      : GetScalarType<T[P], AggregateSyncs[P]>
  }




  export type syncsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: syncsWhereInput
    orderBy?: syncsOrderByWithAggregationInput | syncsOrderByWithAggregationInput[]
    by: SyncsScalarFieldEnum[] | SyncsScalarFieldEnum
    having?: syncsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncsCountAggregateInputType | true
    _min?: SyncsMinAggregateInputType
    _max?: SyncsMaxAggregateInputType
  }

  export type SyncsGroupByOutputType = {
    id: string
    syncable_type: string
    syncable_id: string
    last_ran_at: Date | null
    start_date: Date | null
    status: string | null
    error: string | null
    data: JsonValue | null
    created_at: Date
    updated_at: Date
    error_backtrace: string[]
    parent_id: string | null
    _count: SyncsCountAggregateOutputType | null
    _min: SyncsMinAggregateOutputType | null
    _max: SyncsMaxAggregateOutputType | null
  }

  type GetSyncsGroupByPayload<T extends syncsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncsGroupByOutputType[P]>
            : GetScalarType<T[P], SyncsGroupByOutputType[P]>
        }
      >
    >


  export type syncsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncable_type?: boolean
    syncable_id?: boolean
    last_ran_at?: boolean
    start_date?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    error_backtrace?: boolean
    parent_id?: boolean
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
    other_syncs?: boolean | syncs$other_syncsArgs<ExtArgs>
    _count?: boolean | SyncsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncs"]>

  export type syncsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncable_type?: boolean
    syncable_id?: boolean
    last_ran_at?: boolean
    start_date?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    error_backtrace?: boolean
    parent_id?: boolean
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
  }, ExtArgs["result"]["syncs"]>

  export type syncsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syncable_type?: boolean
    syncable_id?: boolean
    last_ran_at?: boolean
    start_date?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    error_backtrace?: boolean
    parent_id?: boolean
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
  }, ExtArgs["result"]["syncs"]>

  export type syncsSelectScalar = {
    id?: boolean
    syncable_type?: boolean
    syncable_id?: boolean
    last_ran_at?: boolean
    start_date?: boolean
    status?: boolean
    error?: boolean
    data?: boolean
    created_at?: boolean
    updated_at?: boolean
    error_backtrace?: boolean
    parent_id?: boolean
  }

  export type syncsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syncable_type" | "syncable_id" | "last_ran_at" | "start_date" | "status" | "error" | "data" | "created_at" | "updated_at" | "error_backtrace" | "parent_id", ExtArgs["result"]["syncs"]>
  export type syncsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
    other_syncs?: boolean | syncs$other_syncsArgs<ExtArgs>
    _count?: boolean | SyncsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type syncsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
  }
  export type syncsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syncs?: boolean | syncs$syncsArgs<ExtArgs>
  }

  export type $syncsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "syncs"
    objects: {
      syncs: Prisma.$syncsPayload<ExtArgs> | null
      other_syncs: Prisma.$syncsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syncable_type: string
      syncable_id: string
      last_ran_at: Date | null
      start_date: Date | null
      status: string | null
      error: string | null
      data: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
      error_backtrace: string[]
      parent_id: string | null
    }, ExtArgs["result"]["syncs"]>
    composites: {}
  }

  type syncsGetPayload<S extends boolean | null | undefined | syncsDefaultArgs> = $Result.GetResult<Prisma.$syncsPayload, S>

  type syncsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<syncsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncsCountAggregateInputType | true
    }

  export interface syncsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['syncs'], meta: { name: 'syncs' } }
    /**
     * Find zero or one Syncs that matches the filter.
     * @param {syncsFindUniqueArgs} args - Arguments to find a Syncs
     * @example
     * // Get one Syncs
     * const syncs = await prisma.syncs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends syncsFindUniqueArgs>(args: SelectSubset<T, syncsFindUniqueArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Syncs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {syncsFindUniqueOrThrowArgs} args - Arguments to find a Syncs
     * @example
     * // Get one Syncs
     * const syncs = await prisma.syncs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends syncsFindUniqueOrThrowArgs>(args: SelectSubset<T, syncsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsFindFirstArgs} args - Arguments to find a Syncs
     * @example
     * // Get one Syncs
     * const syncs = await prisma.syncs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends syncsFindFirstArgs>(args?: SelectSubset<T, syncsFindFirstArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syncs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsFindFirstOrThrowArgs} args - Arguments to find a Syncs
     * @example
     * // Get one Syncs
     * const syncs = await prisma.syncs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends syncsFindFirstOrThrowArgs>(args?: SelectSubset<T, syncsFindFirstOrThrowArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Syncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syncs
     * const syncs = await prisma.syncs.findMany()
     * 
     * // Get first 10 Syncs
     * const syncs = await prisma.syncs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncsWithIdOnly = await prisma.syncs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends syncsFindManyArgs>(args?: SelectSubset<T, syncsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Syncs.
     * @param {syncsCreateArgs} args - Arguments to create a Syncs.
     * @example
     * // Create one Syncs
     * const Syncs = await prisma.syncs.create({
     *   data: {
     *     // ... data to create a Syncs
     *   }
     * })
     * 
     */
    create<T extends syncsCreateArgs>(args: SelectSubset<T, syncsCreateArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Syncs.
     * @param {syncsCreateManyArgs} args - Arguments to create many Syncs.
     * @example
     * // Create many Syncs
     * const syncs = await prisma.syncs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends syncsCreateManyArgs>(args?: SelectSubset<T, syncsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Syncs and returns the data saved in the database.
     * @param {syncsCreateManyAndReturnArgs} args - Arguments to create many Syncs.
     * @example
     * // Create many Syncs
     * const syncs = await prisma.syncs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Syncs and only return the `id`
     * const syncsWithIdOnly = await prisma.syncs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends syncsCreateManyAndReturnArgs>(args?: SelectSubset<T, syncsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Syncs.
     * @param {syncsDeleteArgs} args - Arguments to delete one Syncs.
     * @example
     * // Delete one Syncs
     * const Syncs = await prisma.syncs.delete({
     *   where: {
     *     // ... filter to delete one Syncs
     *   }
     * })
     * 
     */
    delete<T extends syncsDeleteArgs>(args: SelectSubset<T, syncsDeleteArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Syncs.
     * @param {syncsUpdateArgs} args - Arguments to update one Syncs.
     * @example
     * // Update one Syncs
     * const syncs = await prisma.syncs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends syncsUpdateArgs>(args: SelectSubset<T, syncsUpdateArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Syncs.
     * @param {syncsDeleteManyArgs} args - Arguments to filter Syncs to delete.
     * @example
     * // Delete a few Syncs
     * const { count } = await prisma.syncs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends syncsDeleteManyArgs>(args?: SelectSubset<T, syncsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syncs
     * const syncs = await prisma.syncs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends syncsUpdateManyArgs>(args: SelectSubset<T, syncsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syncs and returns the data updated in the database.
     * @param {syncsUpdateManyAndReturnArgs} args - Arguments to update many Syncs.
     * @example
     * // Update many Syncs
     * const syncs = await prisma.syncs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Syncs and only return the `id`
     * const syncsWithIdOnly = await prisma.syncs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends syncsUpdateManyAndReturnArgs>(args: SelectSubset<T, syncsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Syncs.
     * @param {syncsUpsertArgs} args - Arguments to update or create a Syncs.
     * @example
     * // Update or create a Syncs
     * const syncs = await prisma.syncs.upsert({
     *   create: {
     *     // ... data to create a Syncs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syncs we want to update
     *   }
     * })
     */
    upsert<T extends syncsUpsertArgs>(args: SelectSubset<T, syncsUpsertArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Syncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsCountArgs} args - Arguments to filter Syncs to count.
     * @example
     * // Count the number of Syncs
     * const count = await prisma.syncs.count({
     *   where: {
     *     // ... the filter for the Syncs we want to count
     *   }
     * })
    **/
    count<T extends syncsCountArgs>(
      args?: Subset<T, syncsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncsAggregateArgs>(args: Subset<T, SyncsAggregateArgs>): Prisma.PrismaPromise<GetSyncsAggregateType<T>>

    /**
     * Group by Syncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {syncsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends syncsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: syncsGroupByArgs['orderBy'] }
        : { orderBy?: syncsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, syncsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the syncs model
   */
  readonly fields: syncsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for syncs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__syncsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syncs<T extends syncs$syncsArgs<ExtArgs> = {}>(args?: Subset<T, syncs$syncsArgs<ExtArgs>>): Prisma__syncsClient<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_syncs<T extends syncs$other_syncsArgs<ExtArgs> = {}>(args?: Subset<T, syncs$other_syncsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$syncsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the syncs model
   */
  interface syncsFieldRefs {
    readonly id: FieldRef<"syncs", 'String'>
    readonly syncable_type: FieldRef<"syncs", 'String'>
    readonly syncable_id: FieldRef<"syncs", 'String'>
    readonly last_ran_at: FieldRef<"syncs", 'DateTime'>
    readonly start_date: FieldRef<"syncs", 'DateTime'>
    readonly status: FieldRef<"syncs", 'String'>
    readonly error: FieldRef<"syncs", 'String'>
    readonly data: FieldRef<"syncs", 'Json'>
    readonly created_at: FieldRef<"syncs", 'DateTime'>
    readonly updated_at: FieldRef<"syncs", 'DateTime'>
    readonly error_backtrace: FieldRef<"syncs", 'String[]'>
    readonly parent_id: FieldRef<"syncs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * syncs findUnique
   */
  export type syncsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter, which syncs to fetch.
     */
    where: syncsWhereUniqueInput
  }

  /**
   * syncs findUniqueOrThrow
   */
  export type syncsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter, which syncs to fetch.
     */
    where: syncsWhereUniqueInput
  }

  /**
   * syncs findFirst
   */
  export type syncsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter, which syncs to fetch.
     */
    where?: syncsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of syncs to fetch.
     */
    orderBy?: syncsOrderByWithRelationInput | syncsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for syncs.
     */
    cursor?: syncsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` syncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` syncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of syncs.
     */
    distinct?: SyncsScalarFieldEnum | SyncsScalarFieldEnum[]
  }

  /**
   * syncs findFirstOrThrow
   */
  export type syncsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter, which syncs to fetch.
     */
    where?: syncsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of syncs to fetch.
     */
    orderBy?: syncsOrderByWithRelationInput | syncsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for syncs.
     */
    cursor?: syncsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` syncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` syncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of syncs.
     */
    distinct?: SyncsScalarFieldEnum | SyncsScalarFieldEnum[]
  }

  /**
   * syncs findMany
   */
  export type syncsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter, which syncs to fetch.
     */
    where?: syncsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of syncs to fetch.
     */
    orderBy?: syncsOrderByWithRelationInput | syncsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing syncs.
     */
    cursor?: syncsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` syncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` syncs.
     */
    skip?: number
    distinct?: SyncsScalarFieldEnum | SyncsScalarFieldEnum[]
  }

  /**
   * syncs create
   */
  export type syncsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * The data needed to create a syncs.
     */
    data: XOR<syncsCreateInput, syncsUncheckedCreateInput>
  }

  /**
   * syncs createMany
   */
  export type syncsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many syncs.
     */
    data: syncsCreateManyInput | syncsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * syncs createManyAndReturn
   */
  export type syncsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * The data used to create many syncs.
     */
    data: syncsCreateManyInput | syncsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * syncs update
   */
  export type syncsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * The data needed to update a syncs.
     */
    data: XOR<syncsUpdateInput, syncsUncheckedUpdateInput>
    /**
     * Choose, which syncs to update.
     */
    where: syncsWhereUniqueInput
  }

  /**
   * syncs updateMany
   */
  export type syncsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update syncs.
     */
    data: XOR<syncsUpdateManyMutationInput, syncsUncheckedUpdateManyInput>
    /**
     * Filter which syncs to update
     */
    where?: syncsWhereInput
    /**
     * Limit how many syncs to update.
     */
    limit?: number
  }

  /**
   * syncs updateManyAndReturn
   */
  export type syncsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * The data used to update syncs.
     */
    data: XOR<syncsUpdateManyMutationInput, syncsUncheckedUpdateManyInput>
    /**
     * Filter which syncs to update
     */
    where?: syncsWhereInput
    /**
     * Limit how many syncs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * syncs upsert
   */
  export type syncsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * The filter to search for the syncs to update in case it exists.
     */
    where: syncsWhereUniqueInput
    /**
     * In case the syncs found by the `where` argument doesn't exist, create a new syncs with this data.
     */
    create: XOR<syncsCreateInput, syncsUncheckedCreateInput>
    /**
     * In case the syncs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<syncsUpdateInput, syncsUncheckedUpdateInput>
  }

  /**
   * syncs delete
   */
  export type syncsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    /**
     * Filter which syncs to delete.
     */
    where: syncsWhereUniqueInput
  }

  /**
   * syncs deleteMany
   */
  export type syncsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which syncs to delete
     */
    where?: syncsWhereInput
    /**
     * Limit how many syncs to delete.
     */
    limit?: number
  }

  /**
   * syncs.syncs
   */
  export type syncs$syncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    where?: syncsWhereInput
  }

  /**
   * syncs.other_syncs
   */
  export type syncs$other_syncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
    where?: syncsWhereInput
    orderBy?: syncsOrderByWithRelationInput | syncsOrderByWithRelationInput[]
    cursor?: syncsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncsScalarFieldEnum | SyncsScalarFieldEnum[]
  }

  /**
   * syncs without action
   */
  export type syncsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the syncs
     */
    select?: syncsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the syncs
     */
    omit?: syncsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: syncsInclude<ExtArgs> | null
  }


  /**
   * Model taggings
   */

  export type AggregateTaggings = {
    _count: TaggingsCountAggregateOutputType | null
    _min: TaggingsMinAggregateOutputType | null
    _max: TaggingsMaxAggregateOutputType | null
  }

  export type TaggingsMinAggregateOutputType = {
    id: string | null
    tag_id: string | null
    taggable_type: string | null
    taggable_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaggingsMaxAggregateOutputType = {
    id: string | null
    tag_id: string | null
    taggable_type: string | null
    taggable_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TaggingsCountAggregateOutputType = {
    id: number
    tag_id: number
    taggable_type: number
    taggable_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TaggingsMinAggregateInputType = {
    id?: true
    tag_id?: true
    taggable_type?: true
    taggable_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TaggingsMaxAggregateInputType = {
    id?: true
    tag_id?: true
    taggable_type?: true
    taggable_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TaggingsCountAggregateInputType = {
    id?: true
    tag_id?: true
    taggable_type?: true
    taggable_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TaggingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taggings to aggregate.
     */
    where?: taggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggings to fetch.
     */
    orderBy?: taggingsOrderByWithRelationInput | taggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taggings
    **/
    _count?: true | TaggingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaggingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaggingsMaxAggregateInputType
  }

  export type GetTaggingsAggregateType<T extends TaggingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaggings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaggings[P]>
      : GetScalarType<T[P], AggregateTaggings[P]>
  }




  export type taggingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taggingsWhereInput
    orderBy?: taggingsOrderByWithAggregationInput | taggingsOrderByWithAggregationInput[]
    by: TaggingsScalarFieldEnum[] | TaggingsScalarFieldEnum
    having?: taggingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaggingsCountAggregateInputType | true
    _min?: TaggingsMinAggregateInputType
    _max?: TaggingsMaxAggregateInputType
  }

  export type TaggingsGroupByOutputType = {
    id: string
    tag_id: string
    taggable_type: string | null
    taggable_id: string | null
    created_at: Date
    updated_at: Date
    _count: TaggingsCountAggregateOutputType | null
    _min: TaggingsMinAggregateOutputType | null
    _max: TaggingsMaxAggregateOutputType | null
  }

  type GetTaggingsGroupByPayload<T extends taggingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaggingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaggingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaggingsGroupByOutputType[P]>
            : GetScalarType<T[P], TaggingsGroupByOutputType[P]>
        }
      >
    >


  export type taggingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_id?: boolean
    taggable_type?: boolean
    taggable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taggings"]>

  export type taggingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_id?: boolean
    taggable_type?: boolean
    taggable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taggings"]>

  export type taggingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag_id?: boolean
    taggable_type?: boolean
    taggable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taggings"]>

  export type taggingsSelectScalar = {
    id?: boolean
    tag_id?: boolean
    taggable_type?: boolean
    taggable_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type taggingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag_id" | "taggable_type" | "taggable_id" | "created_at" | "updated_at", ExtArgs["result"]["taggings"]>
  export type taggingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type taggingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type taggingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }

  export type $taggingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taggings"
    objects: {
      tags: Prisma.$tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag_id: string
      taggable_type: string | null
      taggable_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["taggings"]>
    composites: {}
  }

  type taggingsGetPayload<S extends boolean | null | undefined | taggingsDefaultArgs> = $Result.GetResult<Prisma.$taggingsPayload, S>

  type taggingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<taggingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaggingsCountAggregateInputType | true
    }

  export interface taggingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taggings'], meta: { name: 'taggings' } }
    /**
     * Find zero or one Taggings that matches the filter.
     * @param {taggingsFindUniqueArgs} args - Arguments to find a Taggings
     * @example
     * // Get one Taggings
     * const taggings = await prisma.taggings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends taggingsFindUniqueArgs>(args: SelectSubset<T, taggingsFindUniqueArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Taggings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {taggingsFindUniqueOrThrowArgs} args - Arguments to find a Taggings
     * @example
     * // Get one Taggings
     * const taggings = await prisma.taggings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends taggingsFindUniqueOrThrowArgs>(args: SelectSubset<T, taggingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Taggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsFindFirstArgs} args - Arguments to find a Taggings
     * @example
     * // Get one Taggings
     * const taggings = await prisma.taggings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends taggingsFindFirstArgs>(args?: SelectSubset<T, taggingsFindFirstArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Taggings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsFindFirstOrThrowArgs} args - Arguments to find a Taggings
     * @example
     * // Get one Taggings
     * const taggings = await prisma.taggings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends taggingsFindFirstOrThrowArgs>(args?: SelectSubset<T, taggingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Taggings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taggings
     * const taggings = await prisma.taggings.findMany()
     * 
     * // Get first 10 Taggings
     * const taggings = await prisma.taggings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taggingsWithIdOnly = await prisma.taggings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends taggingsFindManyArgs>(args?: SelectSubset<T, taggingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Taggings.
     * @param {taggingsCreateArgs} args - Arguments to create a Taggings.
     * @example
     * // Create one Taggings
     * const Taggings = await prisma.taggings.create({
     *   data: {
     *     // ... data to create a Taggings
     *   }
     * })
     * 
     */
    create<T extends taggingsCreateArgs>(args: SelectSubset<T, taggingsCreateArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Taggings.
     * @param {taggingsCreateManyArgs} args - Arguments to create many Taggings.
     * @example
     * // Create many Taggings
     * const taggings = await prisma.taggings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends taggingsCreateManyArgs>(args?: SelectSubset<T, taggingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Taggings and returns the data saved in the database.
     * @param {taggingsCreateManyAndReturnArgs} args - Arguments to create many Taggings.
     * @example
     * // Create many Taggings
     * const taggings = await prisma.taggings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Taggings and only return the `id`
     * const taggingsWithIdOnly = await prisma.taggings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends taggingsCreateManyAndReturnArgs>(args?: SelectSubset<T, taggingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Taggings.
     * @param {taggingsDeleteArgs} args - Arguments to delete one Taggings.
     * @example
     * // Delete one Taggings
     * const Taggings = await prisma.taggings.delete({
     *   where: {
     *     // ... filter to delete one Taggings
     *   }
     * })
     * 
     */
    delete<T extends taggingsDeleteArgs>(args: SelectSubset<T, taggingsDeleteArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Taggings.
     * @param {taggingsUpdateArgs} args - Arguments to update one Taggings.
     * @example
     * // Update one Taggings
     * const taggings = await prisma.taggings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends taggingsUpdateArgs>(args: SelectSubset<T, taggingsUpdateArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Taggings.
     * @param {taggingsDeleteManyArgs} args - Arguments to filter Taggings to delete.
     * @example
     * // Delete a few Taggings
     * const { count } = await prisma.taggings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends taggingsDeleteManyArgs>(args?: SelectSubset<T, taggingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taggings
     * const taggings = await prisma.taggings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends taggingsUpdateManyArgs>(args: SelectSubset<T, taggingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taggings and returns the data updated in the database.
     * @param {taggingsUpdateManyAndReturnArgs} args - Arguments to update many Taggings.
     * @example
     * // Update many Taggings
     * const taggings = await prisma.taggings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Taggings and only return the `id`
     * const taggingsWithIdOnly = await prisma.taggings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends taggingsUpdateManyAndReturnArgs>(args: SelectSubset<T, taggingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Taggings.
     * @param {taggingsUpsertArgs} args - Arguments to update or create a Taggings.
     * @example
     * // Update or create a Taggings
     * const taggings = await prisma.taggings.upsert({
     *   create: {
     *     // ... data to create a Taggings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taggings we want to update
     *   }
     * })
     */
    upsert<T extends taggingsUpsertArgs>(args: SelectSubset<T, taggingsUpsertArgs<ExtArgs>>): Prisma__taggingsClient<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Taggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsCountArgs} args - Arguments to filter Taggings to count.
     * @example
     * // Count the number of Taggings
     * const count = await prisma.taggings.count({
     *   where: {
     *     // ... the filter for the Taggings we want to count
     *   }
     * })
    **/
    count<T extends taggingsCountArgs>(
      args?: Subset<T, taggingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaggingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Taggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaggingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaggingsAggregateArgs>(args: Subset<T, TaggingsAggregateArgs>): Prisma.PrismaPromise<GetTaggingsAggregateType<T>>

    /**
     * Group by Taggings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taggingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends taggingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: taggingsGroupByArgs['orderBy'] }
        : { orderBy?: taggingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, taggingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaggingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taggings model
   */
  readonly fields: taggingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taggings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__taggingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagsDefaultArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taggings model
   */
  interface taggingsFieldRefs {
    readonly id: FieldRef<"taggings", 'String'>
    readonly tag_id: FieldRef<"taggings", 'String'>
    readonly taggable_type: FieldRef<"taggings", 'String'>
    readonly taggable_id: FieldRef<"taggings", 'String'>
    readonly created_at: FieldRef<"taggings", 'DateTime'>
    readonly updated_at: FieldRef<"taggings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * taggings findUnique
   */
  export type taggingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter, which taggings to fetch.
     */
    where: taggingsWhereUniqueInput
  }

  /**
   * taggings findUniqueOrThrow
   */
  export type taggingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter, which taggings to fetch.
     */
    where: taggingsWhereUniqueInput
  }

  /**
   * taggings findFirst
   */
  export type taggingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter, which taggings to fetch.
     */
    where?: taggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggings to fetch.
     */
    orderBy?: taggingsOrderByWithRelationInput | taggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taggings.
     */
    cursor?: taggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taggings.
     */
    distinct?: TaggingsScalarFieldEnum | TaggingsScalarFieldEnum[]
  }

  /**
   * taggings findFirstOrThrow
   */
  export type taggingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter, which taggings to fetch.
     */
    where?: taggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggings to fetch.
     */
    orderBy?: taggingsOrderByWithRelationInput | taggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taggings.
     */
    cursor?: taggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taggings.
     */
    distinct?: TaggingsScalarFieldEnum | TaggingsScalarFieldEnum[]
  }

  /**
   * taggings findMany
   */
  export type taggingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter, which taggings to fetch.
     */
    where?: taggingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taggings to fetch.
     */
    orderBy?: taggingsOrderByWithRelationInput | taggingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taggings.
     */
    cursor?: taggingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taggings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taggings.
     */
    skip?: number
    distinct?: TaggingsScalarFieldEnum | TaggingsScalarFieldEnum[]
  }

  /**
   * taggings create
   */
  export type taggingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * The data needed to create a taggings.
     */
    data: XOR<taggingsCreateInput, taggingsUncheckedCreateInput>
  }

  /**
   * taggings createMany
   */
  export type taggingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many taggings.
     */
    data: taggingsCreateManyInput | taggingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taggings createManyAndReturn
   */
  export type taggingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * The data used to create many taggings.
     */
    data: taggingsCreateManyInput | taggingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * taggings update
   */
  export type taggingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * The data needed to update a taggings.
     */
    data: XOR<taggingsUpdateInput, taggingsUncheckedUpdateInput>
    /**
     * Choose, which taggings to update.
     */
    where: taggingsWhereUniqueInput
  }

  /**
   * taggings updateMany
   */
  export type taggingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update taggings.
     */
    data: XOR<taggingsUpdateManyMutationInput, taggingsUncheckedUpdateManyInput>
    /**
     * Filter which taggings to update
     */
    where?: taggingsWhereInput
    /**
     * Limit how many taggings to update.
     */
    limit?: number
  }

  /**
   * taggings updateManyAndReturn
   */
  export type taggingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * The data used to update taggings.
     */
    data: XOR<taggingsUpdateManyMutationInput, taggingsUncheckedUpdateManyInput>
    /**
     * Filter which taggings to update
     */
    where?: taggingsWhereInput
    /**
     * Limit how many taggings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * taggings upsert
   */
  export type taggingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * The filter to search for the taggings to update in case it exists.
     */
    where: taggingsWhereUniqueInput
    /**
     * In case the taggings found by the `where` argument doesn't exist, create a new taggings with this data.
     */
    create: XOR<taggingsCreateInput, taggingsUncheckedCreateInput>
    /**
     * In case the taggings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taggingsUpdateInput, taggingsUncheckedUpdateInput>
  }

  /**
   * taggings delete
   */
  export type taggingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    /**
     * Filter which taggings to delete.
     */
    where: taggingsWhereUniqueInput
  }

  /**
   * taggings deleteMany
   */
  export type taggingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taggings to delete
     */
    where?: taggingsWhereInput
    /**
     * Limit how many taggings to delete.
     */
    limit?: number
  }

  /**
   * taggings without action
   */
  export type taggingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
  }


  /**
   * Model tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    family_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    color: number
    family_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    family_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    name: string | null
    color: string
    family_id: string
    created_at: Date
    updated_at: Date
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    taggings?: boolean | tags$taggingsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    family_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "family_id" | "created_at" | "updated_at", ExtArgs["result"]["tags"]>
  export type tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taggings?: boolean | tags$taggingsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tags"
    objects: {
      taggings: Prisma.$taggingsPayload<ExtArgs>[]
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      color: string
      family_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type tagsGetPayload<S extends boolean | null | undefined | tagsDefaultArgs> = $Result.GetResult<Prisma.$tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsFindUniqueArgs>(args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsFindFirstArgs>(args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagsFindManyArgs>(args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends tagsCreateArgs>(args: SelectSubset<T, tagsCreateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsCreateManyArgs>(args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends tagsDeleteArgs>(args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsUpdateArgs>(args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsDeleteManyArgs>(args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsUpdateManyArgs>(args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {tagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends tagsUpsertArgs>(args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taggings<T extends tags$taggingsArgs<ExtArgs> = {}>(args?: Subset<T, tags$taggingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taggingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tags model
   */
  interface tagsFieldRefs {
    readonly id: FieldRef<"tags", 'String'>
    readonly name: FieldRef<"tags", 'String'>
    readonly color: FieldRef<"tags", 'String'>
    readonly family_id: FieldRef<"tags", 'String'>
    readonly created_at: FieldRef<"tags", 'DateTime'>
    readonly updated_at: FieldRef<"tags", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }

  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags createManyAndReturn
   */
  export type tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tags updateManyAndReturn
   */
  export type tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }

  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tags.taggings
   */
  export type tags$taggingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taggings
     */
    select?: taggingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taggings
     */
    omit?: taggingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taggingsInclude<ExtArgs> | null
    where?: taggingsWhereInput
    orderBy?: taggingsOrderByWithRelationInput | taggingsOrderByWithRelationInput[]
    cursor?: taggingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaggingsScalarFieldEnum | TaggingsScalarFieldEnum[]
  }

  /**
   * tags without action
   */
  export type tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
  }


  /**
   * Model tool_calls
   */

  export type AggregateTool_calls = {
    _count: Tool_callsCountAggregateOutputType | null
    _min: Tool_callsMinAggregateOutputType | null
    _max: Tool_callsMaxAggregateOutputType | null
  }

  export type Tool_callsMinAggregateOutputType = {
    id: string | null
    message_id: string | null
    provider_id: string | null
    provider_call_id: string | null
    type: string | null
    function_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tool_callsMaxAggregateOutputType = {
    id: string | null
    message_id: string | null
    provider_id: string | null
    provider_call_id: string | null
    type: string | null
    function_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tool_callsCountAggregateOutputType = {
    id: number
    message_id: number
    provider_id: number
    provider_call_id: number
    type: number
    function_name: number
    function_arguments: number
    function_result: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Tool_callsMinAggregateInputType = {
    id?: true
    message_id?: true
    provider_id?: true
    provider_call_id?: true
    type?: true
    function_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Tool_callsMaxAggregateInputType = {
    id?: true
    message_id?: true
    provider_id?: true
    provider_call_id?: true
    type?: true
    function_name?: true
    created_at?: true
    updated_at?: true
  }

  export type Tool_callsCountAggregateInputType = {
    id?: true
    message_id?: true
    provider_id?: true
    provider_call_id?: true
    type?: true
    function_name?: true
    function_arguments?: true
    function_result?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Tool_callsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tool_calls to aggregate.
     */
    where?: tool_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tool_calls to fetch.
     */
    orderBy?: tool_callsOrderByWithRelationInput | tool_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tool_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tool_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tool_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tool_calls
    **/
    _count?: true | Tool_callsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tool_callsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tool_callsMaxAggregateInputType
  }

  export type GetTool_callsAggregateType<T extends Tool_callsAggregateArgs> = {
        [P in keyof T & keyof AggregateTool_calls]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTool_calls[P]>
      : GetScalarType<T[P], AggregateTool_calls[P]>
  }




  export type tool_callsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tool_callsWhereInput
    orderBy?: tool_callsOrderByWithAggregationInput | tool_callsOrderByWithAggregationInput[]
    by: Tool_callsScalarFieldEnum[] | Tool_callsScalarFieldEnum
    having?: tool_callsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tool_callsCountAggregateInputType | true
    _min?: Tool_callsMinAggregateInputType
    _max?: Tool_callsMaxAggregateInputType
  }

  export type Tool_callsGroupByOutputType = {
    id: string
    message_id: string
    provider_id: string
    provider_call_id: string | null
    type: string
    function_name: string | null
    function_arguments: JsonValue | null
    function_result: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: Tool_callsCountAggregateOutputType | null
    _min: Tool_callsMinAggregateOutputType | null
    _max: Tool_callsMaxAggregateOutputType | null
  }

  type GetTool_callsGroupByPayload<T extends tool_callsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tool_callsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tool_callsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tool_callsGroupByOutputType[P]>
            : GetScalarType<T[P], Tool_callsGroupByOutputType[P]>
        }
      >
    >


  export type tool_callsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    provider_id?: boolean
    provider_call_id?: boolean
    type?: boolean
    function_name?: boolean
    function_arguments?: boolean
    function_result?: boolean
    created_at?: boolean
    updated_at?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool_calls"]>

  export type tool_callsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    provider_id?: boolean
    provider_call_id?: boolean
    type?: boolean
    function_name?: boolean
    function_arguments?: boolean
    function_result?: boolean
    created_at?: boolean
    updated_at?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool_calls"]>

  export type tool_callsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_id?: boolean
    provider_id?: boolean
    provider_call_id?: boolean
    type?: boolean
    function_name?: boolean
    function_arguments?: boolean
    function_result?: boolean
    created_at?: boolean
    updated_at?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tool_calls"]>

  export type tool_callsSelectScalar = {
    id?: boolean
    message_id?: boolean
    provider_id?: boolean
    provider_call_id?: boolean
    type?: boolean
    function_name?: boolean
    function_arguments?: boolean
    function_result?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tool_callsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message_id" | "provider_id" | "provider_call_id" | "type" | "function_name" | "function_arguments" | "function_result" | "created_at" | "updated_at", ExtArgs["result"]["tool_calls"]>
  export type tool_callsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type tool_callsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type tool_callsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }

  export type $tool_callsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tool_calls"
    objects: {
      messages: Prisma.$messagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message_id: string
      provider_id: string
      provider_call_id: string | null
      type: string
      function_name: string | null
      function_arguments: Prisma.JsonValue | null
      function_result: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tool_calls"]>
    composites: {}
  }

  type tool_callsGetPayload<S extends boolean | null | undefined | tool_callsDefaultArgs> = $Result.GetResult<Prisma.$tool_callsPayload, S>

  type tool_callsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tool_callsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tool_callsCountAggregateInputType | true
    }

  export interface tool_callsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tool_calls'], meta: { name: 'tool_calls' } }
    /**
     * Find zero or one Tool_calls that matches the filter.
     * @param {tool_callsFindUniqueArgs} args - Arguments to find a Tool_calls
     * @example
     * // Get one Tool_calls
     * const tool_calls = await prisma.tool_calls.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tool_callsFindUniqueArgs>(args: SelectSubset<T, tool_callsFindUniqueArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tool_calls that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tool_callsFindUniqueOrThrowArgs} args - Arguments to find a Tool_calls
     * @example
     * // Get one Tool_calls
     * const tool_calls = await prisma.tool_calls.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tool_callsFindUniqueOrThrowArgs>(args: SelectSubset<T, tool_callsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tool_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsFindFirstArgs} args - Arguments to find a Tool_calls
     * @example
     * // Get one Tool_calls
     * const tool_calls = await prisma.tool_calls.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tool_callsFindFirstArgs>(args?: SelectSubset<T, tool_callsFindFirstArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tool_calls that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsFindFirstOrThrowArgs} args - Arguments to find a Tool_calls
     * @example
     * // Get one Tool_calls
     * const tool_calls = await prisma.tool_calls.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tool_callsFindFirstOrThrowArgs>(args?: SelectSubset<T, tool_callsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tool_calls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tool_calls
     * const tool_calls = await prisma.tool_calls.findMany()
     * 
     * // Get first 10 Tool_calls
     * const tool_calls = await prisma.tool_calls.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tool_callsWithIdOnly = await prisma.tool_calls.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tool_callsFindManyArgs>(args?: SelectSubset<T, tool_callsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tool_calls.
     * @param {tool_callsCreateArgs} args - Arguments to create a Tool_calls.
     * @example
     * // Create one Tool_calls
     * const Tool_calls = await prisma.tool_calls.create({
     *   data: {
     *     // ... data to create a Tool_calls
     *   }
     * })
     * 
     */
    create<T extends tool_callsCreateArgs>(args: SelectSubset<T, tool_callsCreateArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tool_calls.
     * @param {tool_callsCreateManyArgs} args - Arguments to create many Tool_calls.
     * @example
     * // Create many Tool_calls
     * const tool_calls = await prisma.tool_calls.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tool_callsCreateManyArgs>(args?: SelectSubset<T, tool_callsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tool_calls and returns the data saved in the database.
     * @param {tool_callsCreateManyAndReturnArgs} args - Arguments to create many Tool_calls.
     * @example
     * // Create many Tool_calls
     * const tool_calls = await prisma.tool_calls.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tool_calls and only return the `id`
     * const tool_callsWithIdOnly = await prisma.tool_calls.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tool_callsCreateManyAndReturnArgs>(args?: SelectSubset<T, tool_callsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tool_calls.
     * @param {tool_callsDeleteArgs} args - Arguments to delete one Tool_calls.
     * @example
     * // Delete one Tool_calls
     * const Tool_calls = await prisma.tool_calls.delete({
     *   where: {
     *     // ... filter to delete one Tool_calls
     *   }
     * })
     * 
     */
    delete<T extends tool_callsDeleteArgs>(args: SelectSubset<T, tool_callsDeleteArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tool_calls.
     * @param {tool_callsUpdateArgs} args - Arguments to update one Tool_calls.
     * @example
     * // Update one Tool_calls
     * const tool_calls = await prisma.tool_calls.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tool_callsUpdateArgs>(args: SelectSubset<T, tool_callsUpdateArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tool_calls.
     * @param {tool_callsDeleteManyArgs} args - Arguments to filter Tool_calls to delete.
     * @example
     * // Delete a few Tool_calls
     * const { count } = await prisma.tool_calls.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tool_callsDeleteManyArgs>(args?: SelectSubset<T, tool_callsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tool_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tool_calls
     * const tool_calls = await prisma.tool_calls.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tool_callsUpdateManyArgs>(args: SelectSubset<T, tool_callsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tool_calls and returns the data updated in the database.
     * @param {tool_callsUpdateManyAndReturnArgs} args - Arguments to update many Tool_calls.
     * @example
     * // Update many Tool_calls
     * const tool_calls = await prisma.tool_calls.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tool_calls and only return the `id`
     * const tool_callsWithIdOnly = await prisma.tool_calls.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tool_callsUpdateManyAndReturnArgs>(args: SelectSubset<T, tool_callsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tool_calls.
     * @param {tool_callsUpsertArgs} args - Arguments to update or create a Tool_calls.
     * @example
     * // Update or create a Tool_calls
     * const tool_calls = await prisma.tool_calls.upsert({
     *   create: {
     *     // ... data to create a Tool_calls
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tool_calls we want to update
     *   }
     * })
     */
    upsert<T extends tool_callsUpsertArgs>(args: SelectSubset<T, tool_callsUpsertArgs<ExtArgs>>): Prisma__tool_callsClient<$Result.GetResult<Prisma.$tool_callsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tool_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsCountArgs} args - Arguments to filter Tool_calls to count.
     * @example
     * // Count the number of Tool_calls
     * const count = await prisma.tool_calls.count({
     *   where: {
     *     // ... the filter for the Tool_calls we want to count
     *   }
     * })
    **/
    count<T extends tool_callsCountArgs>(
      args?: Subset<T, tool_callsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tool_callsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tool_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tool_callsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tool_callsAggregateArgs>(args: Subset<T, Tool_callsAggregateArgs>): Prisma.PrismaPromise<GetTool_callsAggregateType<T>>

    /**
     * Group by Tool_calls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tool_callsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tool_callsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tool_callsGroupByArgs['orderBy'] }
        : { orderBy?: tool_callsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tool_callsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTool_callsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tool_calls model
   */
  readonly fields: tool_callsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tool_calls.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tool_callsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends messagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, messagesDefaultArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tool_calls model
   */
  interface tool_callsFieldRefs {
    readonly id: FieldRef<"tool_calls", 'String'>
    readonly message_id: FieldRef<"tool_calls", 'String'>
    readonly provider_id: FieldRef<"tool_calls", 'String'>
    readonly provider_call_id: FieldRef<"tool_calls", 'String'>
    readonly type: FieldRef<"tool_calls", 'String'>
    readonly function_name: FieldRef<"tool_calls", 'String'>
    readonly function_arguments: FieldRef<"tool_calls", 'Json'>
    readonly function_result: FieldRef<"tool_calls", 'Json'>
    readonly created_at: FieldRef<"tool_calls", 'DateTime'>
    readonly updated_at: FieldRef<"tool_calls", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tool_calls findUnique
   */
  export type tool_callsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter, which tool_calls to fetch.
     */
    where: tool_callsWhereUniqueInput
  }

  /**
   * tool_calls findUniqueOrThrow
   */
  export type tool_callsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter, which tool_calls to fetch.
     */
    where: tool_callsWhereUniqueInput
  }

  /**
   * tool_calls findFirst
   */
  export type tool_callsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter, which tool_calls to fetch.
     */
    where?: tool_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tool_calls to fetch.
     */
    orderBy?: tool_callsOrderByWithRelationInput | tool_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tool_calls.
     */
    cursor?: tool_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tool_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tool_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tool_calls.
     */
    distinct?: Tool_callsScalarFieldEnum | Tool_callsScalarFieldEnum[]
  }

  /**
   * tool_calls findFirstOrThrow
   */
  export type tool_callsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter, which tool_calls to fetch.
     */
    where?: tool_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tool_calls to fetch.
     */
    orderBy?: tool_callsOrderByWithRelationInput | tool_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tool_calls.
     */
    cursor?: tool_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tool_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tool_calls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tool_calls.
     */
    distinct?: Tool_callsScalarFieldEnum | Tool_callsScalarFieldEnum[]
  }

  /**
   * tool_calls findMany
   */
  export type tool_callsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter, which tool_calls to fetch.
     */
    where?: tool_callsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tool_calls to fetch.
     */
    orderBy?: tool_callsOrderByWithRelationInput | tool_callsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tool_calls.
     */
    cursor?: tool_callsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tool_calls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tool_calls.
     */
    skip?: number
    distinct?: Tool_callsScalarFieldEnum | Tool_callsScalarFieldEnum[]
  }

  /**
   * tool_calls create
   */
  export type tool_callsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * The data needed to create a tool_calls.
     */
    data: XOR<tool_callsCreateInput, tool_callsUncheckedCreateInput>
  }

  /**
   * tool_calls createMany
   */
  export type tool_callsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tool_calls.
     */
    data: tool_callsCreateManyInput | tool_callsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tool_calls createManyAndReturn
   */
  export type tool_callsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * The data used to create many tool_calls.
     */
    data: tool_callsCreateManyInput | tool_callsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tool_calls update
   */
  export type tool_callsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * The data needed to update a tool_calls.
     */
    data: XOR<tool_callsUpdateInput, tool_callsUncheckedUpdateInput>
    /**
     * Choose, which tool_calls to update.
     */
    where: tool_callsWhereUniqueInput
  }

  /**
   * tool_calls updateMany
   */
  export type tool_callsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tool_calls.
     */
    data: XOR<tool_callsUpdateManyMutationInput, tool_callsUncheckedUpdateManyInput>
    /**
     * Filter which tool_calls to update
     */
    where?: tool_callsWhereInput
    /**
     * Limit how many tool_calls to update.
     */
    limit?: number
  }

  /**
   * tool_calls updateManyAndReturn
   */
  export type tool_callsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * The data used to update tool_calls.
     */
    data: XOR<tool_callsUpdateManyMutationInput, tool_callsUncheckedUpdateManyInput>
    /**
     * Filter which tool_calls to update
     */
    where?: tool_callsWhereInput
    /**
     * Limit how many tool_calls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tool_calls upsert
   */
  export type tool_callsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * The filter to search for the tool_calls to update in case it exists.
     */
    where: tool_callsWhereUniqueInput
    /**
     * In case the tool_calls found by the `where` argument doesn't exist, create a new tool_calls with this data.
     */
    create: XOR<tool_callsCreateInput, tool_callsUncheckedCreateInput>
    /**
     * In case the tool_calls was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tool_callsUpdateInput, tool_callsUncheckedUpdateInput>
  }

  /**
   * tool_calls delete
   */
  export type tool_callsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
    /**
     * Filter which tool_calls to delete.
     */
    where: tool_callsWhereUniqueInput
  }

  /**
   * tool_calls deleteMany
   */
  export type tool_callsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tool_calls to delete
     */
    where?: tool_callsWhereInput
    /**
     * Limit how many tool_calls to delete.
     */
    limit?: number
  }

  /**
   * tool_calls without action
   */
  export type tool_callsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tool_calls
     */
    select?: tool_callsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tool_calls
     */
    omit?: tool_callsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tool_callsInclude<ExtArgs> | null
  }


  /**
   * Model trades
   */

  export type AggregateTrades = {
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  export type TradesAvgAggregateOutputType = {
    qty: Decimal | null
    price: Decimal | null
  }

  export type TradesSumAggregateOutputType = {
    qty: Decimal | null
    price: Decimal | null
  }

  export type TradesMinAggregateOutputType = {
    id: string | null
    security_id: string | null
    qty: Decimal | null
    price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    currency: string | null
  }

  export type TradesMaxAggregateOutputType = {
    id: string | null
    security_id: string | null
    qty: Decimal | null
    price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
    currency: string | null
  }

  export type TradesCountAggregateOutputType = {
    id: number
    security_id: number
    qty: number
    price: number
    created_at: number
    updated_at: number
    currency: number
    locked_attributes: number
    _all: number
  }


  export type TradesAvgAggregateInputType = {
    qty?: true
    price?: true
  }

  export type TradesSumAggregateInputType = {
    qty?: true
    price?: true
  }

  export type TradesMinAggregateInputType = {
    id?: true
    security_id?: true
    qty?: true
    price?: true
    created_at?: true
    updated_at?: true
    currency?: true
  }

  export type TradesMaxAggregateInputType = {
    id?: true
    security_id?: true
    qty?: true
    price?: true
    created_at?: true
    updated_at?: true
    currency?: true
  }

  export type TradesCountAggregateInputType = {
    id?: true
    security_id?: true
    qty?: true
    price?: true
    created_at?: true
    updated_at?: true
    currency?: true
    locked_attributes?: true
    _all?: true
  }

  export type TradesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trades to aggregate.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trades
    **/
    _count?: true | TradesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TradesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TradesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TradesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TradesMaxAggregateInputType
  }

  export type GetTradesAggregateType<T extends TradesAggregateArgs> = {
        [P in keyof T & keyof AggregateTrades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrades[P]>
      : GetScalarType<T[P], AggregateTrades[P]>
  }




  export type tradesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tradesWhereInput
    orderBy?: tradesOrderByWithAggregationInput | tradesOrderByWithAggregationInput[]
    by: TradesScalarFieldEnum[] | TradesScalarFieldEnum
    having?: tradesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TradesCountAggregateInputType | true
    _avg?: TradesAvgAggregateInputType
    _sum?: TradesSumAggregateInputType
    _min?: TradesMinAggregateInputType
    _max?: TradesMaxAggregateInputType
  }

  export type TradesGroupByOutputType = {
    id: string
    security_id: string
    qty: Decimal | null
    price: Decimal | null
    created_at: Date
    updated_at: Date
    currency: string | null
    locked_attributes: JsonValue | null
    _count: TradesCountAggregateOutputType | null
    _avg: TradesAvgAggregateOutputType | null
    _sum: TradesSumAggregateOutputType | null
    _min: TradesMinAggregateOutputType | null
    _max: TradesMaxAggregateOutputType | null
  }

  type GetTradesGroupByPayload<T extends tradesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TradesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TradesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TradesGroupByOutputType[P]>
            : GetScalarType<T[P], TradesGroupByOutputType[P]>
        }
      >
    >


  export type tradesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    security_id?: boolean
    qty?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locked_attributes?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    security_id?: boolean
    qty?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locked_attributes?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    security_id?: boolean
    qty?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locked_attributes?: boolean
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trades"]>

  export type tradesSelectScalar = {
    id?: boolean
    security_id?: boolean
    qty?: boolean
    price?: boolean
    created_at?: boolean
    updated_at?: boolean
    currency?: boolean
    locked_attributes?: boolean
  }

  export type tradesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "security_id" | "qty" | "price" | "created_at" | "updated_at" | "currency" | "locked_attributes", ExtArgs["result"]["trades"]>
  export type tradesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }
  export type tradesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }
  export type tradesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    securities?: boolean | securitiesDefaultArgs<ExtArgs>
  }

  export type $tradesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trades"
    objects: {
      securities: Prisma.$securitiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      security_id: string
      qty: Prisma.Decimal | null
      price: Prisma.Decimal | null
      created_at: Date
      updated_at: Date
      currency: string | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["trades"]>
    composites: {}
  }

  type tradesGetPayload<S extends boolean | null | undefined | tradesDefaultArgs> = $Result.GetResult<Prisma.$tradesPayload, S>

  type tradesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tradesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TradesCountAggregateInputType | true
    }

  export interface tradesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trades'], meta: { name: 'trades' } }
    /**
     * Find zero or one Trades that matches the filter.
     * @param {tradesFindUniqueArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tradesFindUniqueArgs>(args: SelectSubset<T, tradesFindUniqueArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trades that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tradesFindUniqueOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tradesFindUniqueOrThrowArgs>(args: SelectSubset<T, tradesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindFirstArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tradesFindFirstArgs>(args?: SelectSubset<T, tradesFindFirstArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindFirstOrThrowArgs} args - Arguments to find a Trades
     * @example
     * // Get one Trades
     * const trades = await prisma.trades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tradesFindFirstOrThrowArgs>(args?: SelectSubset<T, tradesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trades
     * const trades = await prisma.trades.findMany()
     * 
     * // Get first 10 Trades
     * const trades = await prisma.trades.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tradesWithIdOnly = await prisma.trades.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tradesFindManyArgs>(args?: SelectSubset<T, tradesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trades.
     * @param {tradesCreateArgs} args - Arguments to create a Trades.
     * @example
     * // Create one Trades
     * const Trades = await prisma.trades.create({
     *   data: {
     *     // ... data to create a Trades
     *   }
     * })
     * 
     */
    create<T extends tradesCreateArgs>(args: SelectSubset<T, tradesCreateArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trades.
     * @param {tradesCreateManyArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trades = await prisma.trades.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tradesCreateManyArgs>(args?: SelectSubset<T, tradesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trades and returns the data saved in the database.
     * @param {tradesCreateManyAndReturnArgs} args - Arguments to create many Trades.
     * @example
     * // Create many Trades
     * const trades = await prisma.trades.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trades and only return the `id`
     * const tradesWithIdOnly = await prisma.trades.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tradesCreateManyAndReturnArgs>(args?: SelectSubset<T, tradesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trades.
     * @param {tradesDeleteArgs} args - Arguments to delete one Trades.
     * @example
     * // Delete one Trades
     * const Trades = await prisma.trades.delete({
     *   where: {
     *     // ... filter to delete one Trades
     *   }
     * })
     * 
     */
    delete<T extends tradesDeleteArgs>(args: SelectSubset<T, tradesDeleteArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trades.
     * @param {tradesUpdateArgs} args - Arguments to update one Trades.
     * @example
     * // Update one Trades
     * const trades = await prisma.trades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tradesUpdateArgs>(args: SelectSubset<T, tradesUpdateArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trades.
     * @param {tradesDeleteManyArgs} args - Arguments to filter Trades to delete.
     * @example
     * // Delete a few Trades
     * const { count } = await prisma.trades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tradesDeleteManyArgs>(args?: SelectSubset<T, tradesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trades
     * const trades = await prisma.trades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tradesUpdateManyArgs>(args: SelectSubset<T, tradesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trades and returns the data updated in the database.
     * @param {tradesUpdateManyAndReturnArgs} args - Arguments to update many Trades.
     * @example
     * // Update many Trades
     * const trades = await prisma.trades.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trades and only return the `id`
     * const tradesWithIdOnly = await prisma.trades.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tradesUpdateManyAndReturnArgs>(args: SelectSubset<T, tradesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trades.
     * @param {tradesUpsertArgs} args - Arguments to update or create a Trades.
     * @example
     * // Update or create a Trades
     * const trades = await prisma.trades.upsert({
     *   create: {
     *     // ... data to create a Trades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trades we want to update
     *   }
     * })
     */
    upsert<T extends tradesUpsertArgs>(args: SelectSubset<T, tradesUpsertArgs<ExtArgs>>): Prisma__tradesClient<$Result.GetResult<Prisma.$tradesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesCountArgs} args - Arguments to filter Trades to count.
     * @example
     * // Count the number of Trades
     * const count = await prisma.trades.count({
     *   where: {
     *     // ... the filter for the Trades we want to count
     *   }
     * })
    **/
    count<T extends tradesCountArgs>(
      args?: Subset<T, tradesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TradesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TradesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TradesAggregateArgs>(args: Subset<T, TradesAggregateArgs>): Prisma.PrismaPromise<GetTradesAggregateType<T>>

    /**
     * Group by Trades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tradesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tradesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tradesGroupByArgs['orderBy'] }
        : { orderBy?: tradesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tradesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTradesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trades model
   */
  readonly fields: tradesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tradesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    securities<T extends securitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, securitiesDefaultArgs<ExtArgs>>): Prisma__securitiesClient<$Result.GetResult<Prisma.$securitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trades model
   */
  interface tradesFieldRefs {
    readonly id: FieldRef<"trades", 'String'>
    readonly security_id: FieldRef<"trades", 'String'>
    readonly qty: FieldRef<"trades", 'Decimal'>
    readonly price: FieldRef<"trades", 'Decimal'>
    readonly created_at: FieldRef<"trades", 'DateTime'>
    readonly updated_at: FieldRef<"trades", 'DateTime'>
    readonly currency: FieldRef<"trades", 'String'>
    readonly locked_attributes: FieldRef<"trades", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * trades findUnique
   */
  export type tradesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades findUniqueOrThrow
   */
  export type tradesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades findFirst
   */
  export type tradesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trades.
     */
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades findFirstOrThrow
   */
  export type tradesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trades.
     */
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades findMany
   */
  export type tradesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter, which trades to fetch.
     */
    where?: tradesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trades to fetch.
     */
    orderBy?: tradesOrderByWithRelationInput | tradesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trades.
     */
    cursor?: tradesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trades.
     */
    skip?: number
    distinct?: TradesScalarFieldEnum | TradesScalarFieldEnum[]
  }

  /**
   * trades create
   */
  export type tradesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The data needed to create a trades.
     */
    data: XOR<tradesCreateInput, tradesUncheckedCreateInput>
  }

  /**
   * trades createMany
   */
  export type tradesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trades.
     */
    data: tradesCreateManyInput | tradesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trades createManyAndReturn
   */
  export type tradesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * The data used to create many trades.
     */
    data: tradesCreateManyInput | tradesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * trades update
   */
  export type tradesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The data needed to update a trades.
     */
    data: XOR<tradesUpdateInput, tradesUncheckedUpdateInput>
    /**
     * Choose, which trades to update.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades updateMany
   */
  export type tradesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trades.
     */
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyInput>
    /**
     * Filter which trades to update
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to update.
     */
    limit?: number
  }

  /**
   * trades updateManyAndReturn
   */
  export type tradesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * The data used to update trades.
     */
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyInput>
    /**
     * Filter which trades to update
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * trades upsert
   */
  export type tradesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * The filter to search for the trades to update in case it exists.
     */
    where: tradesWhereUniqueInput
    /**
     * In case the trades found by the `where` argument doesn't exist, create a new trades with this data.
     */
    create: XOR<tradesCreateInput, tradesUncheckedCreateInput>
    /**
     * In case the trades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tradesUpdateInput, tradesUncheckedUpdateInput>
  }

  /**
   * trades delete
   */
  export type tradesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
    /**
     * Filter which trades to delete.
     */
    where: tradesWhereUniqueInput
  }

  /**
   * trades deleteMany
   */
  export type tradesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trades to delete
     */
    where?: tradesWhereInput
    /**
     * Limit how many trades to delete.
     */
    limit?: number
  }

  /**
   * trades without action
   */
  export type tradesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trades
     */
    select?: tradesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trades
     */
    omit?: tradesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tradesInclude<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    category_id: string | null
    merchant_id: string | null
    plaid_category: string | null
    plaid_category_detailed: string | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    category_id: string | null
    merchant_id: string | null
    plaid_category: string | null
    plaid_category_detailed: string | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    category_id: number
    merchant_id: number
    locked_attributes: number
    plaid_category: number
    plaid_category_detailed: number
    _all: number
  }


  export type TransactionsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    merchant_id?: true
    plaid_category?: true
    plaid_category_detailed?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    merchant_id?: true
    plaid_category?: true
    plaid_category_detailed?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    merchant_id?: true
    locked_attributes?: true
    plaid_category?: true
    plaid_category_detailed?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    category_id: string | null
    merchant_id: string | null
    locked_attributes: JsonValue | null
    plaid_category: string | null
    plaid_category_detailed: string | null
    _count: TransactionsCountAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    merchant_id?: boolean
    locked_attributes?: boolean
    plaid_category?: boolean
    plaid_category_detailed?: boolean
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactions$rejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactions$rejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
    transfers_transfers_outflow_transaction_idTotransactions?: boolean | transactions$transfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>
    transfers_transfers_inflow_transaction_idTotransactions?: boolean | transactions$transfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    merchant_id?: boolean
    locked_attributes?: boolean
    plaid_category?: boolean
    plaid_category_detailed?: boolean
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    merchant_id?: boolean
    locked_attributes?: boolean
    plaid_category?: boolean
    plaid_category_detailed?: boolean
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type transactionsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    merchant_id?: boolean
    locked_attributes?: boolean
    plaid_category?: boolean
    plaid_category_detailed?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "category_id" | "merchant_id" | "locked_attributes" | "plaid_category" | "plaid_category_detailed", ExtArgs["result"]["transactions"]>
  export type transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: boolean | transactions$rejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: boolean | transactions$rejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
    transfers_transfers_outflow_transaction_idTotransactions?: boolean | transactions$transfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>
    transfers_transfers_inflow_transaction_idTotransactions?: boolean | transactions$transfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
  }
  export type transactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | transactions$categoriesArgs<ExtArgs>
    merchants?: boolean | transactions$merchantsArgs<ExtArgs>
  }

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {
      rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions: Prisma.$rejected_transfersPayload<ExtArgs>[]
      rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions: Prisma.$rejected_transfersPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      merchants: Prisma.$merchantsPayload<ExtArgs> | null
      transfers_transfers_outflow_transaction_idTotransactions: Prisma.$transfersPayload<ExtArgs>[]
      transfers_transfers_inflow_transaction_idTotransactions: Prisma.$transfersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      category_id: string | null
      merchant_id: string | null
      locked_attributes: Prisma.JsonValue | null
      plaid_category: string | null
      plaid_category_detailed: string | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {transactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {transactionsUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, transactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions<T extends transactions$rejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$rejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions<T extends transactions$rejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$rejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rejected_transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends transactions$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, transactions$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    merchants<T extends transactions$merchantsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$merchantsArgs<ExtArgs>>): Prisma__merchantsClient<$Result.GetResult<Prisma.$merchantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transfers_transfers_outflow_transaction_idTotransactions<T extends transactions$transfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$transfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transfers_transfers_inflow_transaction_idTotransactions<T extends transactions$transfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs> = {}>(args?: Subset<T, transactions$transfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */
  interface transactionsFieldRefs {
    readonly id: FieldRef<"transactions", 'String'>
    readonly created_at: FieldRef<"transactions", 'DateTime'>
    readonly updated_at: FieldRef<"transactions", 'DateTime'>
    readonly category_id: FieldRef<"transactions", 'String'>
    readonly merchant_id: FieldRef<"transactions", 'String'>
    readonly locked_attributes: FieldRef<"transactions", 'Json'>
    readonly plaid_category: FieldRef<"transactions", 'String'>
    readonly plaid_category_detailed: FieldRef<"transactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions createManyAndReturn
   */
  export type transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions updateManyAndReturn
   */
  export type transactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions.rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions
   */
  export type transactions$rejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    where?: rejected_transfersWhereInput
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    cursor?: rejected_transfersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rejected_transfersScalarFieldEnum | Rejected_transfersScalarFieldEnum[]
  }

  /**
   * transactions.rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions
   */
  export type transactions$rejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rejected_transfers
     */
    select?: rejected_transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rejected_transfers
     */
    omit?: rejected_transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rejected_transfersInclude<ExtArgs> | null
    where?: rejected_transfersWhereInput
    orderBy?: rejected_transfersOrderByWithRelationInput | rejected_transfersOrderByWithRelationInput[]
    cursor?: rejected_transfersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rejected_transfersScalarFieldEnum | Rejected_transfersScalarFieldEnum[]
  }

  /**
   * transactions.categories
   */
  export type transactions$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * transactions.merchants
   */
  export type transactions$merchantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the merchants
     */
    select?: merchantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the merchants
     */
    omit?: merchantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: merchantsInclude<ExtArgs> | null
    where?: merchantsWhereInput
  }

  /**
   * transactions.transfers_transfers_outflow_transaction_idTotransactions
   */
  export type transactions$transfers_transfers_outflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    where?: transfersWhereInput
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    cursor?: transfersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransfersScalarFieldEnum | TransfersScalarFieldEnum[]
  }

  /**
   * transactions.transfers_transfers_inflow_transaction_idTotransactions
   */
  export type transactions$transfers_transfers_inflow_transaction_idTotransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    where?: transfersWhereInput
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    cursor?: transfersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransfersScalarFieldEnum | TransfersScalarFieldEnum[]
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
  }


  /**
   * Model transfers
   */

  export type AggregateTransfers = {
    _count: TransfersCountAggregateOutputType | null
    _min: TransfersMinAggregateOutputType | null
    _max: TransfersMaxAggregateOutputType | null
  }

  export type TransfersMinAggregateOutputType = {
    id: string | null
    inflow_transaction_id: string | null
    outflow_transaction_id: string | null
    status: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransfersMaxAggregateOutputType = {
    id: string | null
    inflow_transaction_id: string | null
    outflow_transaction_id: string | null
    status: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransfersCountAggregateOutputType = {
    id: number
    inflow_transaction_id: number
    outflow_transaction_id: number
    status: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransfersMinAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type TransfersMaxAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type TransfersCountAggregateInputType = {
    id?: true
    inflow_transaction_id?: true
    outflow_transaction_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransfersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transfers to aggregate.
     */
    where?: transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transfers to fetch.
     */
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transfers
    **/
    _count?: true | TransfersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransfersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransfersMaxAggregateInputType
  }

  export type GetTransfersAggregateType<T extends TransfersAggregateArgs> = {
        [P in keyof T & keyof AggregateTransfers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransfers[P]>
      : GetScalarType<T[P], AggregateTransfers[P]>
  }




  export type transfersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transfersWhereInput
    orderBy?: transfersOrderByWithAggregationInput | transfersOrderByWithAggregationInput[]
    by: TransfersScalarFieldEnum[] | TransfersScalarFieldEnum
    having?: transfersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransfersCountAggregateInputType | true
    _min?: TransfersMinAggregateInputType
    _max?: TransfersMaxAggregateInputType
  }

  export type TransfersGroupByOutputType = {
    id: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    status: string
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: TransfersCountAggregateOutputType | null
    _min: TransfersMinAggregateOutputType | null
    _max: TransfersMaxAggregateOutputType | null
  }

  type GetTransfersGroupByPayload<T extends transfersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransfersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransfersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransfersGroupByOutputType[P]>
            : GetScalarType<T[P], TransfersGroupByOutputType[P]>
        }
      >
    >


  export type transfersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfers"]>

  export type transfersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfers"]>

  export type transfersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transfers"]>

  export type transfersSelectScalar = {
    id?: boolean
    inflow_transaction_id?: boolean
    outflow_transaction_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type transfersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inflow_transaction_id" | "outflow_transaction_id" | "status" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["transfers"]>
  export type transfersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }
  export type transfersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }
  export type transfersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions_transfers_outflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
    transactions_transfers_inflow_transaction_idTotransactions?: boolean | transactionsDefaultArgs<ExtArgs>
  }

  export type $transfersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transfers"
    objects: {
      transactions_transfers_outflow_transaction_idTotransactions: Prisma.$transactionsPayload<ExtArgs>
      transactions_transfers_inflow_transaction_idTotransactions: Prisma.$transactionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inflow_transaction_id: string
      outflow_transaction_id: string
      status: string
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["transfers"]>
    composites: {}
  }

  type transfersGetPayload<S extends boolean | null | undefined | transfersDefaultArgs> = $Result.GetResult<Prisma.$transfersPayload, S>

  type transfersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transfersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransfersCountAggregateInputType | true
    }

  export interface transfersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transfers'], meta: { name: 'transfers' } }
    /**
     * Find zero or one Transfers that matches the filter.
     * @param {transfersFindUniqueArgs} args - Arguments to find a Transfers
     * @example
     * // Get one Transfers
     * const transfers = await prisma.transfers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transfersFindUniqueArgs>(args: SelectSubset<T, transfersFindUniqueArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transfers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transfersFindUniqueOrThrowArgs} args - Arguments to find a Transfers
     * @example
     * // Get one Transfers
     * const transfers = await prisma.transfers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transfersFindUniqueOrThrowArgs>(args: SelectSubset<T, transfersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersFindFirstArgs} args - Arguments to find a Transfers
     * @example
     * // Get one Transfers
     * const transfers = await prisma.transfers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transfersFindFirstArgs>(args?: SelectSubset<T, transfersFindFirstArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transfers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersFindFirstOrThrowArgs} args - Arguments to find a Transfers
     * @example
     * // Get one Transfers
     * const transfers = await prisma.transfers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transfersFindFirstOrThrowArgs>(args?: SelectSubset<T, transfersFindFirstOrThrowArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transfers
     * const transfers = await prisma.transfers.findMany()
     * 
     * // Get first 10 Transfers
     * const transfers = await prisma.transfers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transfersWithIdOnly = await prisma.transfers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transfersFindManyArgs>(args?: SelectSubset<T, transfersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transfers.
     * @param {transfersCreateArgs} args - Arguments to create a Transfers.
     * @example
     * // Create one Transfers
     * const Transfers = await prisma.transfers.create({
     *   data: {
     *     // ... data to create a Transfers
     *   }
     * })
     * 
     */
    create<T extends transfersCreateArgs>(args: SelectSubset<T, transfersCreateArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transfers.
     * @param {transfersCreateManyArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfers = await prisma.transfers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transfersCreateManyArgs>(args?: SelectSubset<T, transfersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transfers and returns the data saved in the database.
     * @param {transfersCreateManyAndReturnArgs} args - Arguments to create many Transfers.
     * @example
     * // Create many Transfers
     * const transfers = await prisma.transfers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transfers and only return the `id`
     * const transfersWithIdOnly = await prisma.transfers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends transfersCreateManyAndReturnArgs>(args?: SelectSubset<T, transfersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transfers.
     * @param {transfersDeleteArgs} args - Arguments to delete one Transfers.
     * @example
     * // Delete one Transfers
     * const Transfers = await prisma.transfers.delete({
     *   where: {
     *     // ... filter to delete one Transfers
     *   }
     * })
     * 
     */
    delete<T extends transfersDeleteArgs>(args: SelectSubset<T, transfersDeleteArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transfers.
     * @param {transfersUpdateArgs} args - Arguments to update one Transfers.
     * @example
     * // Update one Transfers
     * const transfers = await prisma.transfers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transfersUpdateArgs>(args: SelectSubset<T, transfersUpdateArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transfers.
     * @param {transfersDeleteManyArgs} args - Arguments to filter Transfers to delete.
     * @example
     * // Delete a few Transfers
     * const { count } = await prisma.transfers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transfersDeleteManyArgs>(args?: SelectSubset<T, transfersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transfers
     * const transfers = await prisma.transfers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transfersUpdateManyArgs>(args: SelectSubset<T, transfersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transfers and returns the data updated in the database.
     * @param {transfersUpdateManyAndReturnArgs} args - Arguments to update many Transfers.
     * @example
     * // Update many Transfers
     * const transfers = await prisma.transfers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transfers and only return the `id`
     * const transfersWithIdOnly = await prisma.transfers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends transfersUpdateManyAndReturnArgs>(args: SelectSubset<T, transfersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transfers.
     * @param {transfersUpsertArgs} args - Arguments to update or create a Transfers.
     * @example
     * // Update or create a Transfers
     * const transfers = await prisma.transfers.upsert({
     *   create: {
     *     // ... data to create a Transfers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transfers we want to update
     *   }
     * })
     */
    upsert<T extends transfersUpsertArgs>(args: SelectSubset<T, transfersUpsertArgs<ExtArgs>>): Prisma__transfersClient<$Result.GetResult<Prisma.$transfersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersCountArgs} args - Arguments to filter Transfers to count.
     * @example
     * // Count the number of Transfers
     * const count = await prisma.transfers.count({
     *   where: {
     *     // ... the filter for the Transfers we want to count
     *   }
     * })
    **/
    count<T extends transfersCountArgs>(
      args?: Subset<T, transfersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransfersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransfersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransfersAggregateArgs>(args: Subset<T, TransfersAggregateArgs>): Prisma.PrismaPromise<GetTransfersAggregateType<T>>

    /**
     * Group by Transfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transfersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transfersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transfersGroupByArgs['orderBy'] }
        : { orderBy?: transfersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transfersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransfersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transfers model
   */
  readonly fields: transfersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transfers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transfersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions_transfers_outflow_transaction_idTotransactions<T extends transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transactionsDefaultArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions_transfers_inflow_transaction_idTotransactions<T extends transactionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, transactionsDefaultArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transfers model
   */
  interface transfersFieldRefs {
    readonly id: FieldRef<"transfers", 'String'>
    readonly inflow_transaction_id: FieldRef<"transfers", 'String'>
    readonly outflow_transaction_id: FieldRef<"transfers", 'String'>
    readonly status: FieldRef<"transfers", 'String'>
    readonly notes: FieldRef<"transfers", 'String'>
    readonly created_at: FieldRef<"transfers", 'DateTime'>
    readonly updated_at: FieldRef<"transfers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transfers findUnique
   */
  export type transfersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter, which transfers to fetch.
     */
    where: transfersWhereUniqueInput
  }

  /**
   * transfers findUniqueOrThrow
   */
  export type transfersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter, which transfers to fetch.
     */
    where: transfersWhereUniqueInput
  }

  /**
   * transfers findFirst
   */
  export type transfersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter, which transfers to fetch.
     */
    where?: transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transfers to fetch.
     */
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transfers.
     */
    cursor?: transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transfers.
     */
    distinct?: TransfersScalarFieldEnum | TransfersScalarFieldEnum[]
  }

  /**
   * transfers findFirstOrThrow
   */
  export type transfersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter, which transfers to fetch.
     */
    where?: transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transfers to fetch.
     */
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transfers.
     */
    cursor?: transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transfers.
     */
    distinct?: TransfersScalarFieldEnum | TransfersScalarFieldEnum[]
  }

  /**
   * transfers findMany
   */
  export type transfersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter, which transfers to fetch.
     */
    where?: transfersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transfers to fetch.
     */
    orderBy?: transfersOrderByWithRelationInput | transfersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transfers.
     */
    cursor?: transfersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transfers.
     */
    skip?: number
    distinct?: TransfersScalarFieldEnum | TransfersScalarFieldEnum[]
  }

  /**
   * transfers create
   */
  export type transfersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * The data needed to create a transfers.
     */
    data: XOR<transfersCreateInput, transfersUncheckedCreateInput>
  }

  /**
   * transfers createMany
   */
  export type transfersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transfers.
     */
    data: transfersCreateManyInput | transfersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transfers createManyAndReturn
   */
  export type transfersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * The data used to create many transfers.
     */
    data: transfersCreateManyInput | transfersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * transfers update
   */
  export type transfersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * The data needed to update a transfers.
     */
    data: XOR<transfersUpdateInput, transfersUncheckedUpdateInput>
    /**
     * Choose, which transfers to update.
     */
    where: transfersWhereUniqueInput
  }

  /**
   * transfers updateMany
   */
  export type transfersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transfers.
     */
    data: XOR<transfersUpdateManyMutationInput, transfersUncheckedUpdateManyInput>
    /**
     * Filter which transfers to update
     */
    where?: transfersWhereInput
    /**
     * Limit how many transfers to update.
     */
    limit?: number
  }

  /**
   * transfers updateManyAndReturn
   */
  export type transfersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * The data used to update transfers.
     */
    data: XOR<transfersUpdateManyMutationInput, transfersUncheckedUpdateManyInput>
    /**
     * Filter which transfers to update
     */
    where?: transfersWhereInput
    /**
     * Limit how many transfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * transfers upsert
   */
  export type transfersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * The filter to search for the transfers to update in case it exists.
     */
    where: transfersWhereUniqueInput
    /**
     * In case the transfers found by the `where` argument doesn't exist, create a new transfers with this data.
     */
    create: XOR<transfersCreateInput, transfersUncheckedCreateInput>
    /**
     * In case the transfers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transfersUpdateInput, transfersUncheckedUpdateInput>
  }

  /**
   * transfers delete
   */
  export type transfersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
    /**
     * Filter which transfers to delete.
     */
    where: transfersWhereUniqueInput
  }

  /**
   * transfers deleteMany
   */
  export type transfersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transfers to delete
     */
    where?: transfersWhereInput
    /**
     * Limit how many transfers to delete.
     */
    limit?: number
  }

  /**
   * transfers without action
   */
  export type transfersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transfers
     */
    select?: transfersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transfers
     */
    omit?: transfersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transfersInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    family_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_digest: string | null
    created_at: Date | null
    updated_at: Date | null
    role: string | null
    active: boolean | null
    onboarded_at: Date | null
    unconfirmed_email: string | null
    otp_secret: string | null
    otp_required: boolean | null
    show_sidebar: boolean | null
    default_period: string | null
    last_viewed_chat_id: string | null
    show_ai_sidebar: boolean | null
    ai_enabled: boolean | null
    theme: string | null
    rule_prompts_disabled: boolean | null
    rule_prompt_dismissed_at: Date | null
    set_onboarding_preferences_at: Date | null
    set_onboarding_goals_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    family_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password_digest: string | null
    created_at: Date | null
    updated_at: Date | null
    role: string | null
    active: boolean | null
    onboarded_at: Date | null
    unconfirmed_email: string | null
    otp_secret: string | null
    otp_required: boolean | null
    show_sidebar: boolean | null
    default_period: string | null
    last_viewed_chat_id: string | null
    show_ai_sidebar: boolean | null
    ai_enabled: boolean | null
    theme: string | null
    rule_prompts_disabled: boolean | null
    rule_prompt_dismissed_at: Date | null
    set_onboarding_preferences_at: Date | null
    set_onboarding_goals_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    family_id: number
    first_name: number
    last_name: number
    email: number
    password_digest: number
    created_at: number
    updated_at: number
    role: number
    active: number
    onboarded_at: number
    unconfirmed_email: number
    otp_secret: number
    otp_required: number
    otp_backup_codes: number
    show_sidebar: number
    default_period: number
    last_viewed_chat_id: number
    show_ai_sidebar: number
    ai_enabled: number
    theme: number
    rule_prompts_disabled: number
    rule_prompt_dismissed_at: number
    goals: number
    set_onboarding_preferences_at: number
    set_onboarding_goals_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    family_id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_digest?: true
    created_at?: true
    updated_at?: true
    role?: true
    active?: true
    onboarded_at?: true
    unconfirmed_email?: true
    otp_secret?: true
    otp_required?: true
    show_sidebar?: true
    default_period?: true
    last_viewed_chat_id?: true
    show_ai_sidebar?: true
    ai_enabled?: true
    theme?: true
    rule_prompts_disabled?: true
    rule_prompt_dismissed_at?: true
    set_onboarding_preferences_at?: true
    set_onboarding_goals_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    family_id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_digest?: true
    created_at?: true
    updated_at?: true
    role?: true
    active?: true
    onboarded_at?: true
    unconfirmed_email?: true
    otp_secret?: true
    otp_required?: true
    show_sidebar?: true
    default_period?: true
    last_viewed_chat_id?: true
    show_ai_sidebar?: true
    ai_enabled?: true
    theme?: true
    rule_prompts_disabled?: true
    rule_prompt_dismissed_at?: true
    set_onboarding_preferences_at?: true
    set_onboarding_goals_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    family_id?: true
    first_name?: true
    last_name?: true
    email?: true
    password_digest?: true
    created_at?: true
    updated_at?: true
    role?: true
    active?: true
    onboarded_at?: true
    unconfirmed_email?: true
    otp_secret?: true
    otp_required?: true
    otp_backup_codes?: true
    show_sidebar?: true
    default_period?: true
    last_viewed_chat_id?: true
    show_ai_sidebar?: true
    ai_enabled?: true
    theme?: true
    rule_prompts_disabled?: true
    rule_prompt_dismissed_at?: true
    goals?: true
    set_onboarding_preferences_at?: true
    set_onboarding_goals_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    family_id: string
    first_name: string | null
    last_name: string | null
    email: string | null
    password_digest: string | null
    created_at: Date
    updated_at: Date
    role: string
    active: boolean
    onboarded_at: Date | null
    unconfirmed_email: string | null
    otp_secret: string | null
    otp_required: boolean
    otp_backup_codes: string[]
    show_sidebar: boolean | null
    default_period: string
    last_viewed_chat_id: string | null
    show_ai_sidebar: boolean | null
    ai_enabled: boolean
    theme: string | null
    rule_prompts_disabled: boolean | null
    rule_prompt_dismissed_at: Date | null
    goals: string[]
    set_onboarding_preferences_at: Date | null
    set_onboarding_goals_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_digest?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    active?: boolean
    onboarded_at?: boolean
    unconfirmed_email?: boolean
    otp_secret?: boolean
    otp_required?: boolean
    otp_backup_codes?: boolean
    show_sidebar?: boolean
    default_period?: boolean
    last_viewed_chat_id?: boolean
    show_ai_sidebar?: boolean
    ai_enabled?: boolean
    theme?: boolean
    rule_prompts_disabled?: boolean
    rule_prompt_dismissed_at?: boolean
    goals?: boolean
    set_onboarding_preferences_at?: boolean
    set_onboarding_goals_at?: boolean
    chats_chats_user_idTousers?: boolean | users$chats_chats_user_idTousersArgs<ExtArgs>
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: boolean | users$impersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs>
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: boolean | users$impersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs>
    invitations?: boolean | users$invitationsArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_digest?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    active?: boolean
    onboarded_at?: boolean
    unconfirmed_email?: boolean
    otp_secret?: boolean
    otp_required?: boolean
    otp_backup_codes?: boolean
    show_sidebar?: boolean
    default_period?: boolean
    last_viewed_chat_id?: boolean
    show_ai_sidebar?: boolean
    ai_enabled?: boolean
    theme?: boolean
    rule_prompts_disabled?: boolean
    rule_prompt_dismissed_at?: boolean
    goals?: boolean
    set_onboarding_preferences_at?: boolean
    set_onboarding_goals_at?: boolean
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    family_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_digest?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    active?: boolean
    onboarded_at?: boolean
    unconfirmed_email?: boolean
    otp_secret?: boolean
    otp_required?: boolean
    otp_backup_codes?: boolean
    show_sidebar?: boolean
    default_period?: boolean
    last_viewed_chat_id?: boolean
    show_ai_sidebar?: boolean
    ai_enabled?: boolean
    theme?: boolean
    rule_prompts_disabled?: boolean
    rule_prompt_dismissed_at?: boolean
    goals?: boolean
    set_onboarding_preferences_at?: boolean
    set_onboarding_goals_at?: boolean
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    family_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password_digest?: boolean
    created_at?: boolean
    updated_at?: boolean
    role?: boolean
    active?: boolean
    onboarded_at?: boolean
    unconfirmed_email?: boolean
    otp_secret?: boolean
    otp_required?: boolean
    otp_backup_codes?: boolean
    show_sidebar?: boolean
    default_period?: boolean
    last_viewed_chat_id?: boolean
    show_ai_sidebar?: boolean
    ai_enabled?: boolean
    theme?: boolean
    rule_prompts_disabled?: boolean
    rule_prompt_dismissed_at?: boolean
    goals?: boolean
    set_onboarding_preferences_at?: boolean
    set_onboarding_goals_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "family_id" | "first_name" | "last_name" | "email" | "password_digest" | "created_at" | "updated_at" | "role" | "active" | "onboarded_at" | "unconfirmed_email" | "otp_secret" | "otp_required" | "otp_backup_codes" | "show_sidebar" | "default_period" | "last_viewed_chat_id" | "show_ai_sidebar" | "ai_enabled" | "theme" | "rule_prompts_disabled" | "rule_prompt_dismissed_at" | "goals" | "set_onboarding_preferences_at" | "set_onboarding_goals_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats_chats_user_idTousers?: boolean | users$chats_chats_user_idTousersArgs<ExtArgs>
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: boolean | users$impersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs>
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: boolean | users$impersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs>
    invitations?: boolean | users$invitationsArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats_users_last_viewed_chat_idTochats?: boolean | users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>
    families?: boolean | familiesDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      chats_chats_user_idTousers: Prisma.$chatsPayload<ExtArgs>[]
      impersonation_sessions_impersonation_sessions_impersonator_idTousers: Prisma.$impersonation_sessionsPayload<ExtArgs>[]
      impersonation_sessions_impersonation_sessions_impersonated_idTousers: Prisma.$impersonation_sessionsPayload<ExtArgs>[]
      invitations: Prisma.$invitationsPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      chats_users_last_viewed_chat_idTochats: Prisma.$chatsPayload<ExtArgs> | null
      families: Prisma.$familiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      family_id: string
      first_name: string | null
      last_name: string | null
      email: string | null
      password_digest: string | null
      created_at: Date
      updated_at: Date
      role: string
      active: boolean
      onboarded_at: Date | null
      unconfirmed_email: string | null
      otp_secret: string | null
      otp_required: boolean
      otp_backup_codes: string[]
      show_sidebar: boolean | null
      default_period: string
      last_viewed_chat_id: string | null
      show_ai_sidebar: boolean | null
      ai_enabled: boolean
      theme: string | null
      rule_prompts_disabled: boolean | null
      rule_prompt_dismissed_at: Date | null
      goals: string[]
      set_onboarding_preferences_at: Date | null
      set_onboarding_goals_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats_chats_user_idTousers<T extends users$chats_chats_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$chats_chats_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    impersonation_sessions_impersonation_sessions_impersonator_idTousers<T extends users$impersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$impersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    impersonation_sessions_impersonation_sessions_impersonated_idTousers<T extends users$impersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$impersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$impersonation_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends users$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, users$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats_users_last_viewed_chat_idTochats<T extends users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs> = {}>(args?: Subset<T, users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    families<T extends familiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, familiesDefaultArgs<ExtArgs>>): Prisma__familiesClient<$Result.GetResult<Prisma.$familiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly family_id: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_digest: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly role: FieldRef<"users", 'String'>
    readonly active: FieldRef<"users", 'Boolean'>
    readonly onboarded_at: FieldRef<"users", 'DateTime'>
    readonly unconfirmed_email: FieldRef<"users", 'String'>
    readonly otp_secret: FieldRef<"users", 'String'>
    readonly otp_required: FieldRef<"users", 'Boolean'>
    readonly otp_backup_codes: FieldRef<"users", 'String[]'>
    readonly show_sidebar: FieldRef<"users", 'Boolean'>
    readonly default_period: FieldRef<"users", 'String'>
    readonly last_viewed_chat_id: FieldRef<"users", 'String'>
    readonly show_ai_sidebar: FieldRef<"users", 'Boolean'>
    readonly ai_enabled: FieldRef<"users", 'Boolean'>
    readonly theme: FieldRef<"users", 'String'>
    readonly rule_prompts_disabled: FieldRef<"users", 'Boolean'>
    readonly rule_prompt_dismissed_at: FieldRef<"users", 'DateTime'>
    readonly goals: FieldRef<"users", 'String[]'>
    readonly set_onboarding_preferences_at: FieldRef<"users", 'DateTime'>
    readonly set_onboarding_goals_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.chats_chats_user_idTousers
   */
  export type users$chats_chats_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    where?: chatsWhereInput
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    cursor?: chatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * users.impersonation_sessions_impersonation_sessions_impersonator_idTousers
   */
  export type users$impersonation_sessions_impersonation_sessions_impersonator_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    where?: impersonation_sessionsWhereInput
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    cursor?: impersonation_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Impersonation_sessionsScalarFieldEnum | Impersonation_sessionsScalarFieldEnum[]
  }

  /**
   * users.impersonation_sessions_impersonation_sessions_impersonated_idTousers
   */
  export type users$impersonation_sessions_impersonation_sessions_impersonated_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the impersonation_sessions
     */
    select?: impersonation_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the impersonation_sessions
     */
    omit?: impersonation_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: impersonation_sessionsInclude<ExtArgs> | null
    where?: impersonation_sessionsWhereInput
    orderBy?: impersonation_sessionsOrderByWithRelationInput | impersonation_sessionsOrderByWithRelationInput[]
    cursor?: impersonation_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Impersonation_sessionsScalarFieldEnum | Impersonation_sessionsScalarFieldEnum[]
  }

  /**
   * users.invitations
   */
  export type users$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invitations
     */
    select?: invitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invitations
     */
    omit?: invitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invitationsInclude<ExtArgs> | null
    where?: invitationsWhereInput
    orderBy?: invitationsOrderByWithRelationInput | invitationsOrderByWithRelationInput[]
    cursor?: invitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * users.chats_users_last_viewed_chat_idTochats
   */
  export type users$chats_users_last_viewed_chat_idTochatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    where?: chatsWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model valuations
   */

  export type AggregateValuations = {
    _count: ValuationsCountAggregateOutputType | null
    _min: ValuationsMinAggregateOutputType | null
    _max: ValuationsMaxAggregateOutputType | null
  }

  export type ValuationsMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ValuationsMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ValuationsCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    locked_attributes: number
    _all: number
  }


  export type ValuationsMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ValuationsMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ValuationsCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    locked_attributes?: true
    _all?: true
  }

  export type ValuationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which valuations to aggregate.
     */
    where?: valuationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of valuations to fetch.
     */
    orderBy?: valuationsOrderByWithRelationInput | valuationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: valuationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` valuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` valuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned valuations
    **/
    _count?: true | ValuationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValuationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValuationsMaxAggregateInputType
  }

  export type GetValuationsAggregateType<T extends ValuationsAggregateArgs> = {
        [P in keyof T & keyof AggregateValuations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValuations[P]>
      : GetScalarType<T[P], AggregateValuations[P]>
  }




  export type valuationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: valuationsWhereInput
    orderBy?: valuationsOrderByWithAggregationInput | valuationsOrderByWithAggregationInput[]
    by: ValuationsScalarFieldEnum[] | ValuationsScalarFieldEnum
    having?: valuationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValuationsCountAggregateInputType | true
    _min?: ValuationsMinAggregateInputType
    _max?: ValuationsMaxAggregateInputType
  }

  export type ValuationsGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    locked_attributes: JsonValue | null
    _count: ValuationsCountAggregateOutputType | null
    _min: ValuationsMinAggregateOutputType | null
    _max: ValuationsMaxAggregateOutputType | null
  }

  type GetValuationsGroupByPayload<T extends valuationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValuationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValuationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValuationsGroupByOutputType[P]>
            : GetScalarType<T[P], ValuationsGroupByOutputType[P]>
        }
      >
    >


  export type valuationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["valuations"]>

  export type valuationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["valuations"]>

  export type valuationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["valuations"]>

  export type valuationsSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    locked_attributes?: boolean
  }

  export type valuationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "locked_attributes", ExtArgs["result"]["valuations"]>

  export type $valuationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "valuations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["valuations"]>
    composites: {}
  }

  type valuationsGetPayload<S extends boolean | null | undefined | valuationsDefaultArgs> = $Result.GetResult<Prisma.$valuationsPayload, S>

  type valuationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<valuationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ValuationsCountAggregateInputType | true
    }

  export interface valuationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['valuations'], meta: { name: 'valuations' } }
    /**
     * Find zero or one Valuations that matches the filter.
     * @param {valuationsFindUniqueArgs} args - Arguments to find a Valuations
     * @example
     * // Get one Valuations
     * const valuations = await prisma.valuations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends valuationsFindUniqueArgs>(args: SelectSubset<T, valuationsFindUniqueArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Valuations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {valuationsFindUniqueOrThrowArgs} args - Arguments to find a Valuations
     * @example
     * // Get one Valuations
     * const valuations = await prisma.valuations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends valuationsFindUniqueOrThrowArgs>(args: SelectSubset<T, valuationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Valuations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsFindFirstArgs} args - Arguments to find a Valuations
     * @example
     * // Get one Valuations
     * const valuations = await prisma.valuations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends valuationsFindFirstArgs>(args?: SelectSubset<T, valuationsFindFirstArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Valuations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsFindFirstOrThrowArgs} args - Arguments to find a Valuations
     * @example
     * // Get one Valuations
     * const valuations = await prisma.valuations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends valuationsFindFirstOrThrowArgs>(args?: SelectSubset<T, valuationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Valuations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Valuations
     * const valuations = await prisma.valuations.findMany()
     * 
     * // Get first 10 Valuations
     * const valuations = await prisma.valuations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const valuationsWithIdOnly = await prisma.valuations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends valuationsFindManyArgs>(args?: SelectSubset<T, valuationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Valuations.
     * @param {valuationsCreateArgs} args - Arguments to create a Valuations.
     * @example
     * // Create one Valuations
     * const Valuations = await prisma.valuations.create({
     *   data: {
     *     // ... data to create a Valuations
     *   }
     * })
     * 
     */
    create<T extends valuationsCreateArgs>(args: SelectSubset<T, valuationsCreateArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Valuations.
     * @param {valuationsCreateManyArgs} args - Arguments to create many Valuations.
     * @example
     * // Create many Valuations
     * const valuations = await prisma.valuations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends valuationsCreateManyArgs>(args?: SelectSubset<T, valuationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Valuations and returns the data saved in the database.
     * @param {valuationsCreateManyAndReturnArgs} args - Arguments to create many Valuations.
     * @example
     * // Create many Valuations
     * const valuations = await prisma.valuations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Valuations and only return the `id`
     * const valuationsWithIdOnly = await prisma.valuations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends valuationsCreateManyAndReturnArgs>(args?: SelectSubset<T, valuationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Valuations.
     * @param {valuationsDeleteArgs} args - Arguments to delete one Valuations.
     * @example
     * // Delete one Valuations
     * const Valuations = await prisma.valuations.delete({
     *   where: {
     *     // ... filter to delete one Valuations
     *   }
     * })
     * 
     */
    delete<T extends valuationsDeleteArgs>(args: SelectSubset<T, valuationsDeleteArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Valuations.
     * @param {valuationsUpdateArgs} args - Arguments to update one Valuations.
     * @example
     * // Update one Valuations
     * const valuations = await prisma.valuations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends valuationsUpdateArgs>(args: SelectSubset<T, valuationsUpdateArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Valuations.
     * @param {valuationsDeleteManyArgs} args - Arguments to filter Valuations to delete.
     * @example
     * // Delete a few Valuations
     * const { count } = await prisma.valuations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends valuationsDeleteManyArgs>(args?: SelectSubset<T, valuationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Valuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Valuations
     * const valuations = await prisma.valuations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends valuationsUpdateManyArgs>(args: SelectSubset<T, valuationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Valuations and returns the data updated in the database.
     * @param {valuationsUpdateManyAndReturnArgs} args - Arguments to update many Valuations.
     * @example
     * // Update many Valuations
     * const valuations = await prisma.valuations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Valuations and only return the `id`
     * const valuationsWithIdOnly = await prisma.valuations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends valuationsUpdateManyAndReturnArgs>(args: SelectSubset<T, valuationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Valuations.
     * @param {valuationsUpsertArgs} args - Arguments to update or create a Valuations.
     * @example
     * // Update or create a Valuations
     * const valuations = await prisma.valuations.upsert({
     *   create: {
     *     // ... data to create a Valuations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Valuations we want to update
     *   }
     * })
     */
    upsert<T extends valuationsUpsertArgs>(args: SelectSubset<T, valuationsUpsertArgs<ExtArgs>>): Prisma__valuationsClient<$Result.GetResult<Prisma.$valuationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Valuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsCountArgs} args - Arguments to filter Valuations to count.
     * @example
     * // Count the number of Valuations
     * const count = await prisma.valuations.count({
     *   where: {
     *     // ... the filter for the Valuations we want to count
     *   }
     * })
    **/
    count<T extends valuationsCountArgs>(
      args?: Subset<T, valuationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValuationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Valuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValuationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValuationsAggregateArgs>(args: Subset<T, ValuationsAggregateArgs>): Prisma.PrismaPromise<GetValuationsAggregateType<T>>

    /**
     * Group by Valuations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {valuationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends valuationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: valuationsGroupByArgs['orderBy'] }
        : { orderBy?: valuationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, valuationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValuationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the valuations model
   */
  readonly fields: valuationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for valuations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__valuationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the valuations model
   */
  interface valuationsFieldRefs {
    readonly id: FieldRef<"valuations", 'String'>
    readonly created_at: FieldRef<"valuations", 'DateTime'>
    readonly updated_at: FieldRef<"valuations", 'DateTime'>
    readonly locked_attributes: FieldRef<"valuations", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * valuations findUnique
   */
  export type valuationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter, which valuations to fetch.
     */
    where: valuationsWhereUniqueInput
  }

  /**
   * valuations findUniqueOrThrow
   */
  export type valuationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter, which valuations to fetch.
     */
    where: valuationsWhereUniqueInput
  }

  /**
   * valuations findFirst
   */
  export type valuationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter, which valuations to fetch.
     */
    where?: valuationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of valuations to fetch.
     */
    orderBy?: valuationsOrderByWithRelationInput | valuationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for valuations.
     */
    cursor?: valuationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` valuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` valuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of valuations.
     */
    distinct?: ValuationsScalarFieldEnum | ValuationsScalarFieldEnum[]
  }

  /**
   * valuations findFirstOrThrow
   */
  export type valuationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter, which valuations to fetch.
     */
    where?: valuationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of valuations to fetch.
     */
    orderBy?: valuationsOrderByWithRelationInput | valuationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for valuations.
     */
    cursor?: valuationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` valuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` valuations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of valuations.
     */
    distinct?: ValuationsScalarFieldEnum | ValuationsScalarFieldEnum[]
  }

  /**
   * valuations findMany
   */
  export type valuationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter, which valuations to fetch.
     */
    where?: valuationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of valuations to fetch.
     */
    orderBy?: valuationsOrderByWithRelationInput | valuationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing valuations.
     */
    cursor?: valuationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` valuations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` valuations.
     */
    skip?: number
    distinct?: ValuationsScalarFieldEnum | ValuationsScalarFieldEnum[]
  }

  /**
   * valuations create
   */
  export type valuationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * The data needed to create a valuations.
     */
    data: XOR<valuationsCreateInput, valuationsUncheckedCreateInput>
  }

  /**
   * valuations createMany
   */
  export type valuationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many valuations.
     */
    data: valuationsCreateManyInput | valuationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * valuations createManyAndReturn
   */
  export type valuationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * The data used to create many valuations.
     */
    data: valuationsCreateManyInput | valuationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * valuations update
   */
  export type valuationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * The data needed to update a valuations.
     */
    data: XOR<valuationsUpdateInput, valuationsUncheckedUpdateInput>
    /**
     * Choose, which valuations to update.
     */
    where: valuationsWhereUniqueInput
  }

  /**
   * valuations updateMany
   */
  export type valuationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update valuations.
     */
    data: XOR<valuationsUpdateManyMutationInput, valuationsUncheckedUpdateManyInput>
    /**
     * Filter which valuations to update
     */
    where?: valuationsWhereInput
    /**
     * Limit how many valuations to update.
     */
    limit?: number
  }

  /**
   * valuations updateManyAndReturn
   */
  export type valuationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * The data used to update valuations.
     */
    data: XOR<valuationsUpdateManyMutationInput, valuationsUncheckedUpdateManyInput>
    /**
     * Filter which valuations to update
     */
    where?: valuationsWhereInput
    /**
     * Limit how many valuations to update.
     */
    limit?: number
  }

  /**
   * valuations upsert
   */
  export type valuationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * The filter to search for the valuations to update in case it exists.
     */
    where: valuationsWhereUniqueInput
    /**
     * In case the valuations found by the `where` argument doesn't exist, create a new valuations with this data.
     */
    create: XOR<valuationsCreateInput, valuationsUncheckedCreateInput>
    /**
     * In case the valuations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<valuationsUpdateInput, valuationsUncheckedUpdateInput>
  }

  /**
   * valuations delete
   */
  export type valuationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
    /**
     * Filter which valuations to delete.
     */
    where: valuationsWhereUniqueInput
  }

  /**
   * valuations deleteMany
   */
  export type valuationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which valuations to delete
     */
    where?: valuationsWhereInput
    /**
     * Limit how many valuations to delete.
     */
    limit?: number
  }

  /**
   * valuations without action
   */
  export type valuationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the valuations
     */
    select?: valuationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the valuations
     */
    omit?: valuationsOmit<ExtArgs> | null
  }


  /**
   * Model vehicles
   */

  export type AggregateVehicles = {
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  export type VehiclesAvgAggregateOutputType = {
    year: number | null
    mileage_value: number | null
  }

  export type VehiclesSumAggregateOutputType = {
    year: number | null
    mileage_value: number | null
  }

  export type VehiclesMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    year: number | null
    mileage_value: number | null
    mileage_unit: string | null
    make: string | null
    model: string | null
  }

  export type VehiclesMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
    year: number | null
    mileage_value: number | null
    mileage_unit: string | null
    make: string | null
    model: string | null
  }

  export type VehiclesCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    year: number
    mileage_value: number
    mileage_unit: number
    make: number
    model: number
    locked_attributes: number
    _all: number
  }


  export type VehiclesAvgAggregateInputType = {
    year?: true
    mileage_value?: true
  }

  export type VehiclesSumAggregateInputType = {
    year?: true
    mileage_value?: true
  }

  export type VehiclesMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year?: true
    mileage_value?: true
    mileage_unit?: true
    make?: true
    model?: true
  }

  export type VehiclesMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year?: true
    mileage_value?: true
    mileage_unit?: true
    make?: true
    model?: true
  }

  export type VehiclesCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    year?: true
    mileage_value?: true
    mileage_unit?: true
    make?: true
    model?: true
    locked_attributes?: true
    _all?: true
  }

  export type VehiclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to aggregate.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    _count?: true | VehiclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehiclesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehiclesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehiclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehiclesMaxAggregateInputType
  }

  export type GetVehiclesAggregateType<T extends VehiclesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicles[P]>
      : GetScalarType<T[P], AggregateVehicles[P]>
  }




  export type vehiclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehiclesWhereInput
    orderBy?: vehiclesOrderByWithAggregationInput | vehiclesOrderByWithAggregationInput[]
    by: VehiclesScalarFieldEnum[] | VehiclesScalarFieldEnum
    having?: vehiclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehiclesCountAggregateInputType | true
    _avg?: VehiclesAvgAggregateInputType
    _sum?: VehiclesSumAggregateInputType
    _min?: VehiclesMinAggregateInputType
    _max?: VehiclesMaxAggregateInputType
  }

  export type VehiclesGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    year: number | null
    mileage_value: number | null
    mileage_unit: string | null
    make: string | null
    model: string | null
    locked_attributes: JsonValue | null
    _count: VehiclesCountAggregateOutputType | null
    _avg: VehiclesAvgAggregateOutputType | null
    _sum: VehiclesSumAggregateOutputType | null
    _min: VehiclesMinAggregateOutputType | null
    _max: VehiclesMaxAggregateOutputType | null
  }

  type GetVehiclesGroupByPayload<T extends vehiclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehiclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehiclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
            : GetScalarType<T[P], VehiclesGroupByOutputType[P]>
        }
      >
    >


  export type vehiclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year?: boolean
    mileage_value?: boolean
    mileage_unit?: boolean
    make?: boolean
    model?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year?: boolean
    mileage_value?: boolean
    mileage_unit?: boolean
    make?: boolean
    model?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year?: boolean
    mileage_value?: boolean
    mileage_unit?: boolean
    make?: boolean
    model?: boolean
    locked_attributes?: boolean
  }, ExtArgs["result"]["vehicles"]>

  export type vehiclesSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    year?: boolean
    mileage_value?: boolean
    mileage_unit?: boolean
    make?: boolean
    model?: boolean
    locked_attributes?: boolean
  }

  export type vehiclesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at" | "year" | "mileage_value" | "mileage_unit" | "make" | "model" | "locked_attributes", ExtArgs["result"]["vehicles"]>

  export type $vehiclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
      year: number | null
      mileage_value: number | null
      mileage_unit: string | null
      make: string | null
      model: string | null
      locked_attributes: Prisma.JsonValue | null
    }, ExtArgs["result"]["vehicles"]>
    composites: {}
  }

  type vehiclesGetPayload<S extends boolean | null | undefined | vehiclesDefaultArgs> = $Result.GetResult<Prisma.$vehiclesPayload, S>

  type vehiclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehiclesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehiclesCountAggregateInputType | true
    }

  export interface vehiclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicles'], meta: { name: 'vehicles' } }
    /**
     * Find zero or one Vehicles that matches the filter.
     * @param {vehiclesFindUniqueArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehiclesFindUniqueArgs>(args: SelectSubset<T, vehiclesFindUniqueArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehiclesFindUniqueOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehiclesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehiclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehiclesFindFirstArgs>(args?: SelectSubset<T, vehiclesFindFirstArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindFirstOrThrowArgs} args - Arguments to find a Vehicles
     * @example
     * // Get one Vehicles
     * const vehicles = await prisma.vehicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehiclesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehiclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicles.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehiclesFindManyArgs>(args?: SelectSubset<T, vehiclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicles.
     * @param {vehiclesCreateArgs} args - Arguments to create a Vehicles.
     * @example
     * // Create one Vehicles
     * const Vehicles = await prisma.vehicles.create({
     *   data: {
     *     // ... data to create a Vehicles
     *   }
     * })
     * 
     */
    create<T extends vehiclesCreateArgs>(args: SelectSubset<T, vehiclesCreateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {vehiclesCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehiclesCreateManyArgs>(args?: SelectSubset<T, vehiclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {vehiclesCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicles = await prisma.vehicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends vehiclesCreateManyAndReturnArgs>(args?: SelectSubset<T, vehiclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicles.
     * @param {vehiclesDeleteArgs} args - Arguments to delete one Vehicles.
     * @example
     * // Delete one Vehicles
     * const Vehicles = await prisma.vehicles.delete({
     *   where: {
     *     // ... filter to delete one Vehicles
     *   }
     * })
     * 
     */
    delete<T extends vehiclesDeleteArgs>(args: SelectSubset<T, vehiclesDeleteArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicles.
     * @param {vehiclesUpdateArgs} args - Arguments to update one Vehicles.
     * @example
     * // Update one Vehicles
     * const vehicles = await prisma.vehicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehiclesUpdateArgs>(args: SelectSubset<T, vehiclesUpdateArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {vehiclesDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehiclesDeleteManyArgs>(args?: SelectSubset<T, vehiclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehiclesUpdateManyArgs>(args: SelectSubset<T, vehiclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {vehiclesUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicles = await prisma.vehicles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehiclesWithIdOnly = await prisma.vehicles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends vehiclesUpdateManyAndReturnArgs>(args: SelectSubset<T, vehiclesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicles.
     * @param {vehiclesUpsertArgs} args - Arguments to update or create a Vehicles.
     * @example
     * // Update or create a Vehicles
     * const vehicles = await prisma.vehicles.upsert({
     *   create: {
     *     // ... data to create a Vehicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicles we want to update
     *   }
     * })
     */
    upsert<T extends vehiclesUpsertArgs>(args: SelectSubset<T, vehiclesUpsertArgs<ExtArgs>>): Prisma__vehiclesClient<$Result.GetResult<Prisma.$vehiclesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicles.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehiclesCountArgs>(
      args?: Subset<T, vehiclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehiclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehiclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehiclesAggregateArgs>(args: Subset<T, VehiclesAggregateArgs>): Prisma.PrismaPromise<GetVehiclesAggregateType<T>>

    /**
     * Group by Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehiclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehiclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehiclesGroupByArgs['orderBy'] }
        : { orderBy?: vehiclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehiclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehiclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicles model
   */
  readonly fields: vehiclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehiclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicles model
   */
  interface vehiclesFieldRefs {
    readonly id: FieldRef<"vehicles", 'String'>
    readonly created_at: FieldRef<"vehicles", 'DateTime'>
    readonly updated_at: FieldRef<"vehicles", 'DateTime'>
    readonly year: FieldRef<"vehicles", 'Int'>
    readonly mileage_value: FieldRef<"vehicles", 'Int'>
    readonly mileage_unit: FieldRef<"vehicles", 'String'>
    readonly make: FieldRef<"vehicles", 'String'>
    readonly model: FieldRef<"vehicles", 'String'>
    readonly locked_attributes: FieldRef<"vehicles", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * vehicles findUnique
   */
  export type vehiclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findUniqueOrThrow
   */
  export type vehiclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles findFirst
   */
  export type vehiclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findFirstOrThrow
   */
  export type vehiclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles findMany
   */
  export type vehiclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehiclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehiclesOrderByWithRelationInput | vehiclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
     */
    cursor?: vehiclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    distinct?: VehiclesScalarFieldEnum | VehiclesScalarFieldEnum[]
  }

  /**
   * vehicles create
   */
  export type vehiclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data needed to create a vehicles.
     */
    data: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
  }

  /**
   * vehicles createMany
   */
  export type vehiclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles createManyAndReturn
   */
  export type vehiclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to create many vehicles.
     */
    data: vehiclesCreateManyInput | vehiclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * vehicles update
   */
  export type vehiclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data needed to update a vehicles.
     */
    data: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
    /**
     * Choose, which vehicles to update.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles updateMany
   */
  export type vehiclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicles updateManyAndReturn
   */
  export type vehiclesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehiclesUpdateManyMutationInput, vehiclesUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicles upsert
   */
  export type vehiclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * The filter to search for the vehicles to update in case it exists.
     */
    where: vehiclesWhereUniqueInput
    /**
     * In case the vehicles found by the `where` argument doesn't exist, create a new vehicles with this data.
     */
    create: XOR<vehiclesCreateInput, vehiclesUncheckedCreateInput>
    /**
     * In case the vehicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehiclesUpdateInput, vehiclesUncheckedUpdateInput>
  }

  /**
   * vehicles delete
   */
  export type vehiclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
    /**
     * Filter which vehicles to delete.
     */
    where: vehiclesWhereUniqueInput
  }

  /**
   * vehicles deleteMany
   */
  export type vehiclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to delete
     */
    where?: vehiclesWhereInput
    /**
     * Limit how many vehicles to delete.
     */
    limit?: number
  }

  /**
   * vehicles without action
   */
  export type vehiclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicles
     */
    select?: vehiclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicles
     */
    omit?: vehiclesOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    subtype: 'subtype',
    family_id: 'family_id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    accountable_type: 'accountable_type',
    accountable_id: 'accountable_id',
    balance: 'balance',
    currency: 'currency',
    is_active: 'is_active',
    classification: 'classification',
    import_id: 'import_id',
    plaid_account_id: 'plaid_account_id',
    scheduled_for_deletion: 'scheduled_for_deletion',
    last_synced_at: 'last_synced_at',
    cash_balance: 'cash_balance',
    locked_attributes: 'locked_attributes'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const Active_storage_attachmentsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    record_type: 'record_type',
    record_id: 'record_id',
    blob_id: 'blob_id',
    created_at: 'created_at'
  };

  export type Active_storage_attachmentsScalarFieldEnum = (typeof Active_storage_attachmentsScalarFieldEnum)[keyof typeof Active_storage_attachmentsScalarFieldEnum]


  export const Active_storage_blobsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    filename: 'filename',
    content_type: 'content_type',
    metadata: 'metadata',
    service_name: 'service_name',
    byte_size: 'byte_size',
    checksum: 'checksum',
    created_at: 'created_at'
  };

  export type Active_storage_blobsScalarFieldEnum = (typeof Active_storage_blobsScalarFieldEnum)[keyof typeof Active_storage_blobsScalarFieldEnum]


  export const Active_storage_variant_recordsScalarFieldEnum: {
    id: 'id',
    blob_id: 'blob_id',
    variation_digest: 'variation_digest'
  };

  export type Active_storage_variant_recordsScalarFieldEnum = (typeof Active_storage_variant_recordsScalarFieldEnum)[keyof typeof Active_storage_variant_recordsScalarFieldEnum]


  export const AddressesScalarFieldEnum: {
    id: 'id',
    addressable_type: 'addressable_type',
    addressable_id: 'addressable_id',
    line1: 'line1',
    line2: 'line2',
    county: 'county',
    locality: 'locality',
    region: 'region',
    country: 'country',
    postal_code: 'postal_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AddressesScalarFieldEnum = (typeof AddressesScalarFieldEnum)[keyof typeof AddressesScalarFieldEnum]


  export const Ar_internal_metadataScalarFieldEnum: {
    key: 'key',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Ar_internal_metadataScalarFieldEnum = (typeof Ar_internal_metadataScalarFieldEnum)[keyof typeof Ar_internal_metadataScalarFieldEnum]


  export const BalancesScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    date: 'date',
    balance: 'balance',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at',
    cash_balance: 'cash_balance'
  };

  export type BalancesScalarFieldEnum = (typeof BalancesScalarFieldEnum)[keyof typeof BalancesScalarFieldEnum]


  export const Budget_categoriesScalarFieldEnum: {
    id: 'id',
    budget_id: 'budget_id',
    category_id: 'category_id',
    budgeted_spending: 'budgeted_spending',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Budget_categoriesScalarFieldEnum = (typeof Budget_categoriesScalarFieldEnum)[keyof typeof Budget_categoriesScalarFieldEnum]


  export const BudgetsScalarFieldEnum: {
    id: 'id',
    family_id: 'family_id',
    start_date: 'start_date',
    end_date: 'end_date',
    budgeted_spending: 'budgeted_spending',
    expected_income: 'expected_income',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BudgetsScalarFieldEnum = (typeof BudgetsScalarFieldEnum)[keyof typeof BudgetsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    family_id: 'family_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    parent_id: 'parent_id',
    classification: 'classification',
    lucide_icon: 'lucide_icon'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const ChatsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    instructions: 'instructions',
    error: 'error',
    latest_assistant_response_id: 'latest_assistant_response_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChatsScalarFieldEnum = (typeof ChatsScalarFieldEnum)[keyof typeof ChatsScalarFieldEnum]


  export const Credit_cardsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    available_credit: 'available_credit',
    minimum_payment: 'minimum_payment',
    apr: 'apr',
    expiration_date: 'expiration_date',
    annual_fee: 'annual_fee',
    locked_attributes: 'locked_attributes'
  };

  export type Credit_cardsScalarFieldEnum = (typeof Credit_cardsScalarFieldEnum)[keyof typeof Credit_cardsScalarFieldEnum]


  export const CryptosScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type CryptosScalarFieldEnum = (typeof CryptosScalarFieldEnum)[keyof typeof CryptosScalarFieldEnum]


  export const Data_enrichmentsScalarFieldEnum: {
    id: 'id',
    enrichable_type: 'enrichable_type',
    enrichable_id: 'enrichable_id',
    source: 'source',
    attribute_name: 'attribute_name',
    value: 'value',
    metadata: 'metadata',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Data_enrichmentsScalarFieldEnum = (typeof Data_enrichmentsScalarFieldEnum)[keyof typeof Data_enrichmentsScalarFieldEnum]


  export const DepositoriesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type DepositoriesScalarFieldEnum = (typeof DepositoriesScalarFieldEnum)[keyof typeof DepositoriesScalarFieldEnum]


  export const EntriesScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    entryable_type: 'entryable_type',
    entryable_id: 'entryable_id',
    amount: 'amount',
    currency: 'currency',
    date: 'date',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    import_id: 'import_id',
    notes: 'notes',
    excluded: 'excluded',
    plaid_id: 'plaid_id',
    locked_attributes: 'locked_attributes'
  };

  export type EntriesScalarFieldEnum = (typeof EntriesScalarFieldEnum)[keyof typeof EntriesScalarFieldEnum]


  export const Exchange_ratesScalarFieldEnum: {
    id: 'id',
    from_currency: 'from_currency',
    to_currency: 'to_currency',
    rate: 'rate',
    date: 'date',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Exchange_ratesScalarFieldEnum = (typeof Exchange_ratesScalarFieldEnum)[keyof typeof Exchange_ratesScalarFieldEnum]


  export const FamiliesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    currency: 'currency',
    locale: 'locale',
    stripe_plan_id: 'stripe_plan_id',
    stripe_customer_id: 'stripe_customer_id',
    stripe_subscription_status: 'stripe_subscription_status',
    date_format: 'date_format',
    country: 'country',
    last_synced_at: 'last_synced_at',
    timezone: 'timezone',
    data_enrichment_enabled: 'data_enrichment_enabled',
    trial_started_at: 'trial_started_at',
    early_access: 'early_access'
  };

  export type FamiliesScalarFieldEnum = (typeof FamiliesScalarFieldEnum)[keyof typeof FamiliesScalarFieldEnum]


  export const HoldingsScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    security_id: 'security_id',
    date: 'date',
    qty: 'qty',
    price: 'price',
    amount: 'amount',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type HoldingsScalarFieldEnum = (typeof HoldingsScalarFieldEnum)[keyof typeof HoldingsScalarFieldEnum]


  export const Impersonation_session_logsScalarFieldEnum: {
    id: 'id',
    impersonation_session_id: 'impersonation_session_id',
    controller: 'controller',
    action: 'action',
    path: 'path',
    method: 'method',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Impersonation_session_logsScalarFieldEnum = (typeof Impersonation_session_logsScalarFieldEnum)[keyof typeof Impersonation_session_logsScalarFieldEnum]


  export const Impersonation_sessionsScalarFieldEnum: {
    id: 'id',
    impersonator_id: 'impersonator_id',
    impersonated_id: 'impersonated_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Impersonation_sessionsScalarFieldEnum = (typeof Impersonation_sessionsScalarFieldEnum)[keyof typeof Impersonation_sessionsScalarFieldEnum]


  export const Import_mappingsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    key: 'key',
    value: 'value',
    create_when_empty: 'create_when_empty',
    import_id: 'import_id',
    mappable_type: 'mappable_type',
    mappable_id: 'mappable_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Import_mappingsScalarFieldEnum = (typeof Import_mappingsScalarFieldEnum)[keyof typeof Import_mappingsScalarFieldEnum]


  export const Import_rowsScalarFieldEnum: {
    id: 'id',
    import_id: 'import_id',
    account: 'account',
    date: 'date',
    qty: 'qty',
    ticker: 'ticker',
    price: 'price',
    amount: 'amount',
    currency: 'currency',
    name: 'name',
    category: 'category',
    tags: 'tags',
    entity_type: 'entity_type',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at',
    exchange_operating_mic: 'exchange_operating_mic'
  };

  export type Import_rowsScalarFieldEnum = (typeof Import_rowsScalarFieldEnum)[keyof typeof Import_rowsScalarFieldEnum]


  export const ImportsScalarFieldEnum: {
    id: 'id',
    column_mappings: 'column_mappings',
    status: 'status',
    raw_file_str: 'raw_file_str',
    normalized_csv_str: 'normalized_csv_str',
    created_at: 'created_at',
    updated_at: 'updated_at',
    col_sep: 'col_sep',
    family_id: 'family_id',
    account_id: 'account_id',
    type: 'type',
    date_col_label: 'date_col_label',
    amount_col_label: 'amount_col_label',
    name_col_label: 'name_col_label',
    category_col_label: 'category_col_label',
    tags_col_label: 'tags_col_label',
    account_col_label: 'account_col_label',
    qty_col_label: 'qty_col_label',
    ticker_col_label: 'ticker_col_label',
    price_col_label: 'price_col_label',
    entity_type_col_label: 'entity_type_col_label',
    notes_col_label: 'notes_col_label',
    currency_col_label: 'currency_col_label',
    date_format: 'date_format',
    signage_convention: 'signage_convention',
    error: 'error',
    number_format: 'number_format',
    exchange_operating_mic_col_label: 'exchange_operating_mic_col_label',
    amount_type_strategy: 'amount_type_strategy',
    amount_type_inflow_value: 'amount_type_inflow_value'
  };

  export type ImportsScalarFieldEnum = (typeof ImportsScalarFieldEnum)[keyof typeof ImportsScalarFieldEnum]


  export const InvestmentsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type InvestmentsScalarFieldEnum = (typeof InvestmentsScalarFieldEnum)[keyof typeof InvestmentsScalarFieldEnum]


  export const InvitationsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    role: 'role',
    token: 'token',
    family_id: 'family_id',
    inviter_id: 'inviter_id',
    accepted_at: 'accepted_at',
    expires_at: 'expires_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvitationsScalarFieldEnum = (typeof InvitationsScalarFieldEnum)[keyof typeof InvitationsScalarFieldEnum]


  export const Invite_codesScalarFieldEnum: {
    id: 'id',
    token: 'token',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Invite_codesScalarFieldEnum = (typeof Invite_codesScalarFieldEnum)[keyof typeof Invite_codesScalarFieldEnum]


  export const LoansScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    rate_type: 'rate_type',
    interest_rate: 'interest_rate',
    term_months: 'term_months',
    initial_balance: 'initial_balance',
    locked_attributes: 'locked_attributes'
  };

  export type LoansScalarFieldEnum = (typeof LoansScalarFieldEnum)[keyof typeof LoansScalarFieldEnum]


  export const MerchantsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    family_id: 'family_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    logo_url: 'logo_url',
    website_url: 'website_url',
    type: 'type',
    source: 'source',
    provider_merchant_id: 'provider_merchant_id'
  };

  export type MerchantsScalarFieldEnum = (typeof MerchantsScalarFieldEnum)[keyof typeof MerchantsScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    chat_id: 'chat_id',
    type: 'type',
    status: 'status',
    content: 'content',
    ai_model: 'ai_model',
    created_at: 'created_at',
    updated_at: 'updated_at',
    debug: 'debug',
    provider_id: 'provider_id',
    reasoning: 'reasoning'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const Other_assetsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type Other_assetsScalarFieldEnum = (typeof Other_assetsScalarFieldEnum)[keyof typeof Other_assetsScalarFieldEnum]


  export const Other_liabilitiesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type Other_liabilitiesScalarFieldEnum = (typeof Other_liabilitiesScalarFieldEnum)[keyof typeof Other_liabilitiesScalarFieldEnum]


  export const Plaid_accountsScalarFieldEnum: {
    id: 'id',
    plaid_item_id: 'plaid_item_id',
    plaid_id: 'plaid_id',
    plaid_type: 'plaid_type',
    plaid_subtype: 'plaid_subtype',
    current_balance: 'current_balance',
    available_balance: 'available_balance',
    currency: 'currency',
    name: 'name',
    mask: 'mask',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Plaid_accountsScalarFieldEnum = (typeof Plaid_accountsScalarFieldEnum)[keyof typeof Plaid_accountsScalarFieldEnum]


  export const Plaid_itemsScalarFieldEnum: {
    id: 'id',
    family_id: 'family_id',
    access_token: 'access_token',
    plaid_id: 'plaid_id',
    name: 'name',
    next_cursor: 'next_cursor',
    scheduled_for_deletion: 'scheduled_for_deletion',
    created_at: 'created_at',
    updated_at: 'updated_at',
    available_products: 'available_products',
    billed_products: 'billed_products',
    last_synced_at: 'last_synced_at',
    plaid_region: 'plaid_region',
    institution_url: 'institution_url',
    institution_id: 'institution_id',
    institution_color: 'institution_color',
    status: 'status'
  };

  export type Plaid_itemsScalarFieldEnum = (typeof Plaid_itemsScalarFieldEnum)[keyof typeof Plaid_itemsScalarFieldEnum]


  export const PropertiesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    year_built: 'year_built',
    area_value: 'area_value',
    area_unit: 'area_unit',
    locked_attributes: 'locked_attributes'
  };

  export type PropertiesScalarFieldEnum = (typeof PropertiesScalarFieldEnum)[keyof typeof PropertiesScalarFieldEnum]


  export const Rejected_transfersScalarFieldEnum: {
    id: 'id',
    inflow_transaction_id: 'inflow_transaction_id',
    outflow_transaction_id: 'outflow_transaction_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Rejected_transfersScalarFieldEnum = (typeof Rejected_transfersScalarFieldEnum)[keyof typeof Rejected_transfersScalarFieldEnum]


  export const Rule_actionsScalarFieldEnum: {
    id: 'id',
    rule_id: 'rule_id',
    action_type: 'action_type',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Rule_actionsScalarFieldEnum = (typeof Rule_actionsScalarFieldEnum)[keyof typeof Rule_actionsScalarFieldEnum]


  export const Rule_conditionsScalarFieldEnum: {
    id: 'id',
    rule_id: 'rule_id',
    parent_id: 'parent_id',
    condition_type: 'condition_type',
    operator: 'operator',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Rule_conditionsScalarFieldEnum = (typeof Rule_conditionsScalarFieldEnum)[keyof typeof Rule_conditionsScalarFieldEnum]


  export const RulesScalarFieldEnum: {
    id: 'id',
    family_id: 'family_id',
    resource_type: 'resource_type',
    effective_date: 'effective_date',
    active: 'active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RulesScalarFieldEnum = (typeof RulesScalarFieldEnum)[keyof typeof RulesScalarFieldEnum]


  export const Schema_migrationsScalarFieldEnum: {
    version: 'version'
  };

  export type Schema_migrationsScalarFieldEnum = (typeof Schema_migrationsScalarFieldEnum)[keyof typeof Schema_migrationsScalarFieldEnum]


  export const SecuritiesScalarFieldEnum: {
    id: 'id',
    ticker: 'ticker',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    country_code: 'country_code',
    exchange_mic: 'exchange_mic',
    exchange_acronym: 'exchange_acronym',
    logo_url: 'logo_url',
    exchange_operating_mic: 'exchange_operating_mic'
  };

  export type SecuritiesScalarFieldEnum = (typeof SecuritiesScalarFieldEnum)[keyof typeof SecuritiesScalarFieldEnum]


  export const Security_pricesScalarFieldEnum: {
    id: 'id',
    date: 'date',
    price: 'price',
    currency: 'currency',
    created_at: 'created_at',
    updated_at: 'updated_at',
    security_id: 'security_id'
  };

  export type Security_pricesScalarFieldEnum = (typeof Security_pricesScalarFieldEnum)[keyof typeof Security_pricesScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    active_impersonator_session_id: 'active_impersonator_session_id',
    subscribed_at: 'subscribed_at',
    prev_transaction_page_params: 'prev_transaction_page_params'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    var: 'var',
    value: 'value',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Stock_exchangesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    acronym: 'acronym',
    mic: 'mic',
    country: 'country',
    country_code: 'country_code',
    city: 'city',
    website: 'website',
    timezone_name: 'timezone_name',
    timezone_abbr: 'timezone_abbr',
    timezone_abbr_dst: 'timezone_abbr_dst',
    currency_code: 'currency_code',
    currency_symbol: 'currency_symbol',
    currency_name: 'currency_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Stock_exchangesScalarFieldEnum = (typeof Stock_exchangesScalarFieldEnum)[keyof typeof Stock_exchangesScalarFieldEnum]


  export const SyncsScalarFieldEnum: {
    id: 'id',
    syncable_type: 'syncable_type',
    syncable_id: 'syncable_id',
    last_ran_at: 'last_ran_at',
    start_date: 'start_date',
    status: 'status',
    error: 'error',
    data: 'data',
    created_at: 'created_at',
    updated_at: 'updated_at',
    error_backtrace: 'error_backtrace',
    parent_id: 'parent_id'
  };

  export type SyncsScalarFieldEnum = (typeof SyncsScalarFieldEnum)[keyof typeof SyncsScalarFieldEnum]


  export const TaggingsScalarFieldEnum: {
    id: 'id',
    tag_id: 'tag_id',
    taggable_type: 'taggable_type',
    taggable_id: 'taggable_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TaggingsScalarFieldEnum = (typeof TaggingsScalarFieldEnum)[keyof typeof TaggingsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    family_id: 'family_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const Tool_callsScalarFieldEnum: {
    id: 'id',
    message_id: 'message_id',
    provider_id: 'provider_id',
    provider_call_id: 'provider_call_id',
    type: 'type',
    function_name: 'function_name',
    function_arguments: 'function_arguments',
    function_result: 'function_result',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Tool_callsScalarFieldEnum = (typeof Tool_callsScalarFieldEnum)[keyof typeof Tool_callsScalarFieldEnum]


  export const TradesScalarFieldEnum: {
    id: 'id',
    security_id: 'security_id',
    qty: 'qty',
    price: 'price',
    created_at: 'created_at',
    updated_at: 'updated_at',
    currency: 'currency',
    locked_attributes: 'locked_attributes'
  };

  export type TradesScalarFieldEnum = (typeof TradesScalarFieldEnum)[keyof typeof TradesScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    category_id: 'category_id',
    merchant_id: 'merchant_id',
    locked_attributes: 'locked_attributes',
    plaid_category: 'plaid_category',
    plaid_category_detailed: 'plaid_category_detailed'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const TransfersScalarFieldEnum: {
    id: 'id',
    inflow_transaction_id: 'inflow_transaction_id',
    outflow_transaction_id: 'outflow_transaction_id',
    status: 'status',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransfersScalarFieldEnum = (typeof TransfersScalarFieldEnum)[keyof typeof TransfersScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    family_id: 'family_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password_digest: 'password_digest',
    created_at: 'created_at',
    updated_at: 'updated_at',
    role: 'role',
    active: 'active',
    onboarded_at: 'onboarded_at',
    unconfirmed_email: 'unconfirmed_email',
    otp_secret: 'otp_secret',
    otp_required: 'otp_required',
    otp_backup_codes: 'otp_backup_codes',
    show_sidebar: 'show_sidebar',
    default_period: 'default_period',
    last_viewed_chat_id: 'last_viewed_chat_id',
    show_ai_sidebar: 'show_ai_sidebar',
    ai_enabled: 'ai_enabled',
    theme: 'theme',
    rule_prompts_disabled: 'rule_prompts_disabled',
    rule_prompt_dismissed_at: 'rule_prompt_dismissed_at',
    goals: 'goals',
    set_onboarding_preferences_at: 'set_onboarding_preferences_at',
    set_onboarding_goals_at: 'set_onboarding_goals_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ValuationsScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locked_attributes: 'locked_attributes'
  };

  export type ValuationsScalarFieldEnum = (typeof ValuationsScalarFieldEnum)[keyof typeof ValuationsScalarFieldEnum]


  export const VehiclesScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    year: 'year',
    mileage_value: 'mileage_value',
    mileage_unit: 'mileage_unit',
    make: 'make',
    model: 'model',
    locked_attributes: 'locked_attributes'
  };

  export type VehiclesScalarFieldEnum = (typeof VehiclesScalarFieldEnum)[keyof typeof VehiclesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: UuidFilter<"accounts"> | string
    subtype?: StringNullableFilter<"accounts"> | string | null
    family_id?: UuidFilter<"accounts"> | string
    name?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    accountable_type?: StringNullableFilter<"accounts"> | string | null
    accountable_id?: UuidNullableFilter<"accounts"> | string | null
    balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"accounts"> | string | null
    is_active?: BoolFilter<"accounts"> | boolean
    classification?: StringNullableFilter<"accounts"> | string | null
    import_id?: UuidNullableFilter<"accounts"> | string | null
    plaid_account_id?: UuidNullableFilter<"accounts"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"accounts"> | boolean | null
    last_synced_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    cash_balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"accounts">
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    imports?: XOR<ImportsNullableScalarRelationFilter, importsWhereInput> | null
    plaid_accounts?: XOR<Plaid_accountsNullableScalarRelationFilter, plaid_accountsWhereInput> | null
    balances?: BalancesListRelationFilter
    entries?: EntriesListRelationFilter
    holdings?: HoldingsListRelationFilter
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    subtype?: SortOrderInput | SortOrder
    family_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accountable_type?: SortOrderInput | SortOrder
    accountable_id?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrder
    classification?: SortOrderInput | SortOrder
    import_id?: SortOrderInput | SortOrder
    plaid_account_id?: SortOrderInput | SortOrder
    scheduled_for_deletion?: SortOrderInput | SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    cash_balance?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    families?: familiesOrderByWithRelationInput
    imports?: importsOrderByWithRelationInput
    plaid_accounts?: plaid_accountsOrderByWithRelationInput
    balances?: balancesOrderByRelationAggregateInput
    entries?: entriesOrderByRelationAggregateInput
    holdings?: holdingsOrderByRelationAggregateInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    subtype?: StringNullableFilter<"accounts"> | string | null
    family_id?: UuidFilter<"accounts"> | string
    name?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    accountable_type?: StringNullableFilter<"accounts"> | string | null
    accountable_id?: UuidNullableFilter<"accounts"> | string | null
    balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"accounts"> | string | null
    is_active?: BoolFilter<"accounts"> | boolean
    classification?: StringNullableFilter<"accounts"> | string | null
    import_id?: UuidNullableFilter<"accounts"> | string | null
    plaid_account_id?: UuidNullableFilter<"accounts"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"accounts"> | boolean | null
    last_synced_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    cash_balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"accounts">
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    imports?: XOR<ImportsNullableScalarRelationFilter, importsWhereInput> | null
    plaid_accounts?: XOR<Plaid_accountsNullableScalarRelationFilter, plaid_accountsWhereInput> | null
    balances?: BalancesListRelationFilter
    entries?: EntriesListRelationFilter
    holdings?: HoldingsListRelationFilter
  }, "id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    subtype?: SortOrderInput | SortOrder
    family_id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accountable_type?: SortOrderInput | SortOrder
    accountable_id?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    is_active?: SortOrder
    classification?: SortOrderInput | SortOrder
    import_id?: SortOrderInput | SortOrder
    plaid_account_id?: SortOrderInput | SortOrder
    scheduled_for_deletion?: SortOrderInput | SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    cash_balance?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"accounts"> | string
    subtype?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    family_id?: UuidWithAggregatesFilter<"accounts"> | string
    name?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
    accountable_type?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    accountable_id?: UuidNullableWithAggregatesFilter<"accounts"> | string | null
    balance?: DecimalNullableWithAggregatesFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    is_active?: BoolWithAggregatesFilter<"accounts"> | boolean
    classification?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    import_id?: UuidNullableWithAggregatesFilter<"accounts"> | string | null
    plaid_account_id?: UuidNullableWithAggregatesFilter<"accounts"> | string | null
    scheduled_for_deletion?: BoolNullableWithAggregatesFilter<"accounts"> | boolean | null
    last_synced_at?: DateTimeNullableWithAggregatesFilter<"accounts"> | Date | string | null
    cash_balance?: DecimalNullableWithAggregatesFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"accounts">
  }

  export type active_storage_attachmentsWhereInput = {
    AND?: active_storage_attachmentsWhereInput | active_storage_attachmentsWhereInput[]
    OR?: active_storage_attachmentsWhereInput[]
    NOT?: active_storage_attachmentsWhereInput | active_storage_attachmentsWhereInput[]
    id?: UuidFilter<"active_storage_attachments"> | string
    name?: StringFilter<"active_storage_attachments"> | string
    record_type?: StringFilter<"active_storage_attachments"> | string
    record_id?: UuidFilter<"active_storage_attachments"> | string
    blob_id?: UuidFilter<"active_storage_attachments"> | string
    created_at?: DateTimeFilter<"active_storage_attachments"> | Date | string
    active_storage_blobs?: XOR<Active_storage_blobsScalarRelationFilter, active_storage_blobsWhereInput>
  }

  export type active_storage_attachmentsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    record_type?: SortOrder
    record_id?: SortOrder
    blob_id?: SortOrder
    created_at?: SortOrder
    active_storage_blobs?: active_storage_blobsOrderByWithRelationInput
  }

  export type active_storage_attachmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    record_type_record_id_name_blob_id?: active_storage_attachmentsRecord_typeRecord_idNameBlob_idCompoundUniqueInput
    AND?: active_storage_attachmentsWhereInput | active_storage_attachmentsWhereInput[]
    OR?: active_storage_attachmentsWhereInput[]
    NOT?: active_storage_attachmentsWhereInput | active_storage_attachmentsWhereInput[]
    name?: StringFilter<"active_storage_attachments"> | string
    record_type?: StringFilter<"active_storage_attachments"> | string
    record_id?: UuidFilter<"active_storage_attachments"> | string
    blob_id?: UuidFilter<"active_storage_attachments"> | string
    created_at?: DateTimeFilter<"active_storage_attachments"> | Date | string
    active_storage_blobs?: XOR<Active_storage_blobsScalarRelationFilter, active_storage_blobsWhereInput>
  }, "id" | "record_type_record_id_name_blob_id">

  export type active_storage_attachmentsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    record_type?: SortOrder
    record_id?: SortOrder
    blob_id?: SortOrder
    created_at?: SortOrder
    _count?: active_storage_attachmentsCountOrderByAggregateInput
    _max?: active_storage_attachmentsMaxOrderByAggregateInput
    _min?: active_storage_attachmentsMinOrderByAggregateInput
  }

  export type active_storage_attachmentsScalarWhereWithAggregatesInput = {
    AND?: active_storage_attachmentsScalarWhereWithAggregatesInput | active_storage_attachmentsScalarWhereWithAggregatesInput[]
    OR?: active_storage_attachmentsScalarWhereWithAggregatesInput[]
    NOT?: active_storage_attachmentsScalarWhereWithAggregatesInput | active_storage_attachmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"active_storage_attachments"> | string
    name?: StringWithAggregatesFilter<"active_storage_attachments"> | string
    record_type?: StringWithAggregatesFilter<"active_storage_attachments"> | string
    record_id?: UuidWithAggregatesFilter<"active_storage_attachments"> | string
    blob_id?: UuidWithAggregatesFilter<"active_storage_attachments"> | string
    created_at?: DateTimeWithAggregatesFilter<"active_storage_attachments"> | Date | string
  }

  export type active_storage_blobsWhereInput = {
    AND?: active_storage_blobsWhereInput | active_storage_blobsWhereInput[]
    OR?: active_storage_blobsWhereInput[]
    NOT?: active_storage_blobsWhereInput | active_storage_blobsWhereInput[]
    id?: UuidFilter<"active_storage_blobs"> | string
    key?: StringFilter<"active_storage_blobs"> | string
    filename?: StringFilter<"active_storage_blobs"> | string
    content_type?: StringNullableFilter<"active_storage_blobs"> | string | null
    metadata?: StringNullableFilter<"active_storage_blobs"> | string | null
    service_name?: StringFilter<"active_storage_blobs"> | string
    byte_size?: BigIntFilter<"active_storage_blobs"> | bigint | number
    checksum?: StringNullableFilter<"active_storage_blobs"> | string | null
    created_at?: DateTimeFilter<"active_storage_blobs"> | Date | string
    active_storage_attachments?: Active_storage_attachmentsListRelationFilter
    active_storage_variant_records?: Active_storage_variant_recordsListRelationFilter
  }

  export type active_storage_blobsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    content_type?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    service_name?: SortOrder
    byte_size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    created_at?: SortOrder
    active_storage_attachments?: active_storage_attachmentsOrderByRelationAggregateInput
    active_storage_variant_records?: active_storage_variant_recordsOrderByRelationAggregateInput
  }

  export type active_storage_blobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: active_storage_blobsWhereInput | active_storage_blobsWhereInput[]
    OR?: active_storage_blobsWhereInput[]
    NOT?: active_storage_blobsWhereInput | active_storage_blobsWhereInput[]
    filename?: StringFilter<"active_storage_blobs"> | string
    content_type?: StringNullableFilter<"active_storage_blobs"> | string | null
    metadata?: StringNullableFilter<"active_storage_blobs"> | string | null
    service_name?: StringFilter<"active_storage_blobs"> | string
    byte_size?: BigIntFilter<"active_storage_blobs"> | bigint | number
    checksum?: StringNullableFilter<"active_storage_blobs"> | string | null
    created_at?: DateTimeFilter<"active_storage_blobs"> | Date | string
    active_storage_attachments?: Active_storage_attachmentsListRelationFilter
    active_storage_variant_records?: Active_storage_variant_recordsListRelationFilter
  }, "id" | "key">

  export type active_storage_blobsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    content_type?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    service_name?: SortOrder
    byte_size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: active_storage_blobsCountOrderByAggregateInput
    _avg?: active_storage_blobsAvgOrderByAggregateInput
    _max?: active_storage_blobsMaxOrderByAggregateInput
    _min?: active_storage_blobsMinOrderByAggregateInput
    _sum?: active_storage_blobsSumOrderByAggregateInput
  }

  export type active_storage_blobsScalarWhereWithAggregatesInput = {
    AND?: active_storage_blobsScalarWhereWithAggregatesInput | active_storage_blobsScalarWhereWithAggregatesInput[]
    OR?: active_storage_blobsScalarWhereWithAggregatesInput[]
    NOT?: active_storage_blobsScalarWhereWithAggregatesInput | active_storage_blobsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"active_storage_blobs"> | string
    key?: StringWithAggregatesFilter<"active_storage_blobs"> | string
    filename?: StringWithAggregatesFilter<"active_storage_blobs"> | string
    content_type?: StringNullableWithAggregatesFilter<"active_storage_blobs"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"active_storage_blobs"> | string | null
    service_name?: StringWithAggregatesFilter<"active_storage_blobs"> | string
    byte_size?: BigIntWithAggregatesFilter<"active_storage_blobs"> | bigint | number
    checksum?: StringNullableWithAggregatesFilter<"active_storage_blobs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"active_storage_blobs"> | Date | string
  }

  export type active_storage_variant_recordsWhereInput = {
    AND?: active_storage_variant_recordsWhereInput | active_storage_variant_recordsWhereInput[]
    OR?: active_storage_variant_recordsWhereInput[]
    NOT?: active_storage_variant_recordsWhereInput | active_storage_variant_recordsWhereInput[]
    id?: UuidFilter<"active_storage_variant_records"> | string
    blob_id?: UuidFilter<"active_storage_variant_records"> | string
    variation_digest?: StringFilter<"active_storage_variant_records"> | string
    active_storage_blobs?: XOR<Active_storage_blobsScalarRelationFilter, active_storage_blobsWhereInput>
  }

  export type active_storage_variant_recordsOrderByWithRelationInput = {
    id?: SortOrder
    blob_id?: SortOrder
    variation_digest?: SortOrder
    active_storage_blobs?: active_storage_blobsOrderByWithRelationInput
  }

  export type active_storage_variant_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blob_id_variation_digest?: active_storage_variant_recordsBlob_idVariation_digestCompoundUniqueInput
    AND?: active_storage_variant_recordsWhereInput | active_storage_variant_recordsWhereInput[]
    OR?: active_storage_variant_recordsWhereInput[]
    NOT?: active_storage_variant_recordsWhereInput | active_storage_variant_recordsWhereInput[]
    blob_id?: UuidFilter<"active_storage_variant_records"> | string
    variation_digest?: StringFilter<"active_storage_variant_records"> | string
    active_storage_blobs?: XOR<Active_storage_blobsScalarRelationFilter, active_storage_blobsWhereInput>
  }, "id" | "blob_id_variation_digest">

  export type active_storage_variant_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    blob_id?: SortOrder
    variation_digest?: SortOrder
    _count?: active_storage_variant_recordsCountOrderByAggregateInput
    _max?: active_storage_variant_recordsMaxOrderByAggregateInput
    _min?: active_storage_variant_recordsMinOrderByAggregateInput
  }

  export type active_storage_variant_recordsScalarWhereWithAggregatesInput = {
    AND?: active_storage_variant_recordsScalarWhereWithAggregatesInput | active_storage_variant_recordsScalarWhereWithAggregatesInput[]
    OR?: active_storage_variant_recordsScalarWhereWithAggregatesInput[]
    NOT?: active_storage_variant_recordsScalarWhereWithAggregatesInput | active_storage_variant_recordsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"active_storage_variant_records"> | string
    blob_id?: UuidWithAggregatesFilter<"active_storage_variant_records"> | string
    variation_digest?: StringWithAggregatesFilter<"active_storage_variant_records"> | string
  }

  export type addressesWhereInput = {
    AND?: addressesWhereInput | addressesWhereInput[]
    OR?: addressesWhereInput[]
    NOT?: addressesWhereInput | addressesWhereInput[]
    id?: UuidFilter<"addresses"> | string
    addressable_type?: StringNullableFilter<"addresses"> | string | null
    addressable_id?: UuidNullableFilter<"addresses"> | string | null
    line1?: StringNullableFilter<"addresses"> | string | null
    line2?: StringNullableFilter<"addresses"> | string | null
    county?: StringNullableFilter<"addresses"> | string | null
    locality?: StringNullableFilter<"addresses"> | string | null
    region?: StringNullableFilter<"addresses"> | string | null
    country?: StringNullableFilter<"addresses"> | string | null
    postal_code?: IntNullableFilter<"addresses"> | number | null
    created_at?: DateTimeFilter<"addresses"> | Date | string
    updated_at?: DateTimeFilter<"addresses"> | Date | string
  }

  export type addressesOrderByWithRelationInput = {
    id?: SortOrder
    addressable_type?: SortOrderInput | SortOrder
    addressable_id?: SortOrderInput | SortOrder
    line1?: SortOrderInput | SortOrder
    line2?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    locality?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type addressesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: addressesWhereInput | addressesWhereInput[]
    OR?: addressesWhereInput[]
    NOT?: addressesWhereInput | addressesWhereInput[]
    addressable_type?: StringNullableFilter<"addresses"> | string | null
    addressable_id?: UuidNullableFilter<"addresses"> | string | null
    line1?: StringNullableFilter<"addresses"> | string | null
    line2?: StringNullableFilter<"addresses"> | string | null
    county?: StringNullableFilter<"addresses"> | string | null
    locality?: StringNullableFilter<"addresses"> | string | null
    region?: StringNullableFilter<"addresses"> | string | null
    country?: StringNullableFilter<"addresses"> | string | null
    postal_code?: IntNullableFilter<"addresses"> | number | null
    created_at?: DateTimeFilter<"addresses"> | Date | string
    updated_at?: DateTimeFilter<"addresses"> | Date | string
  }, "id">

  export type addressesOrderByWithAggregationInput = {
    id?: SortOrder
    addressable_type?: SortOrderInput | SortOrder
    addressable_id?: SortOrderInput | SortOrder
    line1?: SortOrderInput | SortOrder
    line2?: SortOrderInput | SortOrder
    county?: SortOrderInput | SortOrder
    locality?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: addressesCountOrderByAggregateInput
    _avg?: addressesAvgOrderByAggregateInput
    _max?: addressesMaxOrderByAggregateInput
    _min?: addressesMinOrderByAggregateInput
    _sum?: addressesSumOrderByAggregateInput
  }

  export type addressesScalarWhereWithAggregatesInput = {
    AND?: addressesScalarWhereWithAggregatesInput | addressesScalarWhereWithAggregatesInput[]
    OR?: addressesScalarWhereWithAggregatesInput[]
    NOT?: addressesScalarWhereWithAggregatesInput | addressesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"addresses"> | string
    addressable_type?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    addressable_id?: UuidNullableWithAggregatesFilter<"addresses"> | string | null
    line1?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    line2?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    county?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    locality?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    region?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    country?: StringNullableWithAggregatesFilter<"addresses"> | string | null
    postal_code?: IntNullableWithAggregatesFilter<"addresses"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"addresses"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"addresses"> | Date | string
  }

  export type ar_internal_metadataWhereInput = {
    AND?: ar_internal_metadataWhereInput | ar_internal_metadataWhereInput[]
    OR?: ar_internal_metadataWhereInput[]
    NOT?: ar_internal_metadataWhereInput | ar_internal_metadataWhereInput[]
    key?: StringFilter<"ar_internal_metadata"> | string
    value?: StringNullableFilter<"ar_internal_metadata"> | string | null
    created_at?: DateTimeFilter<"ar_internal_metadata"> | Date | string
    updated_at?: DateTimeFilter<"ar_internal_metadata"> | Date | string
  }

  export type ar_internal_metadataOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ar_internal_metadataWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: ar_internal_metadataWhereInput | ar_internal_metadataWhereInput[]
    OR?: ar_internal_metadataWhereInput[]
    NOT?: ar_internal_metadataWhereInput | ar_internal_metadataWhereInput[]
    value?: StringNullableFilter<"ar_internal_metadata"> | string | null
    created_at?: DateTimeFilter<"ar_internal_metadata"> | Date | string
    updated_at?: DateTimeFilter<"ar_internal_metadata"> | Date | string
  }, "key">

  export type ar_internal_metadataOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ar_internal_metadataCountOrderByAggregateInput
    _max?: ar_internal_metadataMaxOrderByAggregateInput
    _min?: ar_internal_metadataMinOrderByAggregateInput
  }

  export type ar_internal_metadataScalarWhereWithAggregatesInput = {
    AND?: ar_internal_metadataScalarWhereWithAggregatesInput | ar_internal_metadataScalarWhereWithAggregatesInput[]
    OR?: ar_internal_metadataScalarWhereWithAggregatesInput[]
    NOT?: ar_internal_metadataScalarWhereWithAggregatesInput | ar_internal_metadataScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"ar_internal_metadata"> | string
    value?: StringNullableWithAggregatesFilter<"ar_internal_metadata"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ar_internal_metadata"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ar_internal_metadata"> | Date | string
  }

  export type balancesWhereInput = {
    AND?: balancesWhereInput | balancesWhereInput[]
    OR?: balancesWhereInput[]
    NOT?: balancesWhereInput | balancesWhereInput[]
    id?: UuidFilter<"balances"> | string
    account_id?: UuidFilter<"balances"> | string
    date?: DateTimeFilter<"balances"> | Date | string
    balance?: DecimalFilter<"balances"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"balances"> | string
    created_at?: DateTimeFilter<"balances"> | Date | string
    updated_at?: DateTimeFilter<"balances"> | Date | string
    cash_balance?: DecimalNullableFilter<"balances"> | Decimal | DecimalJsLike | number | string | null
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type balancesOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    date?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cash_balance?: SortOrderInput | SortOrder
    accounts?: accountsOrderByWithRelationInput
  }

  export type balancesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id_date_currency?: balancesAccount_idDateCurrencyCompoundUniqueInput
    AND?: balancesWhereInput | balancesWhereInput[]
    OR?: balancesWhereInput[]
    NOT?: balancesWhereInput | balancesWhereInput[]
    account_id?: UuidFilter<"balances"> | string
    date?: DateTimeFilter<"balances"> | Date | string
    balance?: DecimalFilter<"balances"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"balances"> | string
    created_at?: DateTimeFilter<"balances"> | Date | string
    updated_at?: DateTimeFilter<"balances"> | Date | string
    cash_balance?: DecimalNullableFilter<"balances"> | Decimal | DecimalJsLike | number | string | null
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id" | "account_id_date_currency">

  export type balancesOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    date?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cash_balance?: SortOrderInput | SortOrder
    _count?: balancesCountOrderByAggregateInput
    _avg?: balancesAvgOrderByAggregateInput
    _max?: balancesMaxOrderByAggregateInput
    _min?: balancesMinOrderByAggregateInput
    _sum?: balancesSumOrderByAggregateInput
  }

  export type balancesScalarWhereWithAggregatesInput = {
    AND?: balancesScalarWhereWithAggregatesInput | balancesScalarWhereWithAggregatesInput[]
    OR?: balancesScalarWhereWithAggregatesInput[]
    NOT?: balancesScalarWhereWithAggregatesInput | balancesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"balances"> | string
    account_id?: UuidWithAggregatesFilter<"balances"> | string
    date?: DateTimeWithAggregatesFilter<"balances"> | Date | string
    balance?: DecimalWithAggregatesFilter<"balances"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"balances"> | string
    created_at?: DateTimeWithAggregatesFilter<"balances"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"balances"> | Date | string
    cash_balance?: DecimalNullableWithAggregatesFilter<"balances"> | Decimal | DecimalJsLike | number | string | null
  }

  export type budget_categoriesWhereInput = {
    AND?: budget_categoriesWhereInput | budget_categoriesWhereInput[]
    OR?: budget_categoriesWhereInput[]
    NOT?: budget_categoriesWhereInput | budget_categoriesWhereInput[]
    id?: UuidFilter<"budget_categories"> | string
    budget_id?: UuidFilter<"budget_categories"> | string
    category_id?: UuidFilter<"budget_categories"> | string
    budgeted_spending?: DecimalFilter<"budget_categories"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"budget_categories"> | string
    created_at?: DateTimeFilter<"budget_categories"> | Date | string
    updated_at?: DateTimeFilter<"budget_categories"> | Date | string
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
    budgets?: XOR<BudgetsScalarRelationFilter, budgetsWhereInput>
  }

  export type budget_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    budget_id?: SortOrder
    category_id?: SortOrder
    budgeted_spending?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    categories?: categoriesOrderByWithRelationInput
    budgets?: budgetsOrderByWithRelationInput
  }

  export type budget_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    budget_id_category_id?: budget_categoriesBudget_idCategory_idCompoundUniqueInput
    AND?: budget_categoriesWhereInput | budget_categoriesWhereInput[]
    OR?: budget_categoriesWhereInput[]
    NOT?: budget_categoriesWhereInput | budget_categoriesWhereInput[]
    budget_id?: UuidFilter<"budget_categories"> | string
    category_id?: UuidFilter<"budget_categories"> | string
    budgeted_spending?: DecimalFilter<"budget_categories"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"budget_categories"> | string
    created_at?: DateTimeFilter<"budget_categories"> | Date | string
    updated_at?: DateTimeFilter<"budget_categories"> | Date | string
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
    budgets?: XOR<BudgetsScalarRelationFilter, budgetsWhereInput>
  }, "id" | "budget_id_category_id">

  export type budget_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    budget_id?: SortOrder
    category_id?: SortOrder
    budgeted_spending?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: budget_categoriesCountOrderByAggregateInput
    _avg?: budget_categoriesAvgOrderByAggregateInput
    _max?: budget_categoriesMaxOrderByAggregateInput
    _min?: budget_categoriesMinOrderByAggregateInput
    _sum?: budget_categoriesSumOrderByAggregateInput
  }

  export type budget_categoriesScalarWhereWithAggregatesInput = {
    AND?: budget_categoriesScalarWhereWithAggregatesInput | budget_categoriesScalarWhereWithAggregatesInput[]
    OR?: budget_categoriesScalarWhereWithAggregatesInput[]
    NOT?: budget_categoriesScalarWhereWithAggregatesInput | budget_categoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"budget_categories"> | string
    budget_id?: UuidWithAggregatesFilter<"budget_categories"> | string
    category_id?: UuidWithAggregatesFilter<"budget_categories"> | string
    budgeted_spending?: DecimalWithAggregatesFilter<"budget_categories"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"budget_categories"> | string
    created_at?: DateTimeWithAggregatesFilter<"budget_categories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"budget_categories"> | Date | string
  }

  export type budgetsWhereInput = {
    AND?: budgetsWhereInput | budgetsWhereInput[]
    OR?: budgetsWhereInput[]
    NOT?: budgetsWhereInput | budgetsWhereInput[]
    id?: UuidFilter<"budgets"> | string
    family_id?: UuidFilter<"budgets"> | string
    start_date?: DateTimeFilter<"budgets"> | Date | string
    end_date?: DateTimeFilter<"budgets"> | Date | string
    budgeted_spending?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    expected_income?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"budgets"> | string
    created_at?: DateTimeFilter<"budgets"> | Date | string
    updated_at?: DateTimeFilter<"budgets"> | Date | string
    budget_categories?: Budget_categoriesListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type budgetsOrderByWithRelationInput = {
    id?: SortOrder
    family_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    budgeted_spending?: SortOrderInput | SortOrder
    expected_income?: SortOrderInput | SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    budget_categories?: budget_categoriesOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
  }

  export type budgetsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    family_id_start_date_end_date?: budgetsFamily_idStart_dateEnd_dateCompoundUniqueInput
    AND?: budgetsWhereInput | budgetsWhereInput[]
    OR?: budgetsWhereInput[]
    NOT?: budgetsWhereInput | budgetsWhereInput[]
    family_id?: UuidFilter<"budgets"> | string
    start_date?: DateTimeFilter<"budgets"> | Date | string
    end_date?: DateTimeFilter<"budgets"> | Date | string
    budgeted_spending?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    expected_income?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"budgets"> | string
    created_at?: DateTimeFilter<"budgets"> | Date | string
    updated_at?: DateTimeFilter<"budgets"> | Date | string
    budget_categories?: Budget_categoriesListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id" | "family_id_start_date_end_date">

  export type budgetsOrderByWithAggregationInput = {
    id?: SortOrder
    family_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    budgeted_spending?: SortOrderInput | SortOrder
    expected_income?: SortOrderInput | SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: budgetsCountOrderByAggregateInput
    _avg?: budgetsAvgOrderByAggregateInput
    _max?: budgetsMaxOrderByAggregateInput
    _min?: budgetsMinOrderByAggregateInput
    _sum?: budgetsSumOrderByAggregateInput
  }

  export type budgetsScalarWhereWithAggregatesInput = {
    AND?: budgetsScalarWhereWithAggregatesInput | budgetsScalarWhereWithAggregatesInput[]
    OR?: budgetsScalarWhereWithAggregatesInput[]
    NOT?: budgetsScalarWhereWithAggregatesInput | budgetsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"budgets"> | string
    family_id?: UuidWithAggregatesFilter<"budgets"> | string
    start_date?: DateTimeWithAggregatesFilter<"budgets"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"budgets"> | Date | string
    budgeted_spending?: DecimalNullableWithAggregatesFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    expected_income?: DecimalNullableWithAggregatesFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"budgets"> | string
    created_at?: DateTimeWithAggregatesFilter<"budgets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"budgets"> | Date | string
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: UuidFilter<"categories"> | string
    name?: StringFilter<"categories"> | string
    color?: StringFilter<"categories"> | string
    family_id?: UuidFilter<"categories"> | string
    created_at?: DateTimeFilter<"categories"> | Date | string
    updated_at?: DateTimeFilter<"categories"> | Date | string
    parent_id?: UuidNullableFilter<"categories"> | string | null
    classification?: StringFilter<"categories"> | string
    lucide_icon?: StringFilter<"categories"> | string
    budget_categories?: Budget_categoriesListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    transactions?: TransactionsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    classification?: SortOrder
    lucide_icon?: SortOrder
    budget_categories?: budget_categoriesOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    name?: StringFilter<"categories"> | string
    color?: StringFilter<"categories"> | string
    family_id?: UuidFilter<"categories"> | string
    created_at?: DateTimeFilter<"categories"> | Date | string
    updated_at?: DateTimeFilter<"categories"> | Date | string
    parent_id?: UuidNullableFilter<"categories"> | string | null
    classification?: StringFilter<"categories"> | string
    lucide_icon?: StringFilter<"categories"> | string
    budget_categories?: Budget_categoriesListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    classification?: SortOrder
    lucide_icon?: SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"categories"> | string
    name?: StringWithAggregatesFilter<"categories"> | string
    color?: StringWithAggregatesFilter<"categories"> | string
    family_id?: UuidWithAggregatesFilter<"categories"> | string
    created_at?: DateTimeWithAggregatesFilter<"categories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"categories"> | Date | string
    parent_id?: UuidNullableWithAggregatesFilter<"categories"> | string | null
    classification?: StringWithAggregatesFilter<"categories"> | string
    lucide_icon?: StringWithAggregatesFilter<"categories"> | string
  }

  export type chatsWhereInput = {
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    id?: UuidFilter<"chats"> | string
    user_id?: UuidFilter<"chats"> | string
    title?: StringFilter<"chats"> | string
    instructions?: StringNullableFilter<"chats"> | string | null
    error?: JsonNullableFilter<"chats">
    latest_assistant_response_id?: StringNullableFilter<"chats"> | string | null
    created_at?: DateTimeFilter<"chats"> | Date | string
    updated_at?: DateTimeFilter<"chats"> | Date | string
    users_chats_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    messages?: MessagesListRelationFilter
    users_users_last_viewed_chat_idTochats?: UsersListRelationFilter
  }

  export type chatsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    latest_assistant_response_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users_chats_user_idTousers?: usersOrderByWithRelationInput
    messages?: messagesOrderByRelationAggregateInput
    users_users_last_viewed_chat_idTochats?: usersOrderByRelationAggregateInput
  }

  export type chatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    user_id?: UuidFilter<"chats"> | string
    title?: StringFilter<"chats"> | string
    instructions?: StringNullableFilter<"chats"> | string | null
    error?: JsonNullableFilter<"chats">
    latest_assistant_response_id?: StringNullableFilter<"chats"> | string | null
    created_at?: DateTimeFilter<"chats"> | Date | string
    updated_at?: DateTimeFilter<"chats"> | Date | string
    users_chats_user_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    messages?: MessagesListRelationFilter
    users_users_last_viewed_chat_idTochats?: UsersListRelationFilter
  }, "id">

  export type chatsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    latest_assistant_response_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: chatsCountOrderByAggregateInput
    _max?: chatsMaxOrderByAggregateInput
    _min?: chatsMinOrderByAggregateInput
  }

  export type chatsScalarWhereWithAggregatesInput = {
    AND?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    OR?: chatsScalarWhereWithAggregatesInput[]
    NOT?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chats"> | string
    user_id?: UuidWithAggregatesFilter<"chats"> | string
    title?: StringWithAggregatesFilter<"chats"> | string
    instructions?: StringNullableWithAggregatesFilter<"chats"> | string | null
    error?: JsonNullableWithAggregatesFilter<"chats">
    latest_assistant_response_id?: StringNullableWithAggregatesFilter<"chats"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"chats"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chats"> | Date | string
  }

  export type credit_cardsWhereInput = {
    AND?: credit_cardsWhereInput | credit_cardsWhereInput[]
    OR?: credit_cardsWhereInput[]
    NOT?: credit_cardsWhereInput | credit_cardsWhereInput[]
    id?: UuidFilter<"credit_cards"> | string
    created_at?: DateTimeFilter<"credit_cards"> | Date | string
    updated_at?: DateTimeFilter<"credit_cards"> | Date | string
    available_credit?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    apr?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    expiration_date?: DateTimeNullableFilter<"credit_cards"> | Date | string | null
    annual_fee?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"credit_cards">
  }

  export type credit_cardsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_credit?: SortOrderInput | SortOrder
    minimum_payment?: SortOrderInput | SortOrder
    apr?: SortOrderInput | SortOrder
    expiration_date?: SortOrderInput | SortOrder
    annual_fee?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type credit_cardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: credit_cardsWhereInput | credit_cardsWhereInput[]
    OR?: credit_cardsWhereInput[]
    NOT?: credit_cardsWhereInput | credit_cardsWhereInput[]
    created_at?: DateTimeFilter<"credit_cards"> | Date | string
    updated_at?: DateTimeFilter<"credit_cards"> | Date | string
    available_credit?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    apr?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    expiration_date?: DateTimeNullableFilter<"credit_cards"> | Date | string | null
    annual_fee?: DecimalNullableFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"credit_cards">
  }, "id">

  export type credit_cardsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_credit?: SortOrderInput | SortOrder
    minimum_payment?: SortOrderInput | SortOrder
    apr?: SortOrderInput | SortOrder
    expiration_date?: SortOrderInput | SortOrder
    annual_fee?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: credit_cardsCountOrderByAggregateInput
    _avg?: credit_cardsAvgOrderByAggregateInput
    _max?: credit_cardsMaxOrderByAggregateInput
    _min?: credit_cardsMinOrderByAggregateInput
    _sum?: credit_cardsSumOrderByAggregateInput
  }

  export type credit_cardsScalarWhereWithAggregatesInput = {
    AND?: credit_cardsScalarWhereWithAggregatesInput | credit_cardsScalarWhereWithAggregatesInput[]
    OR?: credit_cardsScalarWhereWithAggregatesInput[]
    NOT?: credit_cardsScalarWhereWithAggregatesInput | credit_cardsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"credit_cards"> | string
    created_at?: DateTimeWithAggregatesFilter<"credit_cards"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"credit_cards"> | Date | string
    available_credit?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    apr?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    expiration_date?: DateTimeNullableWithAggregatesFilter<"credit_cards"> | Date | string | null
    annual_fee?: DecimalNullableWithAggregatesFilter<"credit_cards"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"credit_cards">
  }

  export type cryptosWhereInput = {
    AND?: cryptosWhereInput | cryptosWhereInput[]
    OR?: cryptosWhereInput[]
    NOT?: cryptosWhereInput | cryptosWhereInput[]
    id?: UuidFilter<"cryptos"> | string
    created_at?: DateTimeFilter<"cryptos"> | Date | string
    updated_at?: DateTimeFilter<"cryptos"> | Date | string
    locked_attributes?: JsonNullableFilter<"cryptos">
  }

  export type cryptosOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type cryptosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: cryptosWhereInput | cryptosWhereInput[]
    OR?: cryptosWhereInput[]
    NOT?: cryptosWhereInput | cryptosWhereInput[]
    created_at?: DateTimeFilter<"cryptos"> | Date | string
    updated_at?: DateTimeFilter<"cryptos"> | Date | string
    locked_attributes?: JsonNullableFilter<"cryptos">
  }, "id">

  export type cryptosOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: cryptosCountOrderByAggregateInput
    _max?: cryptosMaxOrderByAggregateInput
    _min?: cryptosMinOrderByAggregateInput
  }

  export type cryptosScalarWhereWithAggregatesInput = {
    AND?: cryptosScalarWhereWithAggregatesInput | cryptosScalarWhereWithAggregatesInput[]
    OR?: cryptosScalarWhereWithAggregatesInput[]
    NOT?: cryptosScalarWhereWithAggregatesInput | cryptosScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"cryptos"> | string
    created_at?: DateTimeWithAggregatesFilter<"cryptos"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"cryptos"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"cryptos">
  }

  export type data_enrichmentsWhereInput = {
    AND?: data_enrichmentsWhereInput | data_enrichmentsWhereInput[]
    OR?: data_enrichmentsWhereInput[]
    NOT?: data_enrichmentsWhereInput | data_enrichmentsWhereInput[]
    id?: UuidFilter<"data_enrichments"> | string
    enrichable_type?: StringFilter<"data_enrichments"> | string
    enrichable_id?: UuidFilter<"data_enrichments"> | string
    source?: StringNullableFilter<"data_enrichments"> | string | null
    attribute_name?: StringNullableFilter<"data_enrichments"> | string | null
    value?: JsonNullableFilter<"data_enrichments">
    metadata?: JsonNullableFilter<"data_enrichments">
    created_at?: DateTimeFilter<"data_enrichments"> | Date | string
    updated_at?: DateTimeFilter<"data_enrichments"> | Date | string
  }

  export type data_enrichmentsOrderByWithRelationInput = {
    id?: SortOrder
    enrichable_type?: SortOrder
    enrichable_id?: SortOrder
    source?: SortOrderInput | SortOrder
    attribute_name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type data_enrichmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    enrichable_id_enrichable_type_source_attribute_name?: data_enrichmentsEnrichable_idEnrichable_typeSourceAttribute_nameCompoundUniqueInput
    AND?: data_enrichmentsWhereInput | data_enrichmentsWhereInput[]
    OR?: data_enrichmentsWhereInput[]
    NOT?: data_enrichmentsWhereInput | data_enrichmentsWhereInput[]
    enrichable_type?: StringFilter<"data_enrichments"> | string
    enrichable_id?: UuidFilter<"data_enrichments"> | string
    source?: StringNullableFilter<"data_enrichments"> | string | null
    attribute_name?: StringNullableFilter<"data_enrichments"> | string | null
    value?: JsonNullableFilter<"data_enrichments">
    metadata?: JsonNullableFilter<"data_enrichments">
    created_at?: DateTimeFilter<"data_enrichments"> | Date | string
    updated_at?: DateTimeFilter<"data_enrichments"> | Date | string
  }, "id" | "enrichable_id_enrichable_type_source_attribute_name">

  export type data_enrichmentsOrderByWithAggregationInput = {
    id?: SortOrder
    enrichable_type?: SortOrder
    enrichable_id?: SortOrder
    source?: SortOrderInput | SortOrder
    attribute_name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: data_enrichmentsCountOrderByAggregateInput
    _max?: data_enrichmentsMaxOrderByAggregateInput
    _min?: data_enrichmentsMinOrderByAggregateInput
  }

  export type data_enrichmentsScalarWhereWithAggregatesInput = {
    AND?: data_enrichmentsScalarWhereWithAggregatesInput | data_enrichmentsScalarWhereWithAggregatesInput[]
    OR?: data_enrichmentsScalarWhereWithAggregatesInput[]
    NOT?: data_enrichmentsScalarWhereWithAggregatesInput | data_enrichmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"data_enrichments"> | string
    enrichable_type?: StringWithAggregatesFilter<"data_enrichments"> | string
    enrichable_id?: UuidWithAggregatesFilter<"data_enrichments"> | string
    source?: StringNullableWithAggregatesFilter<"data_enrichments"> | string | null
    attribute_name?: StringNullableWithAggregatesFilter<"data_enrichments"> | string | null
    value?: JsonNullableWithAggregatesFilter<"data_enrichments">
    metadata?: JsonNullableWithAggregatesFilter<"data_enrichments">
    created_at?: DateTimeWithAggregatesFilter<"data_enrichments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"data_enrichments"> | Date | string
  }

  export type depositoriesWhereInput = {
    AND?: depositoriesWhereInput | depositoriesWhereInput[]
    OR?: depositoriesWhereInput[]
    NOT?: depositoriesWhereInput | depositoriesWhereInput[]
    id?: UuidFilter<"depositories"> | string
    created_at?: DateTimeFilter<"depositories"> | Date | string
    updated_at?: DateTimeFilter<"depositories"> | Date | string
    locked_attributes?: JsonNullableFilter<"depositories">
  }

  export type depositoriesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type depositoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: depositoriesWhereInput | depositoriesWhereInput[]
    OR?: depositoriesWhereInput[]
    NOT?: depositoriesWhereInput | depositoriesWhereInput[]
    created_at?: DateTimeFilter<"depositories"> | Date | string
    updated_at?: DateTimeFilter<"depositories"> | Date | string
    locked_attributes?: JsonNullableFilter<"depositories">
  }, "id">

  export type depositoriesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: depositoriesCountOrderByAggregateInput
    _max?: depositoriesMaxOrderByAggregateInput
    _min?: depositoriesMinOrderByAggregateInput
  }

  export type depositoriesScalarWhereWithAggregatesInput = {
    AND?: depositoriesScalarWhereWithAggregatesInput | depositoriesScalarWhereWithAggregatesInput[]
    OR?: depositoriesScalarWhereWithAggregatesInput[]
    NOT?: depositoriesScalarWhereWithAggregatesInput | depositoriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"depositories"> | string
    created_at?: DateTimeWithAggregatesFilter<"depositories"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"depositories"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"depositories">
  }

  export type entriesWhereInput = {
    AND?: entriesWhereInput | entriesWhereInput[]
    OR?: entriesWhereInput[]
    NOT?: entriesWhereInput | entriesWhereInput[]
    id?: UuidFilter<"entries"> | string
    account_id?: UuidFilter<"entries"> | string
    entryable_type?: StringNullableFilter<"entries"> | string | null
    entryable_id?: UuidNullableFilter<"entries"> | string | null
    amount?: DecimalNullableFilter<"entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"entries"> | string | null
    date?: DateTimeNullableFilter<"entries"> | Date | string | null
    name?: StringFilter<"entries"> | string
    created_at?: DateTimeFilter<"entries"> | Date | string
    updated_at?: DateTimeFilter<"entries"> | Date | string
    import_id?: UuidNullableFilter<"entries"> | string | null
    notes?: StringNullableFilter<"entries"> | string | null
    excluded?: BoolNullableFilter<"entries"> | boolean | null
    plaid_id?: StringNullableFilter<"entries"> | string | null
    locked_attributes?: JsonNullableFilter<"entries">
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
    imports?: XOR<ImportsNullableScalarRelationFilter, importsWhereInput> | null
  }

  export type entriesOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    entryable_type?: SortOrderInput | SortOrder
    entryable_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    excluded?: SortOrderInput | SortOrder
    plaid_id?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    accounts?: accountsOrderByWithRelationInput
    imports?: importsOrderByWithRelationInput
  }

  export type entriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: entriesWhereInput | entriesWhereInput[]
    OR?: entriesWhereInput[]
    NOT?: entriesWhereInput | entriesWhereInput[]
    account_id?: UuidFilter<"entries"> | string
    entryable_type?: StringNullableFilter<"entries"> | string | null
    entryable_id?: UuidNullableFilter<"entries"> | string | null
    amount?: DecimalNullableFilter<"entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"entries"> | string | null
    date?: DateTimeNullableFilter<"entries"> | Date | string | null
    name?: StringFilter<"entries"> | string
    created_at?: DateTimeFilter<"entries"> | Date | string
    updated_at?: DateTimeFilter<"entries"> | Date | string
    import_id?: UuidNullableFilter<"entries"> | string | null
    notes?: StringNullableFilter<"entries"> | string | null
    excluded?: BoolNullableFilter<"entries"> | boolean | null
    plaid_id?: StringNullableFilter<"entries"> | string | null
    locked_attributes?: JsonNullableFilter<"entries">
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
    imports?: XOR<ImportsNullableScalarRelationFilter, importsWhereInput> | null
  }, "id">

  export type entriesOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    entryable_type?: SortOrderInput | SortOrder
    entryable_id?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    excluded?: SortOrderInput | SortOrder
    plaid_id?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: entriesCountOrderByAggregateInput
    _avg?: entriesAvgOrderByAggregateInput
    _max?: entriesMaxOrderByAggregateInput
    _min?: entriesMinOrderByAggregateInput
    _sum?: entriesSumOrderByAggregateInput
  }

  export type entriesScalarWhereWithAggregatesInput = {
    AND?: entriesScalarWhereWithAggregatesInput | entriesScalarWhereWithAggregatesInput[]
    OR?: entriesScalarWhereWithAggregatesInput[]
    NOT?: entriesScalarWhereWithAggregatesInput | entriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"entries"> | string
    account_id?: UuidWithAggregatesFilter<"entries"> | string
    entryable_type?: StringNullableWithAggregatesFilter<"entries"> | string | null
    entryable_id?: UuidNullableWithAggregatesFilter<"entries"> | string | null
    amount?: DecimalNullableWithAggregatesFilter<"entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"entries"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"entries"> | Date | string | null
    name?: StringWithAggregatesFilter<"entries"> | string
    created_at?: DateTimeWithAggregatesFilter<"entries"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"entries"> | Date | string
    import_id?: UuidNullableWithAggregatesFilter<"entries"> | string | null
    notes?: StringNullableWithAggregatesFilter<"entries"> | string | null
    excluded?: BoolNullableWithAggregatesFilter<"entries"> | boolean | null
    plaid_id?: StringNullableWithAggregatesFilter<"entries"> | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"entries">
  }

  export type exchange_ratesWhereInput = {
    AND?: exchange_ratesWhereInput | exchange_ratesWhereInput[]
    OR?: exchange_ratesWhereInput[]
    NOT?: exchange_ratesWhereInput | exchange_ratesWhereInput[]
    id?: UuidFilter<"exchange_rates"> | string
    from_currency?: StringFilter<"exchange_rates"> | string
    to_currency?: StringFilter<"exchange_rates"> | string
    rate?: DecimalFilter<"exchange_rates"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"exchange_rates"> | Date | string
    created_at?: DateTimeFilter<"exchange_rates"> | Date | string
    updated_at?: DateTimeFilter<"exchange_rates"> | Date | string
  }

  export type exchange_ratesOrderByWithRelationInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type exchange_ratesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    from_currency_to_currency_date?: exchange_ratesFrom_currencyTo_currencyDateCompoundUniqueInput
    AND?: exchange_ratesWhereInput | exchange_ratesWhereInput[]
    OR?: exchange_ratesWhereInput[]
    NOT?: exchange_ratesWhereInput | exchange_ratesWhereInput[]
    from_currency?: StringFilter<"exchange_rates"> | string
    to_currency?: StringFilter<"exchange_rates"> | string
    rate?: DecimalFilter<"exchange_rates"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"exchange_rates"> | Date | string
    created_at?: DateTimeFilter<"exchange_rates"> | Date | string
    updated_at?: DateTimeFilter<"exchange_rates"> | Date | string
  }, "id" | "from_currency_to_currency_date">

  export type exchange_ratesOrderByWithAggregationInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: exchange_ratesCountOrderByAggregateInput
    _avg?: exchange_ratesAvgOrderByAggregateInput
    _max?: exchange_ratesMaxOrderByAggregateInput
    _min?: exchange_ratesMinOrderByAggregateInput
    _sum?: exchange_ratesSumOrderByAggregateInput
  }

  export type exchange_ratesScalarWhereWithAggregatesInput = {
    AND?: exchange_ratesScalarWhereWithAggregatesInput | exchange_ratesScalarWhereWithAggregatesInput[]
    OR?: exchange_ratesScalarWhereWithAggregatesInput[]
    NOT?: exchange_ratesScalarWhereWithAggregatesInput | exchange_ratesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"exchange_rates"> | string
    from_currency?: StringWithAggregatesFilter<"exchange_rates"> | string
    to_currency?: StringWithAggregatesFilter<"exchange_rates"> | string
    rate?: DecimalWithAggregatesFilter<"exchange_rates"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"exchange_rates"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"exchange_rates"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"exchange_rates"> | Date | string
  }

  export type familiesWhereInput = {
    AND?: familiesWhereInput | familiesWhereInput[]
    OR?: familiesWhereInput[]
    NOT?: familiesWhereInput | familiesWhereInput[]
    id?: UuidFilter<"families"> | string
    name?: StringNullableFilter<"families"> | string | null
    created_at?: DateTimeFilter<"families"> | Date | string
    updated_at?: DateTimeFilter<"families"> | Date | string
    currency?: StringNullableFilter<"families"> | string | null
    locale?: StringNullableFilter<"families"> | string | null
    stripe_plan_id?: StringNullableFilter<"families"> | string | null
    stripe_customer_id?: StringNullableFilter<"families"> | string | null
    stripe_subscription_status?: StringNullableFilter<"families"> | string | null
    date_format?: StringNullableFilter<"families"> | string | null
    country?: StringNullableFilter<"families"> | string | null
    last_synced_at?: DateTimeNullableFilter<"families"> | Date | string | null
    timezone?: StringNullableFilter<"families"> | string | null
    data_enrichment_enabled?: BoolNullableFilter<"families"> | boolean | null
    trial_started_at?: DateTimeNullableFilter<"families"> | Date | string | null
    early_access?: BoolNullableFilter<"families"> | boolean | null
    accounts?: AccountsListRelationFilter
    budgets?: BudgetsListRelationFilter
    categories?: CategoriesListRelationFilter
    imports?: ImportsListRelationFilter
    invitations?: InvitationsListRelationFilter
    merchants?: MerchantsListRelationFilter
    plaid_items?: Plaid_itemsListRelationFilter
    rules?: RulesListRelationFilter
    tags?: TagsListRelationFilter
    users?: UsersListRelationFilter
  }

  export type familiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    stripe_plan_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_status?: SortOrderInput | SortOrder
    date_format?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    data_enrichment_enabled?: SortOrderInput | SortOrder
    trial_started_at?: SortOrderInput | SortOrder
    early_access?: SortOrderInput | SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    budgets?: budgetsOrderByRelationAggregateInput
    categories?: categoriesOrderByRelationAggregateInput
    imports?: importsOrderByRelationAggregateInput
    invitations?: invitationsOrderByRelationAggregateInput
    merchants?: merchantsOrderByRelationAggregateInput
    plaid_items?: plaid_itemsOrderByRelationAggregateInput
    rules?: rulesOrderByRelationAggregateInput
    tags?: tagsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
  }

  export type familiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: familiesWhereInput | familiesWhereInput[]
    OR?: familiesWhereInput[]
    NOT?: familiesWhereInput | familiesWhereInput[]
    name?: StringNullableFilter<"families"> | string | null
    created_at?: DateTimeFilter<"families"> | Date | string
    updated_at?: DateTimeFilter<"families"> | Date | string
    currency?: StringNullableFilter<"families"> | string | null
    locale?: StringNullableFilter<"families"> | string | null
    stripe_plan_id?: StringNullableFilter<"families"> | string | null
    stripe_customer_id?: StringNullableFilter<"families"> | string | null
    stripe_subscription_status?: StringNullableFilter<"families"> | string | null
    date_format?: StringNullableFilter<"families"> | string | null
    country?: StringNullableFilter<"families"> | string | null
    last_synced_at?: DateTimeNullableFilter<"families"> | Date | string | null
    timezone?: StringNullableFilter<"families"> | string | null
    data_enrichment_enabled?: BoolNullableFilter<"families"> | boolean | null
    trial_started_at?: DateTimeNullableFilter<"families"> | Date | string | null
    early_access?: BoolNullableFilter<"families"> | boolean | null
    accounts?: AccountsListRelationFilter
    budgets?: BudgetsListRelationFilter
    categories?: CategoriesListRelationFilter
    imports?: ImportsListRelationFilter
    invitations?: InvitationsListRelationFilter
    merchants?: MerchantsListRelationFilter
    plaid_items?: Plaid_itemsListRelationFilter
    rules?: RulesListRelationFilter
    tags?: TagsListRelationFilter
    users?: UsersListRelationFilter
  }, "id">

  export type familiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrderInput | SortOrder
    locale?: SortOrderInput | SortOrder
    stripe_plan_id?: SortOrderInput | SortOrder
    stripe_customer_id?: SortOrderInput | SortOrder
    stripe_subscription_status?: SortOrderInput | SortOrder
    date_format?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    data_enrichment_enabled?: SortOrderInput | SortOrder
    trial_started_at?: SortOrderInput | SortOrder
    early_access?: SortOrderInput | SortOrder
    _count?: familiesCountOrderByAggregateInput
    _max?: familiesMaxOrderByAggregateInput
    _min?: familiesMinOrderByAggregateInput
  }

  export type familiesScalarWhereWithAggregatesInput = {
    AND?: familiesScalarWhereWithAggregatesInput | familiesScalarWhereWithAggregatesInput[]
    OR?: familiesScalarWhereWithAggregatesInput[]
    NOT?: familiesScalarWhereWithAggregatesInput | familiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"families"> | string
    name?: StringNullableWithAggregatesFilter<"families"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"families"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"families"> | Date | string
    currency?: StringNullableWithAggregatesFilter<"families"> | string | null
    locale?: StringNullableWithAggregatesFilter<"families"> | string | null
    stripe_plan_id?: StringNullableWithAggregatesFilter<"families"> | string | null
    stripe_customer_id?: StringNullableWithAggregatesFilter<"families"> | string | null
    stripe_subscription_status?: StringNullableWithAggregatesFilter<"families"> | string | null
    date_format?: StringNullableWithAggregatesFilter<"families"> | string | null
    country?: StringNullableWithAggregatesFilter<"families"> | string | null
    last_synced_at?: DateTimeNullableWithAggregatesFilter<"families"> | Date | string | null
    timezone?: StringNullableWithAggregatesFilter<"families"> | string | null
    data_enrichment_enabled?: BoolNullableWithAggregatesFilter<"families"> | boolean | null
    trial_started_at?: DateTimeNullableWithAggregatesFilter<"families"> | Date | string | null
    early_access?: BoolNullableWithAggregatesFilter<"families"> | boolean | null
  }

  export type holdingsWhereInput = {
    AND?: holdingsWhereInput | holdingsWhereInput[]
    OR?: holdingsWhereInput[]
    NOT?: holdingsWhereInput | holdingsWhereInput[]
    id?: UuidFilter<"holdings"> | string
    account_id?: UuidFilter<"holdings"> | string
    security_id?: UuidFilter<"holdings"> | string
    date?: DateTimeFilter<"holdings"> | Date | string
    qty?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"holdings"> | string
    created_at?: DateTimeFilter<"holdings"> | Date | string
    updated_at?: DateTimeFilter<"holdings"> | Date | string
    securities?: XOR<SecuritiesScalarRelationFilter, securitiesWhereInput>
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }

  export type holdingsOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    security_id?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    securities?: securitiesOrderByWithRelationInput
    accounts?: accountsOrderByWithRelationInput
  }

  export type holdingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    account_id_security_id_date_currency?: holdingsAccount_idSecurity_idDateCurrencyCompoundUniqueInput
    AND?: holdingsWhereInput | holdingsWhereInput[]
    OR?: holdingsWhereInput[]
    NOT?: holdingsWhereInput | holdingsWhereInput[]
    account_id?: UuidFilter<"holdings"> | string
    security_id?: UuidFilter<"holdings"> | string
    date?: DateTimeFilter<"holdings"> | Date | string
    qty?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"holdings"> | string
    created_at?: DateTimeFilter<"holdings"> | Date | string
    updated_at?: DateTimeFilter<"holdings"> | Date | string
    securities?: XOR<SecuritiesScalarRelationFilter, securitiesWhereInput>
    accounts?: XOR<AccountsScalarRelationFilter, accountsWhereInput>
  }, "id" | "account_id_security_id_date_currency">

  export type holdingsOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    security_id?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: holdingsCountOrderByAggregateInput
    _avg?: holdingsAvgOrderByAggregateInput
    _max?: holdingsMaxOrderByAggregateInput
    _min?: holdingsMinOrderByAggregateInput
    _sum?: holdingsSumOrderByAggregateInput
  }

  export type holdingsScalarWhereWithAggregatesInput = {
    AND?: holdingsScalarWhereWithAggregatesInput | holdingsScalarWhereWithAggregatesInput[]
    OR?: holdingsScalarWhereWithAggregatesInput[]
    NOT?: holdingsScalarWhereWithAggregatesInput | holdingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"holdings"> | string
    account_id?: UuidWithAggregatesFilter<"holdings"> | string
    security_id?: UuidWithAggregatesFilter<"holdings"> | string
    date?: DateTimeWithAggregatesFilter<"holdings"> | Date | string
    qty?: DecimalWithAggregatesFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    price?: DecimalWithAggregatesFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalWithAggregatesFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"holdings"> | string
    created_at?: DateTimeWithAggregatesFilter<"holdings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"holdings"> | Date | string
  }

  export type impersonation_session_logsWhereInput = {
    AND?: impersonation_session_logsWhereInput | impersonation_session_logsWhereInput[]
    OR?: impersonation_session_logsWhereInput[]
    NOT?: impersonation_session_logsWhereInput | impersonation_session_logsWhereInput[]
    id?: UuidFilter<"impersonation_session_logs"> | string
    impersonation_session_id?: UuidFilter<"impersonation_session_logs"> | string
    controller?: StringNullableFilter<"impersonation_session_logs"> | string | null
    action?: StringNullableFilter<"impersonation_session_logs"> | string | null
    path?: StringNullableFilter<"impersonation_session_logs"> | string | null
    method?: StringNullableFilter<"impersonation_session_logs"> | string | null
    ip_address?: StringNullableFilter<"impersonation_session_logs"> | string | null
    user_agent?: StringNullableFilter<"impersonation_session_logs"> | string | null
    created_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
    impersonation_sessions?: XOR<Impersonation_sessionsScalarRelationFilter, impersonation_sessionsWhereInput>
  }

  export type impersonation_session_logsOrderByWithRelationInput = {
    id?: SortOrder
    impersonation_session_id?: SortOrder
    controller?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    impersonation_sessions?: impersonation_sessionsOrderByWithRelationInput
  }

  export type impersonation_session_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: impersonation_session_logsWhereInput | impersonation_session_logsWhereInput[]
    OR?: impersonation_session_logsWhereInput[]
    NOT?: impersonation_session_logsWhereInput | impersonation_session_logsWhereInput[]
    impersonation_session_id?: UuidFilter<"impersonation_session_logs"> | string
    controller?: StringNullableFilter<"impersonation_session_logs"> | string | null
    action?: StringNullableFilter<"impersonation_session_logs"> | string | null
    path?: StringNullableFilter<"impersonation_session_logs"> | string | null
    method?: StringNullableFilter<"impersonation_session_logs"> | string | null
    ip_address?: StringNullableFilter<"impersonation_session_logs"> | string | null
    user_agent?: StringNullableFilter<"impersonation_session_logs"> | string | null
    created_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
    impersonation_sessions?: XOR<Impersonation_sessionsScalarRelationFilter, impersonation_sessionsWhereInput>
  }, "id">

  export type impersonation_session_logsOrderByWithAggregationInput = {
    id?: SortOrder
    impersonation_session_id?: SortOrder
    controller?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    path?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: impersonation_session_logsCountOrderByAggregateInput
    _max?: impersonation_session_logsMaxOrderByAggregateInput
    _min?: impersonation_session_logsMinOrderByAggregateInput
  }

  export type impersonation_session_logsScalarWhereWithAggregatesInput = {
    AND?: impersonation_session_logsScalarWhereWithAggregatesInput | impersonation_session_logsScalarWhereWithAggregatesInput[]
    OR?: impersonation_session_logsScalarWhereWithAggregatesInput[]
    NOT?: impersonation_session_logsScalarWhereWithAggregatesInput | impersonation_session_logsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"impersonation_session_logs"> | string
    impersonation_session_id?: UuidWithAggregatesFilter<"impersonation_session_logs"> | string
    controller?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    action?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    path?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    method?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"impersonation_session_logs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"impersonation_session_logs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"impersonation_session_logs"> | Date | string
  }

  export type impersonation_sessionsWhereInput = {
    AND?: impersonation_sessionsWhereInput | impersonation_sessionsWhereInput[]
    OR?: impersonation_sessionsWhereInput[]
    NOT?: impersonation_sessionsWhereInput | impersonation_sessionsWhereInput[]
    id?: UuidFilter<"impersonation_sessions"> | string
    impersonator_id?: UuidFilter<"impersonation_sessions"> | string
    impersonated_id?: UuidFilter<"impersonation_sessions"> | string
    status?: StringFilter<"impersonation_sessions"> | string
    created_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
    impersonation_session_logs?: Impersonation_session_logsListRelationFilter
    users_impersonation_sessions_impersonator_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_impersonation_sessions_impersonated_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    sessions?: SessionsListRelationFilter
  }

  export type impersonation_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    impersonator_id?: SortOrder
    impersonated_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    impersonation_session_logs?: impersonation_session_logsOrderByRelationAggregateInput
    users_impersonation_sessions_impersonator_idTousers?: usersOrderByWithRelationInput
    users_impersonation_sessions_impersonated_idTousers?: usersOrderByWithRelationInput
    sessions?: sessionsOrderByRelationAggregateInput
  }

  export type impersonation_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: impersonation_sessionsWhereInput | impersonation_sessionsWhereInput[]
    OR?: impersonation_sessionsWhereInput[]
    NOT?: impersonation_sessionsWhereInput | impersonation_sessionsWhereInput[]
    impersonator_id?: UuidFilter<"impersonation_sessions"> | string
    impersonated_id?: UuidFilter<"impersonation_sessions"> | string
    status?: StringFilter<"impersonation_sessions"> | string
    created_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
    impersonation_session_logs?: Impersonation_session_logsListRelationFilter
    users_impersonation_sessions_impersonator_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    users_impersonation_sessions_impersonated_idTousers?: XOR<UsersScalarRelationFilter, usersWhereInput>
    sessions?: SessionsListRelationFilter
  }, "id">

  export type impersonation_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    impersonator_id?: SortOrder
    impersonated_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: impersonation_sessionsCountOrderByAggregateInput
    _max?: impersonation_sessionsMaxOrderByAggregateInput
    _min?: impersonation_sessionsMinOrderByAggregateInput
  }

  export type impersonation_sessionsScalarWhereWithAggregatesInput = {
    AND?: impersonation_sessionsScalarWhereWithAggregatesInput | impersonation_sessionsScalarWhereWithAggregatesInput[]
    OR?: impersonation_sessionsScalarWhereWithAggregatesInput[]
    NOT?: impersonation_sessionsScalarWhereWithAggregatesInput | impersonation_sessionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"impersonation_sessions"> | string
    impersonator_id?: UuidWithAggregatesFilter<"impersonation_sessions"> | string
    impersonated_id?: UuidWithAggregatesFilter<"impersonation_sessions"> | string
    status?: StringWithAggregatesFilter<"impersonation_sessions"> | string
    created_at?: DateTimeWithAggregatesFilter<"impersonation_sessions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"impersonation_sessions"> | Date | string
  }

  export type import_mappingsWhereInput = {
    AND?: import_mappingsWhereInput | import_mappingsWhereInput[]
    OR?: import_mappingsWhereInput[]
    NOT?: import_mappingsWhereInput | import_mappingsWhereInput[]
    id?: UuidFilter<"import_mappings"> | string
    type?: StringFilter<"import_mappings"> | string
    key?: StringNullableFilter<"import_mappings"> | string | null
    value?: StringNullableFilter<"import_mappings"> | string | null
    create_when_empty?: BoolNullableFilter<"import_mappings"> | boolean | null
    import_id?: UuidFilter<"import_mappings"> | string
    mappable_type?: StringNullableFilter<"import_mappings"> | string | null
    mappable_id?: UuidNullableFilter<"import_mappings"> | string | null
    created_at?: DateTimeFilter<"import_mappings"> | Date | string
    updated_at?: DateTimeFilter<"import_mappings"> | Date | string
  }

  export type import_mappingsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    create_when_empty?: SortOrderInput | SortOrder
    import_id?: SortOrder
    mappable_type?: SortOrderInput | SortOrder
    mappable_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type import_mappingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: import_mappingsWhereInput | import_mappingsWhereInput[]
    OR?: import_mappingsWhereInput[]
    NOT?: import_mappingsWhereInput | import_mappingsWhereInput[]
    type?: StringFilter<"import_mappings"> | string
    key?: StringNullableFilter<"import_mappings"> | string | null
    value?: StringNullableFilter<"import_mappings"> | string | null
    create_when_empty?: BoolNullableFilter<"import_mappings"> | boolean | null
    import_id?: UuidFilter<"import_mappings"> | string
    mappable_type?: StringNullableFilter<"import_mappings"> | string | null
    mappable_id?: UuidNullableFilter<"import_mappings"> | string | null
    created_at?: DateTimeFilter<"import_mappings"> | Date | string
    updated_at?: DateTimeFilter<"import_mappings"> | Date | string
  }, "id">

  export type import_mappingsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    create_when_empty?: SortOrderInput | SortOrder
    import_id?: SortOrder
    mappable_type?: SortOrderInput | SortOrder
    mappable_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: import_mappingsCountOrderByAggregateInput
    _max?: import_mappingsMaxOrderByAggregateInput
    _min?: import_mappingsMinOrderByAggregateInput
  }

  export type import_mappingsScalarWhereWithAggregatesInput = {
    AND?: import_mappingsScalarWhereWithAggregatesInput | import_mappingsScalarWhereWithAggregatesInput[]
    OR?: import_mappingsScalarWhereWithAggregatesInput[]
    NOT?: import_mappingsScalarWhereWithAggregatesInput | import_mappingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"import_mappings"> | string
    type?: StringWithAggregatesFilter<"import_mappings"> | string
    key?: StringNullableWithAggregatesFilter<"import_mappings"> | string | null
    value?: StringNullableWithAggregatesFilter<"import_mappings"> | string | null
    create_when_empty?: BoolNullableWithAggregatesFilter<"import_mappings"> | boolean | null
    import_id?: UuidWithAggregatesFilter<"import_mappings"> | string
    mappable_type?: StringNullableWithAggregatesFilter<"import_mappings"> | string | null
    mappable_id?: UuidNullableWithAggregatesFilter<"import_mappings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"import_mappings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"import_mappings"> | Date | string
  }

  export type import_rowsWhereInput = {
    AND?: import_rowsWhereInput | import_rowsWhereInput[]
    OR?: import_rowsWhereInput[]
    NOT?: import_rowsWhereInput | import_rowsWhereInput[]
    id?: UuidFilter<"import_rows"> | string
    import_id?: UuidFilter<"import_rows"> | string
    account?: StringNullableFilter<"import_rows"> | string | null
    date?: StringNullableFilter<"import_rows"> | string | null
    qty?: StringNullableFilter<"import_rows"> | string | null
    ticker?: StringNullableFilter<"import_rows"> | string | null
    price?: StringNullableFilter<"import_rows"> | string | null
    amount?: StringNullableFilter<"import_rows"> | string | null
    currency?: StringNullableFilter<"import_rows"> | string | null
    name?: StringNullableFilter<"import_rows"> | string | null
    category?: StringNullableFilter<"import_rows"> | string | null
    tags?: StringNullableFilter<"import_rows"> | string | null
    entity_type?: StringNullableFilter<"import_rows"> | string | null
    notes?: StringNullableFilter<"import_rows"> | string | null
    created_at?: DateTimeFilter<"import_rows"> | Date | string
    updated_at?: DateTimeFilter<"import_rows"> | Date | string
    exchange_operating_mic?: StringNullableFilter<"import_rows"> | string | null
    imports?: XOR<ImportsScalarRelationFilter, importsWhereInput>
  }

  export type import_rowsOrderByWithRelationInput = {
    id?: SortOrder
    import_id?: SortOrder
    account?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    ticker?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    exchange_operating_mic?: SortOrderInput | SortOrder
    imports?: importsOrderByWithRelationInput
  }

  export type import_rowsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: import_rowsWhereInput | import_rowsWhereInput[]
    OR?: import_rowsWhereInput[]
    NOT?: import_rowsWhereInput | import_rowsWhereInput[]
    import_id?: UuidFilter<"import_rows"> | string
    account?: StringNullableFilter<"import_rows"> | string | null
    date?: StringNullableFilter<"import_rows"> | string | null
    qty?: StringNullableFilter<"import_rows"> | string | null
    ticker?: StringNullableFilter<"import_rows"> | string | null
    price?: StringNullableFilter<"import_rows"> | string | null
    amount?: StringNullableFilter<"import_rows"> | string | null
    currency?: StringNullableFilter<"import_rows"> | string | null
    name?: StringNullableFilter<"import_rows"> | string | null
    category?: StringNullableFilter<"import_rows"> | string | null
    tags?: StringNullableFilter<"import_rows"> | string | null
    entity_type?: StringNullableFilter<"import_rows"> | string | null
    notes?: StringNullableFilter<"import_rows"> | string | null
    created_at?: DateTimeFilter<"import_rows"> | Date | string
    updated_at?: DateTimeFilter<"import_rows"> | Date | string
    exchange_operating_mic?: StringNullableFilter<"import_rows"> | string | null
    imports?: XOR<ImportsScalarRelationFilter, importsWhereInput>
  }, "id">

  export type import_rowsOrderByWithAggregationInput = {
    id?: SortOrder
    import_id?: SortOrder
    account?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    ticker?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    exchange_operating_mic?: SortOrderInput | SortOrder
    _count?: import_rowsCountOrderByAggregateInput
    _max?: import_rowsMaxOrderByAggregateInput
    _min?: import_rowsMinOrderByAggregateInput
  }

  export type import_rowsScalarWhereWithAggregatesInput = {
    AND?: import_rowsScalarWhereWithAggregatesInput | import_rowsScalarWhereWithAggregatesInput[]
    OR?: import_rowsScalarWhereWithAggregatesInput[]
    NOT?: import_rowsScalarWhereWithAggregatesInput | import_rowsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"import_rows"> | string
    import_id?: UuidWithAggregatesFilter<"import_rows"> | string
    account?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    date?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    qty?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    ticker?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    price?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    amount?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    currency?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    name?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    category?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    tags?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    entity_type?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    notes?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"import_rows"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"import_rows"> | Date | string
    exchange_operating_mic?: StringNullableWithAggregatesFilter<"import_rows"> | string | null
  }

  export type importsWhereInput = {
    AND?: importsWhereInput | importsWhereInput[]
    OR?: importsWhereInput[]
    NOT?: importsWhereInput | importsWhereInput[]
    id?: UuidFilter<"imports"> | string
    column_mappings?: JsonNullableFilter<"imports">
    status?: StringNullableFilter<"imports"> | string | null
    raw_file_str?: StringNullableFilter<"imports"> | string | null
    normalized_csv_str?: StringNullableFilter<"imports"> | string | null
    created_at?: DateTimeFilter<"imports"> | Date | string
    updated_at?: DateTimeFilter<"imports"> | Date | string
    col_sep?: StringNullableFilter<"imports"> | string | null
    family_id?: UuidFilter<"imports"> | string
    account_id?: UuidNullableFilter<"imports"> | string | null
    type?: StringFilter<"imports"> | string
    date_col_label?: StringNullableFilter<"imports"> | string | null
    amount_col_label?: StringNullableFilter<"imports"> | string | null
    name_col_label?: StringNullableFilter<"imports"> | string | null
    category_col_label?: StringNullableFilter<"imports"> | string | null
    tags_col_label?: StringNullableFilter<"imports"> | string | null
    account_col_label?: StringNullableFilter<"imports"> | string | null
    qty_col_label?: StringNullableFilter<"imports"> | string | null
    ticker_col_label?: StringNullableFilter<"imports"> | string | null
    price_col_label?: StringNullableFilter<"imports"> | string | null
    entity_type_col_label?: StringNullableFilter<"imports"> | string | null
    notes_col_label?: StringNullableFilter<"imports"> | string | null
    currency_col_label?: StringNullableFilter<"imports"> | string | null
    date_format?: StringNullableFilter<"imports"> | string | null
    signage_convention?: StringNullableFilter<"imports"> | string | null
    error?: StringNullableFilter<"imports"> | string | null
    number_format?: StringNullableFilter<"imports"> | string | null
    exchange_operating_mic_col_label?: StringNullableFilter<"imports"> | string | null
    amount_type_strategy?: StringNullableFilter<"imports"> | string | null
    amount_type_inflow_value?: StringNullableFilter<"imports"> | string | null
    accounts?: AccountsListRelationFilter
    entries?: EntriesListRelationFilter
    import_rows?: Import_rowsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type importsOrderByWithRelationInput = {
    id?: SortOrder
    column_mappings?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    raw_file_str?: SortOrderInput | SortOrder
    normalized_csv_str?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    col_sep?: SortOrderInput | SortOrder
    family_id?: SortOrder
    account_id?: SortOrderInput | SortOrder
    type?: SortOrder
    date_col_label?: SortOrderInput | SortOrder
    amount_col_label?: SortOrderInput | SortOrder
    name_col_label?: SortOrderInput | SortOrder
    category_col_label?: SortOrderInput | SortOrder
    tags_col_label?: SortOrderInput | SortOrder
    account_col_label?: SortOrderInput | SortOrder
    qty_col_label?: SortOrderInput | SortOrder
    ticker_col_label?: SortOrderInput | SortOrder
    price_col_label?: SortOrderInput | SortOrder
    entity_type_col_label?: SortOrderInput | SortOrder
    notes_col_label?: SortOrderInput | SortOrder
    currency_col_label?: SortOrderInput | SortOrder
    date_format?: SortOrderInput | SortOrder
    signage_convention?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    number_format?: SortOrderInput | SortOrder
    exchange_operating_mic_col_label?: SortOrderInput | SortOrder
    amount_type_strategy?: SortOrderInput | SortOrder
    amount_type_inflow_value?: SortOrderInput | SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    entries?: entriesOrderByRelationAggregateInput
    import_rows?: import_rowsOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
  }

  export type importsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: importsWhereInput | importsWhereInput[]
    OR?: importsWhereInput[]
    NOT?: importsWhereInput | importsWhereInput[]
    column_mappings?: JsonNullableFilter<"imports">
    status?: StringNullableFilter<"imports"> | string | null
    raw_file_str?: StringNullableFilter<"imports"> | string | null
    normalized_csv_str?: StringNullableFilter<"imports"> | string | null
    created_at?: DateTimeFilter<"imports"> | Date | string
    updated_at?: DateTimeFilter<"imports"> | Date | string
    col_sep?: StringNullableFilter<"imports"> | string | null
    family_id?: UuidFilter<"imports"> | string
    account_id?: UuidNullableFilter<"imports"> | string | null
    type?: StringFilter<"imports"> | string
    date_col_label?: StringNullableFilter<"imports"> | string | null
    amount_col_label?: StringNullableFilter<"imports"> | string | null
    name_col_label?: StringNullableFilter<"imports"> | string | null
    category_col_label?: StringNullableFilter<"imports"> | string | null
    tags_col_label?: StringNullableFilter<"imports"> | string | null
    account_col_label?: StringNullableFilter<"imports"> | string | null
    qty_col_label?: StringNullableFilter<"imports"> | string | null
    ticker_col_label?: StringNullableFilter<"imports"> | string | null
    price_col_label?: StringNullableFilter<"imports"> | string | null
    entity_type_col_label?: StringNullableFilter<"imports"> | string | null
    notes_col_label?: StringNullableFilter<"imports"> | string | null
    currency_col_label?: StringNullableFilter<"imports"> | string | null
    date_format?: StringNullableFilter<"imports"> | string | null
    signage_convention?: StringNullableFilter<"imports"> | string | null
    error?: StringNullableFilter<"imports"> | string | null
    number_format?: StringNullableFilter<"imports"> | string | null
    exchange_operating_mic_col_label?: StringNullableFilter<"imports"> | string | null
    amount_type_strategy?: StringNullableFilter<"imports"> | string | null
    amount_type_inflow_value?: StringNullableFilter<"imports"> | string | null
    accounts?: AccountsListRelationFilter
    entries?: EntriesListRelationFilter
    import_rows?: Import_rowsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id">

  export type importsOrderByWithAggregationInput = {
    id?: SortOrder
    column_mappings?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    raw_file_str?: SortOrderInput | SortOrder
    normalized_csv_str?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    col_sep?: SortOrderInput | SortOrder
    family_id?: SortOrder
    account_id?: SortOrderInput | SortOrder
    type?: SortOrder
    date_col_label?: SortOrderInput | SortOrder
    amount_col_label?: SortOrderInput | SortOrder
    name_col_label?: SortOrderInput | SortOrder
    category_col_label?: SortOrderInput | SortOrder
    tags_col_label?: SortOrderInput | SortOrder
    account_col_label?: SortOrderInput | SortOrder
    qty_col_label?: SortOrderInput | SortOrder
    ticker_col_label?: SortOrderInput | SortOrder
    price_col_label?: SortOrderInput | SortOrder
    entity_type_col_label?: SortOrderInput | SortOrder
    notes_col_label?: SortOrderInput | SortOrder
    currency_col_label?: SortOrderInput | SortOrder
    date_format?: SortOrderInput | SortOrder
    signage_convention?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    number_format?: SortOrderInput | SortOrder
    exchange_operating_mic_col_label?: SortOrderInput | SortOrder
    amount_type_strategy?: SortOrderInput | SortOrder
    amount_type_inflow_value?: SortOrderInput | SortOrder
    _count?: importsCountOrderByAggregateInput
    _max?: importsMaxOrderByAggregateInput
    _min?: importsMinOrderByAggregateInput
  }

  export type importsScalarWhereWithAggregatesInput = {
    AND?: importsScalarWhereWithAggregatesInput | importsScalarWhereWithAggregatesInput[]
    OR?: importsScalarWhereWithAggregatesInput[]
    NOT?: importsScalarWhereWithAggregatesInput | importsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"imports"> | string
    column_mappings?: JsonNullableWithAggregatesFilter<"imports">
    status?: StringNullableWithAggregatesFilter<"imports"> | string | null
    raw_file_str?: StringNullableWithAggregatesFilter<"imports"> | string | null
    normalized_csv_str?: StringNullableWithAggregatesFilter<"imports"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"imports"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"imports"> | Date | string
    col_sep?: StringNullableWithAggregatesFilter<"imports"> | string | null
    family_id?: UuidWithAggregatesFilter<"imports"> | string
    account_id?: UuidNullableWithAggregatesFilter<"imports"> | string | null
    type?: StringWithAggregatesFilter<"imports"> | string
    date_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    amount_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    name_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    category_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    tags_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    account_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    qty_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    ticker_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    price_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    entity_type_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    notes_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    currency_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    date_format?: StringNullableWithAggregatesFilter<"imports"> | string | null
    signage_convention?: StringNullableWithAggregatesFilter<"imports"> | string | null
    error?: StringNullableWithAggregatesFilter<"imports"> | string | null
    number_format?: StringNullableWithAggregatesFilter<"imports"> | string | null
    exchange_operating_mic_col_label?: StringNullableWithAggregatesFilter<"imports"> | string | null
    amount_type_strategy?: StringNullableWithAggregatesFilter<"imports"> | string | null
    amount_type_inflow_value?: StringNullableWithAggregatesFilter<"imports"> | string | null
  }

  export type investmentsWhereInput = {
    AND?: investmentsWhereInput | investmentsWhereInput[]
    OR?: investmentsWhereInput[]
    NOT?: investmentsWhereInput | investmentsWhereInput[]
    id?: UuidFilter<"investments"> | string
    created_at?: DateTimeFilter<"investments"> | Date | string
    updated_at?: DateTimeFilter<"investments"> | Date | string
    locked_attributes?: JsonNullableFilter<"investments">
  }

  export type investmentsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type investmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: investmentsWhereInput | investmentsWhereInput[]
    OR?: investmentsWhereInput[]
    NOT?: investmentsWhereInput | investmentsWhereInput[]
    created_at?: DateTimeFilter<"investments"> | Date | string
    updated_at?: DateTimeFilter<"investments"> | Date | string
    locked_attributes?: JsonNullableFilter<"investments">
  }, "id">

  export type investmentsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: investmentsCountOrderByAggregateInput
    _max?: investmentsMaxOrderByAggregateInput
    _min?: investmentsMinOrderByAggregateInput
  }

  export type investmentsScalarWhereWithAggregatesInput = {
    AND?: investmentsScalarWhereWithAggregatesInput | investmentsScalarWhereWithAggregatesInput[]
    OR?: investmentsScalarWhereWithAggregatesInput[]
    NOT?: investmentsScalarWhereWithAggregatesInput | investmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"investments"> | string
    created_at?: DateTimeWithAggregatesFilter<"investments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"investments"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"investments">
  }

  export type invitationsWhereInput = {
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    id?: UuidFilter<"invitations"> | string
    email?: StringNullableFilter<"invitations"> | string | null
    role?: StringNullableFilter<"invitations"> | string | null
    token?: StringNullableFilter<"invitations"> | string | null
    family_id?: UuidFilter<"invitations"> | string
    inviter_id?: UuidFilter<"invitations"> | string
    accepted_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    updated_at?: DateTimeFilter<"invitations"> | Date | string
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type invitationsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    family_id?: SortOrder
    inviter_id?: SortOrder
    accepted_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    families?: familiesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type invitationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_family_id?: invitationsEmailFamily_idCompoundUniqueInput
    AND?: invitationsWhereInput | invitationsWhereInput[]
    OR?: invitationsWhereInput[]
    NOT?: invitationsWhereInput | invitationsWhereInput[]
    email?: StringNullableFilter<"invitations"> | string | null
    role?: StringNullableFilter<"invitations"> | string | null
    family_id?: UuidFilter<"invitations"> | string
    inviter_id?: UuidFilter<"invitations"> | string
    accepted_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    updated_at?: DateTimeFilter<"invitations"> | Date | string
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "token" | "email_family_id">

  export type invitationsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    family_id?: SortOrder
    inviter_id?: SortOrder
    accepted_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: invitationsCountOrderByAggregateInput
    _max?: invitationsMaxOrderByAggregateInput
    _min?: invitationsMinOrderByAggregateInput
  }

  export type invitationsScalarWhereWithAggregatesInput = {
    AND?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    OR?: invitationsScalarWhereWithAggregatesInput[]
    NOT?: invitationsScalarWhereWithAggregatesInput | invitationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invitations"> | string
    email?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    role?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    token?: StringNullableWithAggregatesFilter<"invitations"> | string | null
    family_id?: UuidWithAggregatesFilter<"invitations"> | string
    inviter_id?: UuidWithAggregatesFilter<"invitations"> | string
    accepted_at?: DateTimeNullableWithAggregatesFilter<"invitations"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"invitations"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"invitations"> | Date | string
  }

  export type invite_codesWhereInput = {
    AND?: invite_codesWhereInput | invite_codesWhereInput[]
    OR?: invite_codesWhereInput[]
    NOT?: invite_codesWhereInput | invite_codesWhereInput[]
    id?: UuidFilter<"invite_codes"> | string
    token?: StringFilter<"invite_codes"> | string
    created_at?: DateTimeFilter<"invite_codes"> | Date | string
    updated_at?: DateTimeFilter<"invite_codes"> | Date | string
  }

  export type invite_codesOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invite_codesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: invite_codesWhereInput | invite_codesWhereInput[]
    OR?: invite_codesWhereInput[]
    NOT?: invite_codesWhereInput | invite_codesWhereInput[]
    created_at?: DateTimeFilter<"invite_codes"> | Date | string
    updated_at?: DateTimeFilter<"invite_codes"> | Date | string
  }, "id" | "token">

  export type invite_codesOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: invite_codesCountOrderByAggregateInput
    _max?: invite_codesMaxOrderByAggregateInput
    _min?: invite_codesMinOrderByAggregateInput
  }

  export type invite_codesScalarWhereWithAggregatesInput = {
    AND?: invite_codesScalarWhereWithAggregatesInput | invite_codesScalarWhereWithAggregatesInput[]
    OR?: invite_codesScalarWhereWithAggregatesInput[]
    NOT?: invite_codesScalarWhereWithAggregatesInput | invite_codesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invite_codes"> | string
    token?: StringWithAggregatesFilter<"invite_codes"> | string
    created_at?: DateTimeWithAggregatesFilter<"invite_codes"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"invite_codes"> | Date | string
  }

  export type loansWhereInput = {
    AND?: loansWhereInput | loansWhereInput[]
    OR?: loansWhereInput[]
    NOT?: loansWhereInput | loansWhereInput[]
    id?: UuidFilter<"loans"> | string
    created_at?: DateTimeFilter<"loans"> | Date | string
    updated_at?: DateTimeFilter<"loans"> | Date | string
    rate_type?: StringNullableFilter<"loans"> | string | null
    interest_rate?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    term_months?: IntNullableFilter<"loans"> | number | null
    initial_balance?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"loans">
  }

  export type loansOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rate_type?: SortOrderInput | SortOrder
    interest_rate?: SortOrderInput | SortOrder
    term_months?: SortOrderInput | SortOrder
    initial_balance?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type loansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: loansWhereInput | loansWhereInput[]
    OR?: loansWhereInput[]
    NOT?: loansWhereInput | loansWhereInput[]
    created_at?: DateTimeFilter<"loans"> | Date | string
    updated_at?: DateTimeFilter<"loans"> | Date | string
    rate_type?: StringNullableFilter<"loans"> | string | null
    interest_rate?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    term_months?: IntNullableFilter<"loans"> | number | null
    initial_balance?: DecimalNullableFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"loans">
  }, "id">

  export type loansOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rate_type?: SortOrderInput | SortOrder
    interest_rate?: SortOrderInput | SortOrder
    term_months?: SortOrderInput | SortOrder
    initial_balance?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: loansCountOrderByAggregateInput
    _avg?: loansAvgOrderByAggregateInput
    _max?: loansMaxOrderByAggregateInput
    _min?: loansMinOrderByAggregateInput
    _sum?: loansSumOrderByAggregateInput
  }

  export type loansScalarWhereWithAggregatesInput = {
    AND?: loansScalarWhereWithAggregatesInput | loansScalarWhereWithAggregatesInput[]
    OR?: loansScalarWhereWithAggregatesInput[]
    NOT?: loansScalarWhereWithAggregatesInput | loansScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"loans"> | string
    created_at?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"loans"> | Date | string
    rate_type?: StringNullableWithAggregatesFilter<"loans"> | string | null
    interest_rate?: DecimalNullableWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    term_months?: IntNullableWithAggregatesFilter<"loans"> | number | null
    initial_balance?: DecimalNullableWithAggregatesFilter<"loans"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"loans">
  }

  export type merchantsWhereInput = {
    AND?: merchantsWhereInput | merchantsWhereInput[]
    OR?: merchantsWhereInput[]
    NOT?: merchantsWhereInput | merchantsWhereInput[]
    id?: UuidFilter<"merchants"> | string
    name?: StringFilter<"merchants"> | string
    color?: StringNullableFilter<"merchants"> | string | null
    family_id?: UuidNullableFilter<"merchants"> | string | null
    created_at?: DateTimeFilter<"merchants"> | Date | string
    updated_at?: DateTimeFilter<"merchants"> | Date | string
    logo_url?: StringNullableFilter<"merchants"> | string | null
    website_url?: StringNullableFilter<"merchants"> | string | null
    type?: StringFilter<"merchants"> | string
    source?: StringNullableFilter<"merchants"> | string | null
    provider_merchant_id?: StringNullableFilter<"merchants"> | string | null
    families?: XOR<FamiliesNullableScalarRelationFilter, familiesWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }

  export type merchantsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    family_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    website_url?: SortOrderInput | SortOrder
    type?: SortOrder
    source?: SortOrderInput | SortOrder
    provider_merchant_id?: SortOrderInput | SortOrder
    families?: familiesOrderByWithRelationInput
    transactions?: transactionsOrderByRelationAggregateInput
  }

  export type merchantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: merchantsWhereInput | merchantsWhereInput[]
    OR?: merchantsWhereInput[]
    NOT?: merchantsWhereInput | merchantsWhereInput[]
    name?: StringFilter<"merchants"> | string
    color?: StringNullableFilter<"merchants"> | string | null
    family_id?: UuidNullableFilter<"merchants"> | string | null
    created_at?: DateTimeFilter<"merchants"> | Date | string
    updated_at?: DateTimeFilter<"merchants"> | Date | string
    logo_url?: StringNullableFilter<"merchants"> | string | null
    website_url?: StringNullableFilter<"merchants"> | string | null
    type?: StringFilter<"merchants"> | string
    source?: StringNullableFilter<"merchants"> | string | null
    provider_merchant_id?: StringNullableFilter<"merchants"> | string | null
    families?: XOR<FamiliesNullableScalarRelationFilter, familiesWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }, "id">

  export type merchantsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    family_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logo_url?: SortOrderInput | SortOrder
    website_url?: SortOrderInput | SortOrder
    type?: SortOrder
    source?: SortOrderInput | SortOrder
    provider_merchant_id?: SortOrderInput | SortOrder
    _count?: merchantsCountOrderByAggregateInput
    _max?: merchantsMaxOrderByAggregateInput
    _min?: merchantsMinOrderByAggregateInput
  }

  export type merchantsScalarWhereWithAggregatesInput = {
    AND?: merchantsScalarWhereWithAggregatesInput | merchantsScalarWhereWithAggregatesInput[]
    OR?: merchantsScalarWhereWithAggregatesInput[]
    NOT?: merchantsScalarWhereWithAggregatesInput | merchantsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"merchants"> | string
    name?: StringWithAggregatesFilter<"merchants"> | string
    color?: StringNullableWithAggregatesFilter<"merchants"> | string | null
    family_id?: UuidNullableWithAggregatesFilter<"merchants"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"merchants"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"merchants"> | Date | string
    logo_url?: StringNullableWithAggregatesFilter<"merchants"> | string | null
    website_url?: StringNullableWithAggregatesFilter<"merchants"> | string | null
    type?: StringWithAggregatesFilter<"merchants"> | string
    source?: StringNullableWithAggregatesFilter<"merchants"> | string | null
    provider_merchant_id?: StringNullableWithAggregatesFilter<"merchants"> | string | null
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: UuidFilter<"messages"> | string
    chat_id?: UuidFilter<"messages"> | string
    type?: StringFilter<"messages"> | string
    status?: StringFilter<"messages"> | string
    content?: StringNullableFilter<"messages"> | string | null
    ai_model?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    updated_at?: DateTimeFilter<"messages"> | Date | string
    debug?: BoolNullableFilter<"messages"> | boolean | null
    provider_id?: StringNullableFilter<"messages"> | string | null
    reasoning?: BoolNullableFilter<"messages"> | boolean | null
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    tool_calls?: Tool_callsListRelationFilter
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    chat_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    content?: SortOrderInput | SortOrder
    ai_model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debug?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    chats?: chatsOrderByWithRelationInput
    tool_calls?: tool_callsOrderByRelationAggregateInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    chat_id?: UuidFilter<"messages"> | string
    type?: StringFilter<"messages"> | string
    status?: StringFilter<"messages"> | string
    content?: StringNullableFilter<"messages"> | string | null
    ai_model?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    updated_at?: DateTimeFilter<"messages"> | Date | string
    debug?: BoolNullableFilter<"messages"> | boolean | null
    provider_id?: StringNullableFilter<"messages"> | string | null
    reasoning?: BoolNullableFilter<"messages"> | boolean | null
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    tool_calls?: Tool_callsListRelationFilter
  }, "id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    chat_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    content?: SortOrderInput | SortOrder
    ai_model?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debug?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    _count?: messagesCountOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"messages"> | string
    chat_id?: UuidWithAggregatesFilter<"messages"> | string
    type?: StringWithAggregatesFilter<"messages"> | string
    status?: StringWithAggregatesFilter<"messages"> | string
    content?: StringNullableWithAggregatesFilter<"messages"> | string | null
    ai_model?: StringNullableWithAggregatesFilter<"messages"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"messages"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"messages"> | Date | string
    debug?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    provider_id?: StringNullableWithAggregatesFilter<"messages"> | string | null
    reasoning?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
  }

  export type other_assetsWhereInput = {
    AND?: other_assetsWhereInput | other_assetsWhereInput[]
    OR?: other_assetsWhereInput[]
    NOT?: other_assetsWhereInput | other_assetsWhereInput[]
    id?: UuidFilter<"other_assets"> | string
    created_at?: DateTimeFilter<"other_assets"> | Date | string
    updated_at?: DateTimeFilter<"other_assets"> | Date | string
    locked_attributes?: JsonNullableFilter<"other_assets">
  }

  export type other_assetsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type other_assetsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: other_assetsWhereInput | other_assetsWhereInput[]
    OR?: other_assetsWhereInput[]
    NOT?: other_assetsWhereInput | other_assetsWhereInput[]
    created_at?: DateTimeFilter<"other_assets"> | Date | string
    updated_at?: DateTimeFilter<"other_assets"> | Date | string
    locked_attributes?: JsonNullableFilter<"other_assets">
  }, "id">

  export type other_assetsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: other_assetsCountOrderByAggregateInput
    _max?: other_assetsMaxOrderByAggregateInput
    _min?: other_assetsMinOrderByAggregateInput
  }

  export type other_assetsScalarWhereWithAggregatesInput = {
    AND?: other_assetsScalarWhereWithAggregatesInput | other_assetsScalarWhereWithAggregatesInput[]
    OR?: other_assetsScalarWhereWithAggregatesInput[]
    NOT?: other_assetsScalarWhereWithAggregatesInput | other_assetsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"other_assets"> | string
    created_at?: DateTimeWithAggregatesFilter<"other_assets"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"other_assets"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"other_assets">
  }

  export type other_liabilitiesWhereInput = {
    AND?: other_liabilitiesWhereInput | other_liabilitiesWhereInput[]
    OR?: other_liabilitiesWhereInput[]
    NOT?: other_liabilitiesWhereInput | other_liabilitiesWhereInput[]
    id?: UuidFilter<"other_liabilities"> | string
    created_at?: DateTimeFilter<"other_liabilities"> | Date | string
    updated_at?: DateTimeFilter<"other_liabilities"> | Date | string
    locked_attributes?: JsonNullableFilter<"other_liabilities">
  }

  export type other_liabilitiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type other_liabilitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: other_liabilitiesWhereInput | other_liabilitiesWhereInput[]
    OR?: other_liabilitiesWhereInput[]
    NOT?: other_liabilitiesWhereInput | other_liabilitiesWhereInput[]
    created_at?: DateTimeFilter<"other_liabilities"> | Date | string
    updated_at?: DateTimeFilter<"other_liabilities"> | Date | string
    locked_attributes?: JsonNullableFilter<"other_liabilities">
  }, "id">

  export type other_liabilitiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: other_liabilitiesCountOrderByAggregateInput
    _max?: other_liabilitiesMaxOrderByAggregateInput
    _min?: other_liabilitiesMinOrderByAggregateInput
  }

  export type other_liabilitiesScalarWhereWithAggregatesInput = {
    AND?: other_liabilitiesScalarWhereWithAggregatesInput | other_liabilitiesScalarWhereWithAggregatesInput[]
    OR?: other_liabilitiesScalarWhereWithAggregatesInput[]
    NOT?: other_liabilitiesScalarWhereWithAggregatesInput | other_liabilitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"other_liabilities"> | string
    created_at?: DateTimeWithAggregatesFilter<"other_liabilities"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"other_liabilities"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"other_liabilities">
  }

  export type plaid_accountsWhereInput = {
    AND?: plaid_accountsWhereInput | plaid_accountsWhereInput[]
    OR?: plaid_accountsWhereInput[]
    NOT?: plaid_accountsWhereInput | plaid_accountsWhereInput[]
    id?: UuidFilter<"plaid_accounts"> | string
    plaid_item_id?: UuidFilter<"plaid_accounts"> | string
    plaid_id?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_type?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_subtype?: StringNullableFilter<"plaid_accounts"> | string | null
    current_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    available_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"plaid_accounts"> | string | null
    name?: StringNullableFilter<"plaid_accounts"> | string | null
    mask?: StringNullableFilter<"plaid_accounts"> | string | null
    created_at?: DateTimeFilter<"plaid_accounts"> | Date | string
    updated_at?: DateTimeFilter<"plaid_accounts"> | Date | string
    accounts?: AccountsListRelationFilter
    plaid_items?: XOR<Plaid_itemsScalarRelationFilter, plaid_itemsWhereInput>
  }

  export type plaid_accountsOrderByWithRelationInput = {
    id?: SortOrder
    plaid_item_id?: SortOrder
    plaid_id?: SortOrderInput | SortOrder
    plaid_type?: SortOrderInput | SortOrder
    plaid_subtype?: SortOrderInput | SortOrder
    current_balance?: SortOrderInput | SortOrder
    available_balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    mask?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    plaid_items?: plaid_itemsOrderByWithRelationInput
  }

  export type plaid_accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plaid_accountsWhereInput | plaid_accountsWhereInput[]
    OR?: plaid_accountsWhereInput[]
    NOT?: plaid_accountsWhereInput | plaid_accountsWhereInput[]
    plaid_item_id?: UuidFilter<"plaid_accounts"> | string
    plaid_id?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_type?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_subtype?: StringNullableFilter<"plaid_accounts"> | string | null
    current_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    available_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"plaid_accounts"> | string | null
    name?: StringNullableFilter<"plaid_accounts"> | string | null
    mask?: StringNullableFilter<"plaid_accounts"> | string | null
    created_at?: DateTimeFilter<"plaid_accounts"> | Date | string
    updated_at?: DateTimeFilter<"plaid_accounts"> | Date | string
    accounts?: AccountsListRelationFilter
    plaid_items?: XOR<Plaid_itemsScalarRelationFilter, plaid_itemsWhereInput>
  }, "id">

  export type plaid_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    plaid_item_id?: SortOrder
    plaid_id?: SortOrderInput | SortOrder
    plaid_type?: SortOrderInput | SortOrder
    plaid_subtype?: SortOrderInput | SortOrder
    current_balance?: SortOrderInput | SortOrder
    available_balance?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    mask?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: plaid_accountsCountOrderByAggregateInput
    _avg?: plaid_accountsAvgOrderByAggregateInput
    _max?: plaid_accountsMaxOrderByAggregateInput
    _min?: plaid_accountsMinOrderByAggregateInput
    _sum?: plaid_accountsSumOrderByAggregateInput
  }

  export type plaid_accountsScalarWhereWithAggregatesInput = {
    AND?: plaid_accountsScalarWhereWithAggregatesInput | plaid_accountsScalarWhereWithAggregatesInput[]
    OR?: plaid_accountsScalarWhereWithAggregatesInput[]
    NOT?: plaid_accountsScalarWhereWithAggregatesInput | plaid_accountsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"plaid_accounts"> | string
    plaid_item_id?: UuidWithAggregatesFilter<"plaid_accounts"> | string
    plaid_id?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    plaid_type?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    plaid_subtype?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    current_balance?: DecimalNullableWithAggregatesFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    available_balance?: DecimalNullableWithAggregatesFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    name?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    mask?: StringNullableWithAggregatesFilter<"plaid_accounts"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"plaid_accounts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"plaid_accounts"> | Date | string
  }

  export type plaid_itemsWhereInput = {
    AND?: plaid_itemsWhereInput | plaid_itemsWhereInput[]
    OR?: plaid_itemsWhereInput[]
    NOT?: plaid_itemsWhereInput | plaid_itemsWhereInput[]
    id?: UuidFilter<"plaid_items"> | string
    family_id?: UuidFilter<"plaid_items"> | string
    access_token?: StringNullableFilter<"plaid_items"> | string | null
    plaid_id?: StringNullableFilter<"plaid_items"> | string | null
    name?: StringNullableFilter<"plaid_items"> | string | null
    next_cursor?: StringNullableFilter<"plaid_items"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"plaid_items"> | boolean | null
    created_at?: DateTimeFilter<"plaid_items"> | Date | string
    updated_at?: DateTimeFilter<"plaid_items"> | Date | string
    available_products?: StringNullableListFilter<"plaid_items">
    billed_products?: StringNullableListFilter<"plaid_items">
    last_synced_at?: DateTimeNullableFilter<"plaid_items"> | Date | string | null
    plaid_region?: StringFilter<"plaid_items"> | string
    institution_url?: StringNullableFilter<"plaid_items"> | string | null
    institution_id?: StringNullableFilter<"plaid_items"> | string | null
    institution_color?: StringNullableFilter<"plaid_items"> | string | null
    status?: StringFilter<"plaid_items"> | string
    plaid_accounts?: Plaid_accountsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type plaid_itemsOrderByWithRelationInput = {
    id?: SortOrder
    family_id?: SortOrder
    access_token?: SortOrderInput | SortOrder
    plaid_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    next_cursor?: SortOrderInput | SortOrder
    scheduled_for_deletion?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_products?: SortOrder
    billed_products?: SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    plaid_region?: SortOrder
    institution_url?: SortOrderInput | SortOrder
    institution_id?: SortOrderInput | SortOrder
    institution_color?: SortOrderInput | SortOrder
    status?: SortOrder
    plaid_accounts?: plaid_accountsOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
  }

  export type plaid_itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: plaid_itemsWhereInput | plaid_itemsWhereInput[]
    OR?: plaid_itemsWhereInput[]
    NOT?: plaid_itemsWhereInput | plaid_itemsWhereInput[]
    family_id?: UuidFilter<"plaid_items"> | string
    access_token?: StringNullableFilter<"plaid_items"> | string | null
    plaid_id?: StringNullableFilter<"plaid_items"> | string | null
    name?: StringNullableFilter<"plaid_items"> | string | null
    next_cursor?: StringNullableFilter<"plaid_items"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"plaid_items"> | boolean | null
    created_at?: DateTimeFilter<"plaid_items"> | Date | string
    updated_at?: DateTimeFilter<"plaid_items"> | Date | string
    available_products?: StringNullableListFilter<"plaid_items">
    billed_products?: StringNullableListFilter<"plaid_items">
    last_synced_at?: DateTimeNullableFilter<"plaid_items"> | Date | string | null
    plaid_region?: StringFilter<"plaid_items"> | string
    institution_url?: StringNullableFilter<"plaid_items"> | string | null
    institution_id?: StringNullableFilter<"plaid_items"> | string | null
    institution_color?: StringNullableFilter<"plaid_items"> | string | null
    status?: StringFilter<"plaid_items"> | string
    plaid_accounts?: Plaid_accountsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id">

  export type plaid_itemsOrderByWithAggregationInput = {
    id?: SortOrder
    family_id?: SortOrder
    access_token?: SortOrderInput | SortOrder
    plaid_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    next_cursor?: SortOrderInput | SortOrder
    scheduled_for_deletion?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_products?: SortOrder
    billed_products?: SortOrder
    last_synced_at?: SortOrderInput | SortOrder
    plaid_region?: SortOrder
    institution_url?: SortOrderInput | SortOrder
    institution_id?: SortOrderInput | SortOrder
    institution_color?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: plaid_itemsCountOrderByAggregateInput
    _max?: plaid_itemsMaxOrderByAggregateInput
    _min?: plaid_itemsMinOrderByAggregateInput
  }

  export type plaid_itemsScalarWhereWithAggregatesInput = {
    AND?: plaid_itemsScalarWhereWithAggregatesInput | plaid_itemsScalarWhereWithAggregatesInput[]
    OR?: plaid_itemsScalarWhereWithAggregatesInput[]
    NOT?: plaid_itemsScalarWhereWithAggregatesInput | plaid_itemsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"plaid_items"> | string
    family_id?: UuidWithAggregatesFilter<"plaid_items"> | string
    access_token?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    plaid_id?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    name?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    next_cursor?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    scheduled_for_deletion?: BoolNullableWithAggregatesFilter<"plaid_items"> | boolean | null
    created_at?: DateTimeWithAggregatesFilter<"plaid_items"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"plaid_items"> | Date | string
    available_products?: StringNullableListFilter<"plaid_items">
    billed_products?: StringNullableListFilter<"plaid_items">
    last_synced_at?: DateTimeNullableWithAggregatesFilter<"plaid_items"> | Date | string | null
    plaid_region?: StringWithAggregatesFilter<"plaid_items"> | string
    institution_url?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    institution_id?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    institution_color?: StringNullableWithAggregatesFilter<"plaid_items"> | string | null
    status?: StringWithAggregatesFilter<"plaid_items"> | string
  }

  export type propertiesWhereInput = {
    AND?: propertiesWhereInput | propertiesWhereInput[]
    OR?: propertiesWhereInput[]
    NOT?: propertiesWhereInput | propertiesWhereInput[]
    id?: UuidFilter<"properties"> | string
    created_at?: DateTimeFilter<"properties"> | Date | string
    updated_at?: DateTimeFilter<"properties"> | Date | string
    year_built?: IntNullableFilter<"properties"> | number | null
    area_value?: IntNullableFilter<"properties"> | number | null
    area_unit?: StringNullableFilter<"properties"> | string | null
    locked_attributes?: JsonNullableFilter<"properties">
  }

  export type propertiesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year_built?: SortOrderInput | SortOrder
    area_value?: SortOrderInput | SortOrder
    area_unit?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type propertiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: propertiesWhereInput | propertiesWhereInput[]
    OR?: propertiesWhereInput[]
    NOT?: propertiesWhereInput | propertiesWhereInput[]
    created_at?: DateTimeFilter<"properties"> | Date | string
    updated_at?: DateTimeFilter<"properties"> | Date | string
    year_built?: IntNullableFilter<"properties"> | number | null
    area_value?: IntNullableFilter<"properties"> | number | null
    area_unit?: StringNullableFilter<"properties"> | string | null
    locked_attributes?: JsonNullableFilter<"properties">
  }, "id">

  export type propertiesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year_built?: SortOrderInput | SortOrder
    area_value?: SortOrderInput | SortOrder
    area_unit?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: propertiesCountOrderByAggregateInput
    _avg?: propertiesAvgOrderByAggregateInput
    _max?: propertiesMaxOrderByAggregateInput
    _min?: propertiesMinOrderByAggregateInput
    _sum?: propertiesSumOrderByAggregateInput
  }

  export type propertiesScalarWhereWithAggregatesInput = {
    AND?: propertiesScalarWhereWithAggregatesInput | propertiesScalarWhereWithAggregatesInput[]
    OR?: propertiesScalarWhereWithAggregatesInput[]
    NOT?: propertiesScalarWhereWithAggregatesInput | propertiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"properties"> | string
    created_at?: DateTimeWithAggregatesFilter<"properties"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"properties"> | Date | string
    year_built?: IntNullableWithAggregatesFilter<"properties"> | number | null
    area_value?: IntNullableWithAggregatesFilter<"properties"> | number | null
    area_unit?: StringNullableWithAggregatesFilter<"properties"> | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"properties">
  }

  export type rejected_transfersWhereInput = {
    AND?: rejected_transfersWhereInput | rejected_transfersWhereInput[]
    OR?: rejected_transfersWhereInput[]
    NOT?: rejected_transfersWhereInput | rejected_transfersWhereInput[]
    id?: UuidFilter<"rejected_transfers"> | string
    inflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    outflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    created_at?: DateTimeFilter<"rejected_transfers"> | Date | string
    updated_at?: DateTimeFilter<"rejected_transfers"> | Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
  }

  export type rejected_transfersOrderByWithRelationInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: transactionsOrderByWithRelationInput
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: transactionsOrderByWithRelationInput
  }

  export type rejected_transfersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inflow_transaction_id_outflow_transaction_id?: rejected_transfersInflow_transaction_idOutflow_transaction_idCompoundUniqueInput
    AND?: rejected_transfersWhereInput | rejected_transfersWhereInput[]
    OR?: rejected_transfersWhereInput[]
    NOT?: rejected_transfersWhereInput | rejected_transfersWhereInput[]
    inflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    outflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    created_at?: DateTimeFilter<"rejected_transfers"> | Date | string
    updated_at?: DateTimeFilter<"rejected_transfers"> | Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
  }, "id" | "inflow_transaction_id_outflow_transaction_id">

  export type rejected_transfersOrderByWithAggregationInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: rejected_transfersCountOrderByAggregateInput
    _max?: rejected_transfersMaxOrderByAggregateInput
    _min?: rejected_transfersMinOrderByAggregateInput
  }

  export type rejected_transfersScalarWhereWithAggregatesInput = {
    AND?: rejected_transfersScalarWhereWithAggregatesInput | rejected_transfersScalarWhereWithAggregatesInput[]
    OR?: rejected_transfersScalarWhereWithAggregatesInput[]
    NOT?: rejected_transfersScalarWhereWithAggregatesInput | rejected_transfersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"rejected_transfers"> | string
    inflow_transaction_id?: UuidWithAggregatesFilter<"rejected_transfers"> | string
    outflow_transaction_id?: UuidWithAggregatesFilter<"rejected_transfers"> | string
    created_at?: DateTimeWithAggregatesFilter<"rejected_transfers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"rejected_transfers"> | Date | string
  }

  export type rule_actionsWhereInput = {
    AND?: rule_actionsWhereInput | rule_actionsWhereInput[]
    OR?: rule_actionsWhereInput[]
    NOT?: rule_actionsWhereInput | rule_actionsWhereInput[]
    id?: UuidFilter<"rule_actions"> | string
    rule_id?: UuidFilter<"rule_actions"> | string
    action_type?: StringFilter<"rule_actions"> | string
    value?: StringNullableFilter<"rule_actions"> | string | null
    created_at?: DateTimeFilter<"rule_actions"> | Date | string
    updated_at?: DateTimeFilter<"rule_actions"> | Date | string
    rules?: XOR<RulesScalarRelationFilter, rulesWhereInput>
  }

  export type rule_actionsOrderByWithRelationInput = {
    id?: SortOrder
    rule_id?: SortOrder
    action_type?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rules?: rulesOrderByWithRelationInput
  }

  export type rule_actionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rule_actionsWhereInput | rule_actionsWhereInput[]
    OR?: rule_actionsWhereInput[]
    NOT?: rule_actionsWhereInput | rule_actionsWhereInput[]
    rule_id?: UuidFilter<"rule_actions"> | string
    action_type?: StringFilter<"rule_actions"> | string
    value?: StringNullableFilter<"rule_actions"> | string | null
    created_at?: DateTimeFilter<"rule_actions"> | Date | string
    updated_at?: DateTimeFilter<"rule_actions"> | Date | string
    rules?: XOR<RulesScalarRelationFilter, rulesWhereInput>
  }, "id">

  export type rule_actionsOrderByWithAggregationInput = {
    id?: SortOrder
    rule_id?: SortOrder
    action_type?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: rule_actionsCountOrderByAggregateInput
    _max?: rule_actionsMaxOrderByAggregateInput
    _min?: rule_actionsMinOrderByAggregateInput
  }

  export type rule_actionsScalarWhereWithAggregatesInput = {
    AND?: rule_actionsScalarWhereWithAggregatesInput | rule_actionsScalarWhereWithAggregatesInput[]
    OR?: rule_actionsScalarWhereWithAggregatesInput[]
    NOT?: rule_actionsScalarWhereWithAggregatesInput | rule_actionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"rule_actions"> | string
    rule_id?: UuidWithAggregatesFilter<"rule_actions"> | string
    action_type?: StringWithAggregatesFilter<"rule_actions"> | string
    value?: StringNullableWithAggregatesFilter<"rule_actions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"rule_actions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"rule_actions"> | Date | string
  }

  export type rule_conditionsWhereInput = {
    AND?: rule_conditionsWhereInput | rule_conditionsWhereInput[]
    OR?: rule_conditionsWhereInput[]
    NOT?: rule_conditionsWhereInput | rule_conditionsWhereInput[]
    id?: UuidFilter<"rule_conditions"> | string
    rule_id?: UuidNullableFilter<"rule_conditions"> | string | null
    parent_id?: UuidNullableFilter<"rule_conditions"> | string | null
    condition_type?: StringFilter<"rule_conditions"> | string
    operator?: StringFilter<"rule_conditions"> | string
    value?: StringNullableFilter<"rule_conditions"> | string | null
    created_at?: DateTimeFilter<"rule_conditions"> | Date | string
    updated_at?: DateTimeFilter<"rule_conditions"> | Date | string
    rule_conditions?: XOR<Rule_conditionsNullableScalarRelationFilter, rule_conditionsWhereInput> | null
    other_rule_conditions?: Rule_conditionsListRelationFilter
    rules?: XOR<RulesNullableScalarRelationFilter, rulesWhereInput> | null
  }

  export type rule_conditionsOrderByWithRelationInput = {
    id?: SortOrder
    rule_id?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    condition_type?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rule_conditions?: rule_conditionsOrderByWithRelationInput
    other_rule_conditions?: rule_conditionsOrderByRelationAggregateInput
    rules?: rulesOrderByWithRelationInput
  }

  export type rule_conditionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rule_conditionsWhereInput | rule_conditionsWhereInput[]
    OR?: rule_conditionsWhereInput[]
    NOT?: rule_conditionsWhereInput | rule_conditionsWhereInput[]
    rule_id?: UuidNullableFilter<"rule_conditions"> | string | null
    parent_id?: UuidNullableFilter<"rule_conditions"> | string | null
    condition_type?: StringFilter<"rule_conditions"> | string
    operator?: StringFilter<"rule_conditions"> | string
    value?: StringNullableFilter<"rule_conditions"> | string | null
    created_at?: DateTimeFilter<"rule_conditions"> | Date | string
    updated_at?: DateTimeFilter<"rule_conditions"> | Date | string
    rule_conditions?: XOR<Rule_conditionsNullableScalarRelationFilter, rule_conditionsWhereInput> | null
    other_rule_conditions?: Rule_conditionsListRelationFilter
    rules?: XOR<RulesNullableScalarRelationFilter, rulesWhereInput> | null
  }, "id">

  export type rule_conditionsOrderByWithAggregationInput = {
    id?: SortOrder
    rule_id?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    condition_type?: SortOrder
    operator?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: rule_conditionsCountOrderByAggregateInput
    _max?: rule_conditionsMaxOrderByAggregateInput
    _min?: rule_conditionsMinOrderByAggregateInput
  }

  export type rule_conditionsScalarWhereWithAggregatesInput = {
    AND?: rule_conditionsScalarWhereWithAggregatesInput | rule_conditionsScalarWhereWithAggregatesInput[]
    OR?: rule_conditionsScalarWhereWithAggregatesInput[]
    NOT?: rule_conditionsScalarWhereWithAggregatesInput | rule_conditionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"rule_conditions"> | string
    rule_id?: UuidNullableWithAggregatesFilter<"rule_conditions"> | string | null
    parent_id?: UuidNullableWithAggregatesFilter<"rule_conditions"> | string | null
    condition_type?: StringWithAggregatesFilter<"rule_conditions"> | string
    operator?: StringWithAggregatesFilter<"rule_conditions"> | string
    value?: StringNullableWithAggregatesFilter<"rule_conditions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"rule_conditions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"rule_conditions"> | Date | string
  }

  export type rulesWhereInput = {
    AND?: rulesWhereInput | rulesWhereInput[]
    OR?: rulesWhereInput[]
    NOT?: rulesWhereInput | rulesWhereInput[]
    id?: UuidFilter<"rules"> | string
    family_id?: UuidFilter<"rules"> | string
    resource_type?: StringFilter<"rules"> | string
    effective_date?: DateTimeNullableFilter<"rules"> | Date | string | null
    active?: BoolFilter<"rules"> | boolean
    created_at?: DateTimeFilter<"rules"> | Date | string
    updated_at?: DateTimeFilter<"rules"> | Date | string
    rule_actions?: Rule_actionsListRelationFilter
    rule_conditions?: Rule_conditionsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type rulesOrderByWithRelationInput = {
    id?: SortOrder
    family_id?: SortOrder
    resource_type?: SortOrder
    effective_date?: SortOrderInput | SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rule_actions?: rule_actionsOrderByRelationAggregateInput
    rule_conditions?: rule_conditionsOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
  }

  export type rulesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rulesWhereInput | rulesWhereInput[]
    OR?: rulesWhereInput[]
    NOT?: rulesWhereInput | rulesWhereInput[]
    family_id?: UuidFilter<"rules"> | string
    resource_type?: StringFilter<"rules"> | string
    effective_date?: DateTimeNullableFilter<"rules"> | Date | string | null
    active?: BoolFilter<"rules"> | boolean
    created_at?: DateTimeFilter<"rules"> | Date | string
    updated_at?: DateTimeFilter<"rules"> | Date | string
    rule_actions?: Rule_actionsListRelationFilter
    rule_conditions?: Rule_conditionsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id">

  export type rulesOrderByWithAggregationInput = {
    id?: SortOrder
    family_id?: SortOrder
    resource_type?: SortOrder
    effective_date?: SortOrderInput | SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: rulesCountOrderByAggregateInput
    _max?: rulesMaxOrderByAggregateInput
    _min?: rulesMinOrderByAggregateInput
  }

  export type rulesScalarWhereWithAggregatesInput = {
    AND?: rulesScalarWhereWithAggregatesInput | rulesScalarWhereWithAggregatesInput[]
    OR?: rulesScalarWhereWithAggregatesInput[]
    NOT?: rulesScalarWhereWithAggregatesInput | rulesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"rules"> | string
    family_id?: UuidWithAggregatesFilter<"rules"> | string
    resource_type?: StringWithAggregatesFilter<"rules"> | string
    effective_date?: DateTimeNullableWithAggregatesFilter<"rules"> | Date | string | null
    active?: BoolWithAggregatesFilter<"rules"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"rules"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"rules"> | Date | string
  }

  export type schema_migrationsWhereInput = {
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    version?: StringFilter<"schema_migrations"> | string
  }

  export type schema_migrationsOrderByWithRelationInput = {
    version?: SortOrder
  }

  export type schema_migrationsWhereUniqueInput = Prisma.AtLeast<{
    version?: string
    AND?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
    OR?: schema_migrationsWhereInput[]
    NOT?: schema_migrationsWhereInput | schema_migrationsWhereInput[]
  }, "version">

  export type schema_migrationsOrderByWithAggregationInput = {
    version?: SortOrder
    _count?: schema_migrationsCountOrderByAggregateInput
    _max?: schema_migrationsMaxOrderByAggregateInput
    _min?: schema_migrationsMinOrderByAggregateInput
  }

  export type schema_migrationsScalarWhereWithAggregatesInput = {
    AND?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    OR?: schema_migrationsScalarWhereWithAggregatesInput[]
    NOT?: schema_migrationsScalarWhereWithAggregatesInput | schema_migrationsScalarWhereWithAggregatesInput[]
    version?: StringWithAggregatesFilter<"schema_migrations"> | string
  }

  export type securitiesWhereInput = {
    AND?: securitiesWhereInput | securitiesWhereInput[]
    OR?: securitiesWhereInput[]
    NOT?: securitiesWhereInput | securitiesWhereInput[]
    id?: UuidFilter<"securities"> | string
    ticker?: StringFilter<"securities"> | string
    name?: StringNullableFilter<"securities"> | string | null
    created_at?: DateTimeFilter<"securities"> | Date | string
    updated_at?: DateTimeFilter<"securities"> | Date | string
    country_code?: StringNullableFilter<"securities"> | string | null
    exchange_mic?: StringNullableFilter<"securities"> | string | null
    exchange_acronym?: StringNullableFilter<"securities"> | string | null
    logo_url?: StringNullableFilter<"securities"> | string | null
    exchange_operating_mic?: StringNullableFilter<"securities"> | string | null
    holdings?: HoldingsListRelationFilter
    security_prices?: Security_pricesListRelationFilter
    trades?: TradesListRelationFilter
  }

  export type securitiesOrderByWithRelationInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country_code?: SortOrderInput | SortOrder
    exchange_mic?: SortOrderInput | SortOrder
    exchange_acronym?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    exchange_operating_mic?: SortOrderInput | SortOrder
    holdings?: holdingsOrderByRelationAggregateInput
    security_prices?: security_pricesOrderByRelationAggregateInput
    trades?: tradesOrderByRelationAggregateInput
  }

  export type securitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticker_exchange_operating_mic?: securitiesTickerExchange_operating_micCompoundUniqueInput
    AND?: securitiesWhereInput | securitiesWhereInput[]
    OR?: securitiesWhereInput[]
    NOT?: securitiesWhereInput | securitiesWhereInput[]
    ticker?: StringFilter<"securities"> | string
    name?: StringNullableFilter<"securities"> | string | null
    created_at?: DateTimeFilter<"securities"> | Date | string
    updated_at?: DateTimeFilter<"securities"> | Date | string
    country_code?: StringNullableFilter<"securities"> | string | null
    exchange_mic?: StringNullableFilter<"securities"> | string | null
    exchange_acronym?: StringNullableFilter<"securities"> | string | null
    logo_url?: StringNullableFilter<"securities"> | string | null
    exchange_operating_mic?: StringNullableFilter<"securities"> | string | null
    holdings?: HoldingsListRelationFilter
    security_prices?: Security_pricesListRelationFilter
    trades?: TradesListRelationFilter
  }, "id" | "ticker_exchange_operating_mic">

  export type securitiesOrderByWithAggregationInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country_code?: SortOrderInput | SortOrder
    exchange_mic?: SortOrderInput | SortOrder
    exchange_acronym?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    exchange_operating_mic?: SortOrderInput | SortOrder
    _count?: securitiesCountOrderByAggregateInput
    _max?: securitiesMaxOrderByAggregateInput
    _min?: securitiesMinOrderByAggregateInput
  }

  export type securitiesScalarWhereWithAggregatesInput = {
    AND?: securitiesScalarWhereWithAggregatesInput | securitiesScalarWhereWithAggregatesInput[]
    OR?: securitiesScalarWhereWithAggregatesInput[]
    NOT?: securitiesScalarWhereWithAggregatesInput | securitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"securities"> | string
    ticker?: StringWithAggregatesFilter<"securities"> | string
    name?: StringNullableWithAggregatesFilter<"securities"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"securities"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"securities"> | Date | string
    country_code?: StringNullableWithAggregatesFilter<"securities"> | string | null
    exchange_mic?: StringNullableWithAggregatesFilter<"securities"> | string | null
    exchange_acronym?: StringNullableWithAggregatesFilter<"securities"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"securities"> | string | null
    exchange_operating_mic?: StringNullableWithAggregatesFilter<"securities"> | string | null
  }

  export type security_pricesWhereInput = {
    AND?: security_pricesWhereInput | security_pricesWhereInput[]
    OR?: security_pricesWhereInput[]
    NOT?: security_pricesWhereInput | security_pricesWhereInput[]
    id?: UuidFilter<"security_prices"> | string
    date?: DateTimeFilter<"security_prices"> | Date | string
    price?: DecimalFilter<"security_prices"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"security_prices"> | string
    created_at?: DateTimeFilter<"security_prices"> | Date | string
    updated_at?: DateTimeFilter<"security_prices"> | Date | string
    security_id?: UuidNullableFilter<"security_prices"> | string | null
    securities?: XOR<SecuritiesNullableScalarRelationFilter, securitiesWhereInput> | null
  }

  export type security_pricesOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    security_id?: SortOrderInput | SortOrder
    securities?: securitiesOrderByWithRelationInput
  }

  export type security_pricesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    security_id_date_currency?: security_pricesSecurity_idDateCurrencyCompoundUniqueInput
    AND?: security_pricesWhereInput | security_pricesWhereInput[]
    OR?: security_pricesWhereInput[]
    NOT?: security_pricesWhereInput | security_pricesWhereInput[]
    date?: DateTimeFilter<"security_prices"> | Date | string
    price?: DecimalFilter<"security_prices"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"security_prices"> | string
    created_at?: DateTimeFilter<"security_prices"> | Date | string
    updated_at?: DateTimeFilter<"security_prices"> | Date | string
    security_id?: UuidNullableFilter<"security_prices"> | string | null
    securities?: XOR<SecuritiesNullableScalarRelationFilter, securitiesWhereInput> | null
  }, "id" | "security_id_date_currency">

  export type security_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    security_id?: SortOrderInput | SortOrder
    _count?: security_pricesCountOrderByAggregateInput
    _avg?: security_pricesAvgOrderByAggregateInput
    _max?: security_pricesMaxOrderByAggregateInput
    _min?: security_pricesMinOrderByAggregateInput
    _sum?: security_pricesSumOrderByAggregateInput
  }

  export type security_pricesScalarWhereWithAggregatesInput = {
    AND?: security_pricesScalarWhereWithAggregatesInput | security_pricesScalarWhereWithAggregatesInput[]
    OR?: security_pricesScalarWhereWithAggregatesInput[]
    NOT?: security_pricesScalarWhereWithAggregatesInput | security_pricesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"security_prices"> | string
    date?: DateTimeWithAggregatesFilter<"security_prices"> | Date | string
    price?: DecimalWithAggregatesFilter<"security_prices"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"security_prices"> | string
    created_at?: DateTimeWithAggregatesFilter<"security_prices"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"security_prices"> | Date | string
    security_id?: UuidNullableWithAggregatesFilter<"security_prices"> | string | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidFilter<"sessions"> | string
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeFilter<"sessions"> | Date | string
    active_impersonator_session_id?: UuidNullableFilter<"sessions"> | string | null
    subscribed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    prev_transaction_page_params?: JsonNullableFilter<"sessions">
    impersonation_sessions?: XOR<Impersonation_sessionsNullableScalarRelationFilter, impersonation_sessionsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active_impersonator_session_id?: SortOrderInput | SortOrder
    subscribed_at?: SortOrderInput | SortOrder
    prev_transaction_page_params?: SortOrderInput | SortOrder
    impersonation_sessions?: impersonation_sessionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: UuidFilter<"sessions"> | string
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeFilter<"sessions"> | Date | string
    active_impersonator_session_id?: UuidNullableFilter<"sessions"> | string | null
    subscribed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    prev_transaction_page_params?: JsonNullableFilter<"sessions">
    impersonation_sessions?: XOR<Impersonation_sessionsNullableScalarRelationFilter, impersonation_sessionsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active_impersonator_session_id?: SortOrderInput | SortOrder
    subscribed_at?: SortOrderInput | SortOrder
    prev_transaction_page_params?: SortOrderInput | SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sessions"> | string
    user_id?: UuidWithAggregatesFilter<"sessions"> | string
    user_agent?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    active_impersonator_session_id?: UuidNullableWithAggregatesFilter<"sessions"> | string | null
    subscribed_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    prev_transaction_page_params?: JsonNullableWithAggregatesFilter<"sessions">
  }

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    id?: BigIntFilter<"settings"> | bigint | number
    var?: StringFilter<"settings"> | string
    value?: StringNullableFilter<"settings"> | string | null
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    var?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    var?: string
    AND?: settingsWhereInput | settingsWhereInput[]
    OR?: settingsWhereInput[]
    NOT?: settingsWhereInput | settingsWhereInput[]
    value?: StringNullableFilter<"settings"> | string | null
    created_at?: DateTimeFilter<"settings"> | Date | string
    updated_at?: DateTimeFilter<"settings"> | Date | string
  }, "id" | "var">

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    var?: SortOrder
    value?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _avg?: settingsAvgOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
    _sum?: settingsSumOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    OR?: settingsScalarWhereWithAggregatesInput[]
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"settings"> | bigint | number
    var?: StringWithAggregatesFilter<"settings"> | string
    value?: StringNullableWithAggregatesFilter<"settings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string
  }

  export type stock_exchangesWhereInput = {
    AND?: stock_exchangesWhereInput | stock_exchangesWhereInput[]
    OR?: stock_exchangesWhereInput[]
    NOT?: stock_exchangesWhereInput | stock_exchangesWhereInput[]
    id?: UuidFilter<"stock_exchanges"> | string
    name?: StringFilter<"stock_exchanges"> | string
    acronym?: StringNullableFilter<"stock_exchanges"> | string | null
    mic?: StringFilter<"stock_exchanges"> | string
    country?: StringFilter<"stock_exchanges"> | string
    country_code?: StringFilter<"stock_exchanges"> | string
    city?: StringNullableFilter<"stock_exchanges"> | string | null
    website?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_name?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_abbr?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_abbr_dst?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_code?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_symbol?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_name?: StringNullableFilter<"stock_exchanges"> | string | null
    created_at?: DateTimeFilter<"stock_exchanges"> | Date | string
    updated_at?: DateTimeFilter<"stock_exchanges"> | Date | string
  }

  export type stock_exchangesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    acronym?: SortOrderInput | SortOrder
    mic?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    city?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timezone_name?: SortOrderInput | SortOrder
    timezone_abbr?: SortOrderInput | SortOrder
    timezone_abbr_dst?: SortOrderInput | SortOrder
    currency_code?: SortOrderInput | SortOrder
    currency_symbol?: SortOrderInput | SortOrder
    currency_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stock_exchangesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: stock_exchangesWhereInput | stock_exchangesWhereInput[]
    OR?: stock_exchangesWhereInput[]
    NOT?: stock_exchangesWhereInput | stock_exchangesWhereInput[]
    name?: StringFilter<"stock_exchanges"> | string
    acronym?: StringNullableFilter<"stock_exchanges"> | string | null
    mic?: StringFilter<"stock_exchanges"> | string
    country?: StringFilter<"stock_exchanges"> | string
    country_code?: StringFilter<"stock_exchanges"> | string
    city?: StringNullableFilter<"stock_exchanges"> | string | null
    website?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_name?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_abbr?: StringNullableFilter<"stock_exchanges"> | string | null
    timezone_abbr_dst?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_code?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_symbol?: StringNullableFilter<"stock_exchanges"> | string | null
    currency_name?: StringNullableFilter<"stock_exchanges"> | string | null
    created_at?: DateTimeFilter<"stock_exchanges"> | Date | string
    updated_at?: DateTimeFilter<"stock_exchanges"> | Date | string
  }, "id">

  export type stock_exchangesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    acronym?: SortOrderInput | SortOrder
    mic?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    city?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    timezone_name?: SortOrderInput | SortOrder
    timezone_abbr?: SortOrderInput | SortOrder
    timezone_abbr_dst?: SortOrderInput | SortOrder
    currency_code?: SortOrderInput | SortOrder
    currency_symbol?: SortOrderInput | SortOrder
    currency_name?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: stock_exchangesCountOrderByAggregateInput
    _max?: stock_exchangesMaxOrderByAggregateInput
    _min?: stock_exchangesMinOrderByAggregateInput
  }

  export type stock_exchangesScalarWhereWithAggregatesInput = {
    AND?: stock_exchangesScalarWhereWithAggregatesInput | stock_exchangesScalarWhereWithAggregatesInput[]
    OR?: stock_exchangesScalarWhereWithAggregatesInput[]
    NOT?: stock_exchangesScalarWhereWithAggregatesInput | stock_exchangesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"stock_exchanges"> | string
    name?: StringWithAggregatesFilter<"stock_exchanges"> | string
    acronym?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    mic?: StringWithAggregatesFilter<"stock_exchanges"> | string
    country?: StringWithAggregatesFilter<"stock_exchanges"> | string
    country_code?: StringWithAggregatesFilter<"stock_exchanges"> | string
    city?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    website?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    timezone_name?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    timezone_abbr?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    timezone_abbr_dst?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    currency_code?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    currency_symbol?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    currency_name?: StringNullableWithAggregatesFilter<"stock_exchanges"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"stock_exchanges"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"stock_exchanges"> | Date | string
  }

  export type syncsWhereInput = {
    AND?: syncsWhereInput | syncsWhereInput[]
    OR?: syncsWhereInput[]
    NOT?: syncsWhereInput | syncsWhereInput[]
    id?: UuidFilter<"syncs"> | string
    syncable_type?: StringFilter<"syncs"> | string
    syncable_id?: UuidFilter<"syncs"> | string
    last_ran_at?: DateTimeNullableFilter<"syncs"> | Date | string | null
    start_date?: DateTimeNullableFilter<"syncs"> | Date | string | null
    status?: StringNullableFilter<"syncs"> | string | null
    error?: StringNullableFilter<"syncs"> | string | null
    data?: JsonNullableFilter<"syncs">
    created_at?: DateTimeFilter<"syncs"> | Date | string
    updated_at?: DateTimeFilter<"syncs"> | Date | string
    error_backtrace?: StringNullableListFilter<"syncs">
    parent_id?: UuidNullableFilter<"syncs"> | string | null
    syncs?: XOR<SyncsNullableScalarRelationFilter, syncsWhereInput> | null
    other_syncs?: SyncsListRelationFilter
  }

  export type syncsOrderByWithRelationInput = {
    id?: SortOrder
    syncable_type?: SortOrder
    syncable_id?: SortOrder
    last_ran_at?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    error_backtrace?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    syncs?: syncsOrderByWithRelationInput
    other_syncs?: syncsOrderByRelationAggregateInput
  }

  export type syncsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: syncsWhereInput | syncsWhereInput[]
    OR?: syncsWhereInput[]
    NOT?: syncsWhereInput | syncsWhereInput[]
    syncable_type?: StringFilter<"syncs"> | string
    syncable_id?: UuidFilter<"syncs"> | string
    last_ran_at?: DateTimeNullableFilter<"syncs"> | Date | string | null
    start_date?: DateTimeNullableFilter<"syncs"> | Date | string | null
    status?: StringNullableFilter<"syncs"> | string | null
    error?: StringNullableFilter<"syncs"> | string | null
    data?: JsonNullableFilter<"syncs">
    created_at?: DateTimeFilter<"syncs"> | Date | string
    updated_at?: DateTimeFilter<"syncs"> | Date | string
    error_backtrace?: StringNullableListFilter<"syncs">
    parent_id?: UuidNullableFilter<"syncs"> | string | null
    syncs?: XOR<SyncsNullableScalarRelationFilter, syncsWhereInput> | null
    other_syncs?: SyncsListRelationFilter
  }, "id">

  export type syncsOrderByWithAggregationInput = {
    id?: SortOrder
    syncable_type?: SortOrder
    syncable_id?: SortOrder
    last_ran_at?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    error_backtrace?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    _count?: syncsCountOrderByAggregateInput
    _max?: syncsMaxOrderByAggregateInput
    _min?: syncsMinOrderByAggregateInput
  }

  export type syncsScalarWhereWithAggregatesInput = {
    AND?: syncsScalarWhereWithAggregatesInput | syncsScalarWhereWithAggregatesInput[]
    OR?: syncsScalarWhereWithAggregatesInput[]
    NOT?: syncsScalarWhereWithAggregatesInput | syncsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"syncs"> | string
    syncable_type?: StringWithAggregatesFilter<"syncs"> | string
    syncable_id?: UuidWithAggregatesFilter<"syncs"> | string
    last_ran_at?: DateTimeNullableWithAggregatesFilter<"syncs"> | Date | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"syncs"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"syncs"> | string | null
    error?: StringNullableWithAggregatesFilter<"syncs"> | string | null
    data?: JsonNullableWithAggregatesFilter<"syncs">
    created_at?: DateTimeWithAggregatesFilter<"syncs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"syncs"> | Date | string
    error_backtrace?: StringNullableListFilter<"syncs">
    parent_id?: UuidNullableWithAggregatesFilter<"syncs"> | string | null
  }

  export type taggingsWhereInput = {
    AND?: taggingsWhereInput | taggingsWhereInput[]
    OR?: taggingsWhereInput[]
    NOT?: taggingsWhereInput | taggingsWhereInput[]
    id?: UuidFilter<"taggings"> | string
    tag_id?: UuidFilter<"taggings"> | string
    taggable_type?: StringNullableFilter<"taggings"> | string | null
    taggable_id?: UuidNullableFilter<"taggings"> | string | null
    created_at?: DateTimeFilter<"taggings"> | Date | string
    updated_at?: DateTimeFilter<"taggings"> | Date | string
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }

  export type taggingsOrderByWithRelationInput = {
    id?: SortOrder
    tag_id?: SortOrder
    taggable_type?: SortOrderInput | SortOrder
    taggable_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tags?: tagsOrderByWithRelationInput
  }

  export type taggingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: taggingsWhereInput | taggingsWhereInput[]
    OR?: taggingsWhereInput[]
    NOT?: taggingsWhereInput | taggingsWhereInput[]
    tag_id?: UuidFilter<"taggings"> | string
    taggable_type?: StringNullableFilter<"taggings"> | string | null
    taggable_id?: UuidNullableFilter<"taggings"> | string | null
    created_at?: DateTimeFilter<"taggings"> | Date | string
    updated_at?: DateTimeFilter<"taggings"> | Date | string
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }, "id">

  export type taggingsOrderByWithAggregationInput = {
    id?: SortOrder
    tag_id?: SortOrder
    taggable_type?: SortOrderInput | SortOrder
    taggable_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: taggingsCountOrderByAggregateInput
    _max?: taggingsMaxOrderByAggregateInput
    _min?: taggingsMinOrderByAggregateInput
  }

  export type taggingsScalarWhereWithAggregatesInput = {
    AND?: taggingsScalarWhereWithAggregatesInput | taggingsScalarWhereWithAggregatesInput[]
    OR?: taggingsScalarWhereWithAggregatesInput[]
    NOT?: taggingsScalarWhereWithAggregatesInput | taggingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"taggings"> | string
    tag_id?: UuidWithAggregatesFilter<"taggings"> | string
    taggable_type?: StringNullableWithAggregatesFilter<"taggings"> | string | null
    taggable_id?: UuidNullableWithAggregatesFilter<"taggings"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"taggings"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"taggings"> | Date | string
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    id?: UuidFilter<"tags"> | string
    name?: StringNullableFilter<"tags"> | string | null
    color?: StringFilter<"tags"> | string
    family_id?: UuidFilter<"tags"> | string
    created_at?: DateTimeFilter<"tags"> | Date | string
    updated_at?: DateTimeFilter<"tags"> | Date | string
    taggings?: TaggingsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type tagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    taggings?: taggingsOrderByRelationAggregateInput
    families?: familiesOrderByWithRelationInput
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    name?: StringNullableFilter<"tags"> | string | null
    color?: StringFilter<"tags"> | string
    family_id?: UuidFilter<"tags"> | string
    created_at?: DateTimeFilter<"tags"> | Date | string
    updated_at?: DateTimeFilter<"tags"> | Date | string
    taggings?: TaggingsListRelationFilter
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id">

  export type tagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tagsCountOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"tags"> | string
    name?: StringNullableWithAggregatesFilter<"tags"> | string | null
    color?: StringWithAggregatesFilter<"tags"> | string
    family_id?: UuidWithAggregatesFilter<"tags"> | string
    created_at?: DateTimeWithAggregatesFilter<"tags"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tags"> | Date | string
  }

  export type tool_callsWhereInput = {
    AND?: tool_callsWhereInput | tool_callsWhereInput[]
    OR?: tool_callsWhereInput[]
    NOT?: tool_callsWhereInput | tool_callsWhereInput[]
    id?: UuidFilter<"tool_calls"> | string
    message_id?: UuidFilter<"tool_calls"> | string
    provider_id?: StringFilter<"tool_calls"> | string
    provider_call_id?: StringNullableFilter<"tool_calls"> | string | null
    type?: StringFilter<"tool_calls"> | string
    function_name?: StringNullableFilter<"tool_calls"> | string | null
    function_arguments?: JsonNullableFilter<"tool_calls">
    function_result?: JsonNullableFilter<"tool_calls">
    created_at?: DateTimeFilter<"tool_calls"> | Date | string
    updated_at?: DateTimeFilter<"tool_calls"> | Date | string
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }

  export type tool_callsOrderByWithRelationInput = {
    id?: SortOrder
    message_id?: SortOrder
    provider_id?: SortOrder
    provider_call_id?: SortOrderInput | SortOrder
    type?: SortOrder
    function_name?: SortOrderInput | SortOrder
    function_arguments?: SortOrderInput | SortOrder
    function_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    messages?: messagesOrderByWithRelationInput
  }

  export type tool_callsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tool_callsWhereInput | tool_callsWhereInput[]
    OR?: tool_callsWhereInput[]
    NOT?: tool_callsWhereInput | tool_callsWhereInput[]
    message_id?: UuidFilter<"tool_calls"> | string
    provider_id?: StringFilter<"tool_calls"> | string
    provider_call_id?: StringNullableFilter<"tool_calls"> | string | null
    type?: StringFilter<"tool_calls"> | string
    function_name?: StringNullableFilter<"tool_calls"> | string | null
    function_arguments?: JsonNullableFilter<"tool_calls">
    function_result?: JsonNullableFilter<"tool_calls">
    created_at?: DateTimeFilter<"tool_calls"> | Date | string
    updated_at?: DateTimeFilter<"tool_calls"> | Date | string
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }, "id">

  export type tool_callsOrderByWithAggregationInput = {
    id?: SortOrder
    message_id?: SortOrder
    provider_id?: SortOrder
    provider_call_id?: SortOrderInput | SortOrder
    type?: SortOrder
    function_name?: SortOrderInput | SortOrder
    function_arguments?: SortOrderInput | SortOrder
    function_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tool_callsCountOrderByAggregateInput
    _max?: tool_callsMaxOrderByAggregateInput
    _min?: tool_callsMinOrderByAggregateInput
  }

  export type tool_callsScalarWhereWithAggregatesInput = {
    AND?: tool_callsScalarWhereWithAggregatesInput | tool_callsScalarWhereWithAggregatesInput[]
    OR?: tool_callsScalarWhereWithAggregatesInput[]
    NOT?: tool_callsScalarWhereWithAggregatesInput | tool_callsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"tool_calls"> | string
    message_id?: UuidWithAggregatesFilter<"tool_calls"> | string
    provider_id?: StringWithAggregatesFilter<"tool_calls"> | string
    provider_call_id?: StringNullableWithAggregatesFilter<"tool_calls"> | string | null
    type?: StringWithAggregatesFilter<"tool_calls"> | string
    function_name?: StringNullableWithAggregatesFilter<"tool_calls"> | string | null
    function_arguments?: JsonNullableWithAggregatesFilter<"tool_calls">
    function_result?: JsonNullableWithAggregatesFilter<"tool_calls">
    created_at?: DateTimeWithAggregatesFilter<"tool_calls"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tool_calls"> | Date | string
  }

  export type tradesWhereInput = {
    AND?: tradesWhereInput | tradesWhereInput[]
    OR?: tradesWhereInput[]
    NOT?: tradesWhereInput | tradesWhereInput[]
    id?: UuidFilter<"trades"> | string
    security_id?: UuidFilter<"trades"> | string
    qty?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    currency?: StringNullableFilter<"trades"> | string | null
    locked_attributes?: JsonNullableFilter<"trades">
    securities?: XOR<SecuritiesScalarRelationFilter, securitiesWhereInput>
  }

  export type tradesOrderByWithRelationInput = {
    id?: SortOrder
    security_id?: SortOrder
    qty?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    securities?: securitiesOrderByWithRelationInput
  }

  export type tradesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: tradesWhereInput | tradesWhereInput[]
    OR?: tradesWhereInput[]
    NOT?: tradesWhereInput | tradesWhereInput[]
    security_id?: UuidFilter<"trades"> | string
    qty?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    currency?: StringNullableFilter<"trades"> | string | null
    locked_attributes?: JsonNullableFilter<"trades">
    securities?: XOR<SecuritiesScalarRelationFilter, securitiesWhereInput>
  }, "id">

  export type tradesOrderByWithAggregationInput = {
    id?: SortOrder
    security_id?: SortOrder
    qty?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: tradesCountOrderByAggregateInput
    _avg?: tradesAvgOrderByAggregateInput
    _max?: tradesMaxOrderByAggregateInput
    _min?: tradesMinOrderByAggregateInput
    _sum?: tradesSumOrderByAggregateInput
  }

  export type tradesScalarWhereWithAggregatesInput = {
    AND?: tradesScalarWhereWithAggregatesInput | tradesScalarWhereWithAggregatesInput[]
    OR?: tradesScalarWhereWithAggregatesInput[]
    NOT?: tradesScalarWhereWithAggregatesInput | tradesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"trades"> | string
    security_id?: UuidWithAggregatesFilter<"trades"> | string
    qty?: DecimalNullableWithAggregatesFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableWithAggregatesFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"trades"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"trades"> | Date | string
    currency?: StringNullableWithAggregatesFilter<"trades"> | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"trades">
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    id?: UuidFilter<"transactions"> | string
    created_at?: DateTimeFilter<"transactions"> | Date | string
    updated_at?: DateTimeFilter<"transactions"> | Date | string
    category_id?: UuidNullableFilter<"transactions"> | string | null
    merchant_id?: UuidNullableFilter<"transactions"> | string | null
    locked_attributes?: JsonNullableFilter<"transactions">
    plaid_category?: StringNullableFilter<"transactions"> | string | null
    plaid_category_detailed?: StringNullableFilter<"transactions"> | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: Rejected_transfersListRelationFilter
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: Rejected_transfersListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    merchants?: XOR<MerchantsNullableScalarRelationFilter, merchantsWhereInput> | null
    transfers_transfers_outflow_transaction_idTotransactions?: TransfersListRelationFilter
    transfers_transfers_inflow_transaction_idTotransactions?: TransfersListRelationFilter
  }

  export type transactionsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrderInput | SortOrder
    merchant_id?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    plaid_category?: SortOrderInput | SortOrder
    plaid_category_detailed?: SortOrderInput | SortOrder
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersOrderByRelationAggregateInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    merchants?: merchantsOrderByWithRelationInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersOrderByRelationAggregateInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersOrderByRelationAggregateInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    created_at?: DateTimeFilter<"transactions"> | Date | string
    updated_at?: DateTimeFilter<"transactions"> | Date | string
    category_id?: UuidNullableFilter<"transactions"> | string | null
    merchant_id?: UuidNullableFilter<"transactions"> | string | null
    locked_attributes?: JsonNullableFilter<"transactions">
    plaid_category?: StringNullableFilter<"transactions"> | string | null
    plaid_category_detailed?: StringNullableFilter<"transactions"> | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: Rejected_transfersListRelationFilter
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: Rejected_transfersListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    merchants?: XOR<MerchantsNullableScalarRelationFilter, merchantsWhereInput> | null
    transfers_transfers_outflow_transaction_idTotransactions?: TransfersListRelationFilter
    transfers_transfers_inflow_transaction_idTotransactions?: TransfersListRelationFilter
  }, "id">

  export type transactionsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrderInput | SortOrder
    merchant_id?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    plaid_category?: SortOrderInput | SortOrder
    plaid_category_detailed?: SortOrderInput | SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transactions"> | string
    created_at?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
    category_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    merchant_id?: UuidNullableWithAggregatesFilter<"transactions"> | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"transactions">
    plaid_category?: StringNullableWithAggregatesFilter<"transactions"> | string | null
    plaid_category_detailed?: StringNullableWithAggregatesFilter<"transactions"> | string | null
  }

  export type transfersWhereInput = {
    AND?: transfersWhereInput | transfersWhereInput[]
    OR?: transfersWhereInput[]
    NOT?: transfersWhereInput | transfersWhereInput[]
    id?: UuidFilter<"transfers"> | string
    inflow_transaction_id?: UuidFilter<"transfers"> | string
    outflow_transaction_id?: UuidFilter<"transfers"> | string
    status?: StringFilter<"transfers"> | string
    notes?: StringNullableFilter<"transfers"> | string | null
    created_at?: DateTimeFilter<"transfers"> | Date | string
    updated_at?: DateTimeFilter<"transfers"> | Date | string
    transactions_transfers_outflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
    transactions_transfers_inflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
  }

  export type transfersOrderByWithRelationInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transactions_transfers_outflow_transaction_idTotransactions?: transactionsOrderByWithRelationInput
    transactions_transfers_inflow_transaction_idTotransactions?: transactionsOrderByWithRelationInput
  }

  export type transfersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inflow_transaction_id_outflow_transaction_id?: transfersInflow_transaction_idOutflow_transaction_idCompoundUniqueInput
    AND?: transfersWhereInput | transfersWhereInput[]
    OR?: transfersWhereInput[]
    NOT?: transfersWhereInput | transfersWhereInput[]
    inflow_transaction_id?: UuidFilter<"transfers"> | string
    outflow_transaction_id?: UuidFilter<"transfers"> | string
    status?: StringFilter<"transfers"> | string
    notes?: StringNullableFilter<"transfers"> | string | null
    created_at?: DateTimeFilter<"transfers"> | Date | string
    updated_at?: DateTimeFilter<"transfers"> | Date | string
    transactions_transfers_outflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
    transactions_transfers_inflow_transaction_idTotransactions?: XOR<TransactionsScalarRelationFilter, transactionsWhereInput>
  }, "id" | "inflow_transaction_id_outflow_transaction_id">

  export type transfersOrderByWithAggregationInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: transfersCountOrderByAggregateInput
    _max?: transfersMaxOrderByAggregateInput
    _min?: transfersMinOrderByAggregateInput
  }

  export type transfersScalarWhereWithAggregatesInput = {
    AND?: transfersScalarWhereWithAggregatesInput | transfersScalarWhereWithAggregatesInput[]
    OR?: transfersScalarWhereWithAggregatesInput[]
    NOT?: transfersScalarWhereWithAggregatesInput | transfersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"transfers"> | string
    inflow_transaction_id?: UuidWithAggregatesFilter<"transfers"> | string
    outflow_transaction_id?: UuidWithAggregatesFilter<"transfers"> | string
    status?: StringWithAggregatesFilter<"transfers"> | string
    notes?: StringNullableWithAggregatesFilter<"transfers"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"transfers"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"transfers"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    family_id?: UuidFilter<"users"> | string
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    password_digest?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role?: StringFilter<"users"> | string
    active?: BoolFilter<"users"> | boolean
    onboarded_at?: DateTimeNullableFilter<"users"> | Date | string | null
    unconfirmed_email?: StringNullableFilter<"users"> | string | null
    otp_secret?: StringNullableFilter<"users"> | string | null
    otp_required?: BoolFilter<"users"> | boolean
    otp_backup_codes?: StringNullableListFilter<"users">
    show_sidebar?: BoolNullableFilter<"users"> | boolean | null
    default_period?: StringFilter<"users"> | string
    last_viewed_chat_id?: UuidNullableFilter<"users"> | string | null
    show_ai_sidebar?: BoolNullableFilter<"users"> | boolean | null
    ai_enabled?: BoolFilter<"users"> | boolean
    theme?: StringNullableFilter<"users"> | string | null
    rule_prompts_disabled?: BoolNullableFilter<"users"> | boolean | null
    rule_prompt_dismissed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    goals?: StringNullableListFilter<"users">
    set_onboarding_preferences_at?: DateTimeNullableFilter<"users"> | Date | string | null
    set_onboarding_goals_at?: DateTimeNullableFilter<"users"> | Date | string | null
    chats_chats_user_idTousers?: ChatsListRelationFilter
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: Impersonation_sessionsListRelationFilter
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: Impersonation_sessionsListRelationFilter
    invitations?: InvitationsListRelationFilter
    sessions?: SessionsListRelationFilter
    chats_users_last_viewed_chat_idTochats?: XOR<ChatsNullableScalarRelationFilter, chatsWhereInput> | null
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    family_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_digest?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    active?: SortOrder
    onboarded_at?: SortOrderInput | SortOrder
    unconfirmed_email?: SortOrderInput | SortOrder
    otp_secret?: SortOrderInput | SortOrder
    otp_required?: SortOrder
    otp_backup_codes?: SortOrder
    show_sidebar?: SortOrderInput | SortOrder
    default_period?: SortOrder
    last_viewed_chat_id?: SortOrderInput | SortOrder
    show_ai_sidebar?: SortOrderInput | SortOrder
    ai_enabled?: SortOrder
    theme?: SortOrderInput | SortOrder
    rule_prompts_disabled?: SortOrderInput | SortOrder
    rule_prompt_dismissed_at?: SortOrderInput | SortOrder
    goals?: SortOrder
    set_onboarding_preferences_at?: SortOrderInput | SortOrder
    set_onboarding_goals_at?: SortOrderInput | SortOrder
    chats_chats_user_idTousers?: chatsOrderByRelationAggregateInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsOrderByRelationAggregateInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsOrderByRelationAggregateInput
    invitations?: invitationsOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    chats_users_last_viewed_chat_idTochats?: chatsOrderByWithRelationInput
    families?: familiesOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    family_id?: UuidFilter<"users"> | string
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    password_digest?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role?: StringFilter<"users"> | string
    active?: BoolFilter<"users"> | boolean
    onboarded_at?: DateTimeNullableFilter<"users"> | Date | string | null
    unconfirmed_email?: StringNullableFilter<"users"> | string | null
    otp_secret?: StringNullableFilter<"users"> | string | null
    otp_required?: BoolFilter<"users"> | boolean
    otp_backup_codes?: StringNullableListFilter<"users">
    show_sidebar?: BoolNullableFilter<"users"> | boolean | null
    default_period?: StringFilter<"users"> | string
    last_viewed_chat_id?: UuidNullableFilter<"users"> | string | null
    show_ai_sidebar?: BoolNullableFilter<"users"> | boolean | null
    ai_enabled?: BoolFilter<"users"> | boolean
    theme?: StringNullableFilter<"users"> | string | null
    rule_prompts_disabled?: BoolNullableFilter<"users"> | boolean | null
    rule_prompt_dismissed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    goals?: StringNullableListFilter<"users">
    set_onboarding_preferences_at?: DateTimeNullableFilter<"users"> | Date | string | null
    set_onboarding_goals_at?: DateTimeNullableFilter<"users"> | Date | string | null
    chats_chats_user_idTousers?: ChatsListRelationFilter
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: Impersonation_sessionsListRelationFilter
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: Impersonation_sessionsListRelationFilter
    invitations?: InvitationsListRelationFilter
    sessions?: SessionsListRelationFilter
    chats_users_last_viewed_chat_idTochats?: XOR<ChatsNullableScalarRelationFilter, chatsWhereInput> | null
    families?: XOR<FamiliesScalarRelationFilter, familiesWhereInput>
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    family_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password_digest?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    active?: SortOrder
    onboarded_at?: SortOrderInput | SortOrder
    unconfirmed_email?: SortOrderInput | SortOrder
    otp_secret?: SortOrderInput | SortOrder
    otp_required?: SortOrder
    otp_backup_codes?: SortOrder
    show_sidebar?: SortOrderInput | SortOrder
    default_period?: SortOrder
    last_viewed_chat_id?: SortOrderInput | SortOrder
    show_ai_sidebar?: SortOrderInput | SortOrder
    ai_enabled?: SortOrder
    theme?: SortOrderInput | SortOrder
    rule_prompts_disabled?: SortOrderInput | SortOrder
    rule_prompt_dismissed_at?: SortOrderInput | SortOrder
    goals?: SortOrder
    set_onboarding_preferences_at?: SortOrderInput | SortOrder
    set_onboarding_goals_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    family_id?: UuidWithAggregatesFilter<"users"> | string
    first_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    password_digest?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    role?: StringWithAggregatesFilter<"users"> | string
    active?: BoolWithAggregatesFilter<"users"> | boolean
    onboarded_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    unconfirmed_email?: StringNullableWithAggregatesFilter<"users"> | string | null
    otp_secret?: StringNullableWithAggregatesFilter<"users"> | string | null
    otp_required?: BoolWithAggregatesFilter<"users"> | boolean
    otp_backup_codes?: StringNullableListFilter<"users">
    show_sidebar?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    default_period?: StringWithAggregatesFilter<"users"> | string
    last_viewed_chat_id?: UuidNullableWithAggregatesFilter<"users"> | string | null
    show_ai_sidebar?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    ai_enabled?: BoolWithAggregatesFilter<"users"> | boolean
    theme?: StringNullableWithAggregatesFilter<"users"> | string | null
    rule_prompts_disabled?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    rule_prompt_dismissed_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    goals?: StringNullableListFilter<"users">
    set_onboarding_preferences_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    set_onboarding_goals_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type valuationsWhereInput = {
    AND?: valuationsWhereInput | valuationsWhereInput[]
    OR?: valuationsWhereInput[]
    NOT?: valuationsWhereInput | valuationsWhereInput[]
    id?: UuidFilter<"valuations"> | string
    created_at?: DateTimeFilter<"valuations"> | Date | string
    updated_at?: DateTimeFilter<"valuations"> | Date | string
    locked_attributes?: JsonNullableFilter<"valuations">
  }

  export type valuationsOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type valuationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: valuationsWhereInput | valuationsWhereInput[]
    OR?: valuationsWhereInput[]
    NOT?: valuationsWhereInput | valuationsWhereInput[]
    created_at?: DateTimeFilter<"valuations"> | Date | string
    updated_at?: DateTimeFilter<"valuations"> | Date | string
    locked_attributes?: JsonNullableFilter<"valuations">
  }, "id">

  export type valuationsOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: valuationsCountOrderByAggregateInput
    _max?: valuationsMaxOrderByAggregateInput
    _min?: valuationsMinOrderByAggregateInput
  }

  export type valuationsScalarWhereWithAggregatesInput = {
    AND?: valuationsScalarWhereWithAggregatesInput | valuationsScalarWhereWithAggregatesInput[]
    OR?: valuationsScalarWhereWithAggregatesInput[]
    NOT?: valuationsScalarWhereWithAggregatesInput | valuationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"valuations"> | string
    created_at?: DateTimeWithAggregatesFilter<"valuations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"valuations"> | Date | string
    locked_attributes?: JsonNullableWithAggregatesFilter<"valuations">
  }

  export type vehiclesWhereInput = {
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    id?: UuidFilter<"vehicles"> | string
    created_at?: DateTimeFilter<"vehicles"> | Date | string
    updated_at?: DateTimeFilter<"vehicles"> | Date | string
    year?: IntNullableFilter<"vehicles"> | number | null
    mileage_value?: IntNullableFilter<"vehicles"> | number | null
    mileage_unit?: StringNullableFilter<"vehicles"> | string | null
    make?: StringNullableFilter<"vehicles"> | string | null
    model?: StringNullableFilter<"vehicles"> | string | null
    locked_attributes?: JsonNullableFilter<"vehicles">
  }

  export type vehiclesOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year?: SortOrderInput | SortOrder
    mileage_value?: SortOrderInput | SortOrder
    mileage_unit?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
  }

  export type vehiclesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehiclesWhereInput | vehiclesWhereInput[]
    OR?: vehiclesWhereInput[]
    NOT?: vehiclesWhereInput | vehiclesWhereInput[]
    created_at?: DateTimeFilter<"vehicles"> | Date | string
    updated_at?: DateTimeFilter<"vehicles"> | Date | string
    year?: IntNullableFilter<"vehicles"> | number | null
    mileage_value?: IntNullableFilter<"vehicles"> | number | null
    mileage_unit?: StringNullableFilter<"vehicles"> | string | null
    make?: StringNullableFilter<"vehicles"> | string | null
    model?: StringNullableFilter<"vehicles"> | string | null
    locked_attributes?: JsonNullableFilter<"vehicles">
  }, "id">

  export type vehiclesOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year?: SortOrderInput | SortOrder
    mileage_value?: SortOrderInput | SortOrder
    mileage_unit?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    locked_attributes?: SortOrderInput | SortOrder
    _count?: vehiclesCountOrderByAggregateInput
    _avg?: vehiclesAvgOrderByAggregateInput
    _max?: vehiclesMaxOrderByAggregateInput
    _min?: vehiclesMinOrderByAggregateInput
    _sum?: vehiclesSumOrderByAggregateInput
  }

  export type vehiclesScalarWhereWithAggregatesInput = {
    AND?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    OR?: vehiclesScalarWhereWithAggregatesInput[]
    NOT?: vehiclesScalarWhereWithAggregatesInput | vehiclesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"vehicles"> | string
    created_at?: DateTimeWithAggregatesFilter<"vehicles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"vehicles"> | Date | string
    year?: IntNullableWithAggregatesFilter<"vehicles"> | number | null
    mileage_value?: IntNullableWithAggregatesFilter<"vehicles"> | number | null
    mileage_unit?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    make?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    model?: StringNullableWithAggregatesFilter<"vehicles"> | string | null
    locked_attributes?: JsonNullableWithAggregatesFilter<"vehicles">
  }

  export type accountsCreateInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    imports?: importsCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    imports?: importsUpdateOneWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type accountsCreateManyInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type active_storage_attachmentsCreateInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    created_at: Date | string
    active_storage_blobs: active_storage_blobsCreateNestedOneWithoutActive_storage_attachmentsInput
  }

  export type active_storage_attachmentsUncheckedCreateInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    blob_id: string
    created_at: Date | string
  }

  export type active_storage_attachmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_blobs?: active_storage_blobsUpdateOneRequiredWithoutActive_storage_attachmentsNestedInput
  }

  export type active_storage_attachmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    blob_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_attachmentsCreateManyInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    blob_id: string
    created_at: Date | string
  }

  export type active_storage_attachmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_attachmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    blob_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_blobsCreateInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_attachments?: active_storage_attachmentsCreateNestedManyWithoutActive_storage_blobsInput
    active_storage_variant_records?: active_storage_variant_recordsCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsUncheckedCreateInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_attachments?: active_storage_attachmentsUncheckedCreateNestedManyWithoutActive_storage_blobsInput
    active_storage_variant_records?: active_storage_variant_recordsUncheckedCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_attachments?: active_storage_attachmentsUpdateManyWithoutActive_storage_blobsNestedInput
    active_storage_variant_records?: active_storage_variant_recordsUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type active_storage_blobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_attachments?: active_storage_attachmentsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput
    active_storage_variant_records?: active_storage_variant_recordsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type active_storage_blobsCreateManyInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
  }

  export type active_storage_blobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_blobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_variant_recordsCreateInput = {
    id?: string
    variation_digest: string
    active_storage_blobs: active_storage_blobsCreateNestedOneWithoutActive_storage_variant_recordsInput
  }

  export type active_storage_variant_recordsUncheckedCreateInput = {
    id?: string
    blob_id: string
    variation_digest: string
  }

  export type active_storage_variant_recordsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
    active_storage_blobs?: active_storage_blobsUpdateOneRequiredWithoutActive_storage_variant_recordsNestedInput
  }

  export type active_storage_variant_recordsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob_id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type active_storage_variant_recordsCreateManyInput = {
    id?: string
    blob_id: string
    variation_digest: string
  }

  export type active_storage_variant_recordsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type active_storage_variant_recordsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blob_id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type addressesCreateInput = {
    id?: string
    addressable_type?: string | null
    addressable_id?: string | null
    line1?: string | null
    line2?: string | null
    county?: string | null
    locality?: string | null
    region?: string | null
    country?: string | null
    postal_code?: number | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type addressesUncheckedCreateInput = {
    id?: string
    addressable_type?: string | null
    addressable_id?: string | null
    line1?: string | null
    line2?: string | null
    county?: string | null
    locality?: string | null
    region?: string | null
    country?: string | null
    postal_code?: number | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type addressesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressable_type?: NullableStringFieldUpdateOperationsInput | string | null
    addressable_id?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: NullableStringFieldUpdateOperationsInput | string | null
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressable_type?: NullableStringFieldUpdateOperationsInput | string | null
    addressable_id?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: NullableStringFieldUpdateOperationsInput | string | null
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressesCreateManyInput = {
    id?: string
    addressable_type?: string | null
    addressable_id?: string | null
    line1?: string | null
    line2?: string | null
    county?: string | null
    locality?: string | null
    region?: string | null
    country?: string | null
    postal_code?: number | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type addressesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressable_type?: NullableStringFieldUpdateOperationsInput | string | null
    addressable_id?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: NullableStringFieldUpdateOperationsInput | string | null
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    addressable_type?: NullableStringFieldUpdateOperationsInput | string | null
    addressable_id?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: NullableStringFieldUpdateOperationsInput | string | null
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    county?: NullableStringFieldUpdateOperationsInput | string | null
    locality?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ar_internal_metadataCreateInput = {
    key: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type ar_internal_metadataUncheckedCreateInput = {
    key: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type ar_internal_metadataUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ar_internal_metadataUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ar_internal_metadataCreateManyInput = {
    key: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type ar_internal_metadataUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ar_internal_metadataUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balancesCreateInput = {
    id?: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    accounts: accountsCreateNestedOneWithoutBalancesInput
  }

  export type balancesUncheckedCreateInput = {
    id?: string
    account_id: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    accounts?: accountsUpdateOneRequiredWithoutBalancesNestedInput
  }

  export type balancesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type balancesCreateManyInput = {
    id?: string
    account_id: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type budget_categoriesCreateInput = {
    id?: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    categories: categoriesCreateNestedOneWithoutBudget_categoriesInput
    budgets: budgetsCreateNestedOneWithoutBudget_categoriesInput
  }

  export type budget_categoriesUncheckedCreateInput = {
    id?: string
    budget_id: string
    category_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budget_categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneRequiredWithoutBudget_categoriesNestedInput
    budgets?: budgetsUpdateOneRequiredWithoutBudget_categoriesNestedInput
  }

  export type budget_categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesCreateManyInput = {
    id?: string
    budget_id: string
    category_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budget_categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budgetsCreateInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
    budget_categories?: budget_categoriesCreateNestedManyWithoutBudgetsInput
    families: familiesCreateNestedOneWithoutBudgetsInput
  }

  export type budgetsUncheckedCreateInput = {
    id?: string
    family_id: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
    budget_categories?: budget_categoriesUncheckedCreateNestedManyWithoutBudgetsInput
  }

  export type budgetsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_categories?: budget_categoriesUpdateManyWithoutBudgetsNestedInput
    families?: familiesUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type budgetsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_categories?: budget_categoriesUncheckedUpdateManyWithoutBudgetsNestedInput
  }

  export type budgetsCreateManyInput = {
    id?: string
    family_id: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budgetsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budgetsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriesCreateInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesCreateNestedManyWithoutCategoriesInput
    families: familiesCreateNestedOneWithoutCategoriesInput
    transactions?: transactionsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: string
    name: string
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUpdateManyWithoutCategoriesNestedInput
    families?: familiesUpdateOneRequiredWithoutCategoriesNestedInput
    transactions?: transactionsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: string
    name: string
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
  }

  export type categoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
  }

  export type chatsCreateInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    users_chats_user_idTousers: usersCreateNestedOneWithoutChats_chats_user_idTousersInput
    messages?: messagesCreateNestedManyWithoutChatsInput
    users_users_last_viewed_chat_idTochats?: usersCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsUncheckedCreateInput = {
    id?: string
    user_id: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
    users_users_last_viewed_chat_idTochats?: usersUncheckedCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_chats_user_idTousers?: usersUpdateOneRequiredWithoutChats_chats_user_idTousersNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
    users_users_last_viewed_chat_idTochats?: usersUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type chatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
    users_users_last_viewed_chat_idTochats?: usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type chatsCreateManyInput = {
    id?: string
    user_id: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type chatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type credit_cardsCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    available_credit?: Decimal | DecimalJsLike | number | string | null
    minimum_payment?: Decimal | DecimalJsLike | number | string | null
    apr?: Decimal | DecimalJsLike | number | string | null
    expiration_date?: Date | string | null
    annual_fee?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    available_credit?: Decimal | DecimalJsLike | number | string | null
    minimum_payment?: Decimal | DecimalJsLike | number | string | null
    apr?: Decimal | DecimalJsLike | number | string | null
    expiration_date?: Date | string | null
    annual_fee?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_credit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    apr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annual_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_credit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    apr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annual_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    available_credit?: Decimal | DecimalJsLike | number | string | null
    minimum_payment?: Decimal | DecimalJsLike | number | string | null
    apr?: Decimal | DecimalJsLike | number | string | null
    expiration_date?: Date | string | null
    annual_fee?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_credit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    apr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annual_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type credit_cardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_credit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minimum_payment?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    apr?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiration_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    annual_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type cryptosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type data_enrichmentsCreateInput = {
    id?: string
    enrichable_type: string
    enrichable_id: string
    source?: string | null
    attribute_name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type data_enrichmentsUncheckedCreateInput = {
    id?: string
    enrichable_type: string
    enrichable_id: string
    source?: string | null
    attribute_name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type data_enrichmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrichable_type?: StringFieldUpdateOperationsInput | string
    enrichable_id?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type data_enrichmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrichable_type?: StringFieldUpdateOperationsInput | string
    enrichable_id?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type data_enrichmentsCreateManyInput = {
    id?: string
    enrichable_type: string
    enrichable_id: string
    source?: string | null
    attribute_name?: string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type data_enrichmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrichable_type?: StringFieldUpdateOperationsInput | string
    enrichable_id?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type data_enrichmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrichable_type?: StringFieldUpdateOperationsInput | string
    enrichable_id?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    attribute_name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type depositoriesCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type depositoriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesCreateInput = {
    id?: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    accounts: accountsCreateNestedOneWithoutEntriesInput
    imports?: importsCreateNestedOneWithoutEntriesInput
  }

  export type entriesUncheckedCreateInput = {
    id?: string
    account_id: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    import_id?: string | null
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    accounts?: accountsUpdateOneRequiredWithoutEntriesNestedInput
    imports?: importsUpdateOneWithoutEntriesNestedInput
  }

  export type entriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesCreateManyInput = {
    id?: string
    account_id: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    import_id?: string | null
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type exchange_ratesCreateInput = {
    id?: string
    from_currency: string
    to_currency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at: Date | string
    updated_at: Date | string
  }

  export type exchange_ratesUncheckedCreateInput = {
    id?: string
    from_currency: string
    to_currency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at: Date | string
    updated_at: Date | string
  }

  export type exchange_ratesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_ratesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_ratesCreateManyInput = {
    id?: string
    from_currency: string
    to_currency: string
    rate: Decimal | DecimalJsLike | number | string
    date: Date | string
    created_at: Date | string
    updated_at: Date | string
  }

  export type exchange_ratesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchange_ratesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    from_currency?: StringFieldUpdateOperationsInput | string
    to_currency?: StringFieldUpdateOperationsInput | string
    rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type familiesCreateInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesCreateManyInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
  }

  export type familiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type familiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type holdingsCreateInput = {
    id?: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    securities: securitiesCreateNestedOneWithoutHoldingsInput
    accounts: accountsCreateNestedOneWithoutHoldingsInput
  }

  export type holdingsUncheckedCreateInput = {
    id?: string
    account_id: string
    security_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type holdingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    securities?: securitiesUpdateOneRequiredWithoutHoldingsNestedInput
    accounts?: accountsUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type holdingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type holdingsCreateManyInput = {
    id?: string
    account_id: string
    security_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type holdingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type holdingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_session_logsCreateInput = {
    id?: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
    impersonation_sessions: impersonation_sessionsCreateNestedOneWithoutImpersonation_session_logsInput
  }

  export type impersonation_session_logsUncheckedCreateInput = {
    id?: string
    impersonation_session_id: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_session_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_sessions?: impersonation_sessionsUpdateOneRequiredWithoutImpersonation_session_logsNestedInput
  }

  export type impersonation_session_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonation_session_id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_session_logsCreateManyInput = {
    id?: string
    impersonation_session_id: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_session_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_session_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonation_session_id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_sessionsCreateInput = {
    id?: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsCreateNestedManyWithoutImpersonation_sessionsInput
    users_impersonation_sessions_impersonator_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    users_impersonation_sessions_impersonated_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    sessions?: sessionsCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsUncheckedCreateInput = {
    id?: string
    impersonator_id: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUpdateManyWithoutImpersonation_sessionsNestedInput
    users_impersonation_sessions_impersonator_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersNestedInput
    users_impersonation_sessions_impersonated_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersNestedInput
    sessions?: sessionsUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsCreateManyInput = {
    id?: string
    impersonator_id: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type import_mappingsCreateInput = {
    id?: string
    type: string
    key?: string | null
    value?: string | null
    create_when_empty?: boolean | null
    import_id: string
    mappable_type?: string | null
    mappable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type import_mappingsUncheckedCreateInput = {
    id?: string
    type: string
    key?: string | null
    value?: string | null
    create_when_empty?: boolean | null
    import_id: string
    mappable_type?: string | null
    mappable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type import_mappingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    create_when_empty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    import_id?: StringFieldUpdateOperationsInput | string
    mappable_type?: NullableStringFieldUpdateOperationsInput | string | null
    mappable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type import_mappingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    create_when_empty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    import_id?: StringFieldUpdateOperationsInput | string
    mappable_type?: NullableStringFieldUpdateOperationsInput | string | null
    mappable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type import_mappingsCreateManyInput = {
    id?: string
    type: string
    key?: string | null
    value?: string | null
    create_when_empty?: boolean | null
    import_id: string
    mappable_type?: string | null
    mappable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type import_mappingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    create_when_empty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    import_id?: StringFieldUpdateOperationsInput | string
    mappable_type?: NullableStringFieldUpdateOperationsInput | string | null
    mappable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type import_mappingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    create_when_empty?: NullableBoolFieldUpdateOperationsInput | boolean | null
    import_id?: StringFieldUpdateOperationsInput | string
    mappable_type?: NullableStringFieldUpdateOperationsInput | string | null
    mappable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type import_rowsCreateInput = {
    id?: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
    imports: importsCreateNestedOneWithoutImport_rowsInput
  }

  export type import_rowsUncheckedCreateInput = {
    id?: string
    import_id: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
  }

  export type import_rowsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    imports?: importsUpdateOneRequiredWithoutImport_rowsNestedInput
  }

  export type import_rowsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    import_id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type import_rowsCreateManyInput = {
    id?: string
    import_id: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
  }

  export type import_rowsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type import_rowsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    import_id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type importsCreateInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsCreateNestedManyWithoutImportsInput
    entries?: entriesCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsCreateNestedManyWithoutImportsInput
    families: familiesCreateNestedOneWithoutImportsInput
  }

  export type importsUncheckedCreateInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    family_id: string
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutImportsInput
    entries?: entriesUncheckedCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsUncheckedCreateNestedManyWithoutImportsInput
  }

  export type importsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutImportsNestedInput
    entries?: entriesUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUpdateManyWithoutImportsNestedInput
    families?: familiesUpdateOneRequiredWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutImportsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUncheckedUpdateManyWithoutImportsNestedInput
  }

  export type importsCreateManyInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    family_id: string
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
  }

  export type importsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type importsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type investmentsCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type investmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type invitationsCreateInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
    families: familiesCreateNestedOneWithoutInvitationsInput
    users: usersCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    family_id: string
    inviter_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type invitationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    families?: familiesUpdateOneRequiredWithoutInvitationsNestedInput
    users?: usersUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    inviter_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsCreateManyInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    family_id: string
    inviter_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type invitationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    inviter_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invite_codesCreateInput = {
    id?: string
    token: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type invite_codesUncheckedCreateInput = {
    id?: string
    token: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type invite_codesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invite_codesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invite_codesCreateManyInput = {
    id?: string
    token: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type invite_codesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invite_codesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type loansCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    rate_type?: string | null
    interest_rate?: Decimal | DecimalJsLike | number | string | null
    term_months?: number | null
    initial_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    rate_type?: string | null
    interest_rate?: Decimal | DecimalJsLike | number | string | null
    term_months?: number | null
    initial_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rate_type?: NullableStringFieldUpdateOperationsInput | string | null
    interest_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    term_months?: NullableIntFieldUpdateOperationsInput | number | null
    initial_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rate_type?: NullableStringFieldUpdateOperationsInput | string | null
    interest_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    term_months?: NullableIntFieldUpdateOperationsInput | number | null
    initial_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    rate_type?: string | null
    interest_rate?: Decimal | DecimalJsLike | number | string | null
    term_months?: number | null
    initial_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rate_type?: NullableStringFieldUpdateOperationsInput | string | null
    interest_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    term_months?: NullableIntFieldUpdateOperationsInput | number | null
    initial_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type loansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rate_type?: NullableStringFieldUpdateOperationsInput | string | null
    interest_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    term_months?: NullableIntFieldUpdateOperationsInput | number | null
    initial_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type merchantsCreateInput = {
    id?: string
    name: string
    color?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
    families?: familiesCreateNestedOneWithoutMerchantsInput
    transactions?: transactionsCreateNestedManyWithoutMerchantsInput
  }

  export type merchantsUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    family_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutMerchantsInput
  }

  export type merchantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    families?: familiesUpdateOneWithoutMerchantsNestedInput
    transactions?: transactionsUpdateManyWithoutMerchantsNestedInput
  }

  export type merchantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutMerchantsNestedInput
  }

  export type merchantsCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    family_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
  }

  export type merchantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type merchantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesCreateInput = {
    id?: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
    chats: chatsCreateNestedOneWithoutMessagesInput
    tool_calls?: tool_callsCreateNestedManyWithoutMessagesInput
  }

  export type messagesUncheckedCreateInput = {
    id?: string
    chat_id: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
    tool_calls?: tool_callsUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chats?: chatsUpdateOneRequiredWithoutMessagesNestedInput
    tool_calls?: tool_callsUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tool_calls?: tool_callsUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesCreateManyInput = {
    id?: string
    chat_id: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
  }

  export type messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type other_assetsCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_assetsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type other_liabilitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plaid_accountsCreateInput = {
    id?: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
    accounts?: accountsCreateNestedManyWithoutPlaid_accountsInput
    plaid_items: plaid_itemsCreateNestedOneWithoutPlaid_accountsInput
  }

  export type plaid_accountsUncheckedCreateInput = {
    id?: string
    plaid_item_id: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
    accounts?: accountsUncheckedCreateNestedManyWithoutPlaid_accountsInput
  }

  export type plaid_accountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateManyWithoutPlaid_accountsNestedInput
    plaid_items?: plaid_itemsUpdateOneRequiredWithoutPlaid_accountsNestedInput
  }

  export type plaid_accountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_item_id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUncheckedUpdateManyWithoutPlaid_accountsNestedInput
  }

  export type plaid_accountsCreateManyInput = {
    id?: string
    plaid_item_id: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type plaid_accountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type plaid_accountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_item_id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type plaid_itemsCreateInput = {
    id?: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
    plaid_accounts?: plaid_accountsCreateNestedManyWithoutPlaid_itemsInput
    families: familiesCreateNestedOneWithoutPlaid_itemsInput
  }

  export type plaid_itemsUncheckedCreateInput = {
    id?: string
    family_id: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
    plaid_accounts?: plaid_accountsUncheckedCreateNestedManyWithoutPlaid_itemsInput
  }

  export type plaid_itemsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plaid_accounts?: plaid_accountsUpdateManyWithoutPlaid_itemsNestedInput
    families?: familiesUpdateOneRequiredWithoutPlaid_itemsNestedInput
  }

  export type plaid_itemsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plaid_accounts?: plaid_accountsUncheckedUpdateManyWithoutPlaid_itemsNestedInput
  }

  export type plaid_itemsCreateManyInput = {
    id?: string
    family_id: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
  }

  export type plaid_itemsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type plaid_itemsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type propertiesCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year_built?: number | null
    area_value?: number | null
    area_unit?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year_built?: number | null
    area_value?: number | null
    area_unit?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year_built?: NullableIntFieldUpdateOperationsInput | number | null
    area_value?: NullableIntFieldUpdateOperationsInput | number | null
    area_unit?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year_built?: NullableIntFieldUpdateOperationsInput | number | null
    area_value?: NullableIntFieldUpdateOperationsInput | number | null
    area_unit?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year_built?: number | null
    area_value?: number | null
    area_unit?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year_built?: NullableIntFieldUpdateOperationsInput | number | null
    area_value?: NullableIntFieldUpdateOperationsInput | number | null
    area_unit?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type propertiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year_built?: NullableIntFieldUpdateOperationsInput | number | null
    area_value?: NullableIntFieldUpdateOperationsInput | number | null
    area_unit?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type rejected_transfersCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput
    transactions_rejected_transfers_inflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput
  }

  export type rejected_transfersUncheckedCreateInput = {
    id?: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type rejected_transfersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersCreateManyInput = {
    id?: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsCreateInput = {
    id?: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    rules: rulesCreateNestedOneWithoutRule_actionsInput
  }

  export type rule_actionsUncheckedCreateInput = {
    id?: string
    rule_id: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_actionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: rulesUpdateOneRequiredWithoutRule_actionsNestedInput
  }

  export type rule_actionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsCreateManyInput = {
    id?: string
    rule_id: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_actionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_conditionsCreateInput = {
    id?: string
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    rule_conditions?: rule_conditionsCreateNestedOneWithoutOther_rule_conditionsInput
    other_rule_conditions?: rule_conditionsCreateNestedManyWithoutRule_conditionsInput
    rules?: rulesCreateNestedOneWithoutRule_conditionsInput
  }

  export type rule_conditionsUncheckedCreateInput = {
    id?: string
    rule_id?: string | null
    parent_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    other_rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRule_conditionsInput
  }

  export type rule_conditionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_conditions?: rule_conditionsUpdateOneWithoutOther_rule_conditionsNestedInput
    other_rule_conditions?: rule_conditionsUpdateManyWithoutRule_conditionsNestedInput
    rules?: rulesUpdateOneWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    other_rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsCreateManyInput = {
    id?: string
    rule_id?: string | null
    parent_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_conditionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_conditionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rulesCreateInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsCreateNestedManyWithoutRulesInput
    rule_conditions?: rule_conditionsCreateNestedManyWithoutRulesInput
    families: familiesCreateNestedOneWithoutRulesInput
  }

  export type rulesUncheckedCreateInput = {
    id?: string
    family_id: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsUncheckedCreateNestedManyWithoutRulesInput
    rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRulesInput
  }

  export type rulesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUpdateManyWithoutRulesNestedInput
    rule_conditions?: rule_conditionsUpdateManyWithoutRulesNestedInput
    families?: familiesUpdateOneRequiredWithoutRulesNestedInput
  }

  export type rulesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUncheckedUpdateManyWithoutRulesNestedInput
    rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type rulesCreateManyInput = {
    id?: string
    family_id: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
  }

  export type rulesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rulesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type schema_migrationsCreateInput = {
    version: string
  }

  export type schema_migrationsUncheckedCreateInput = {
    version: string
  }

  export type schema_migrationsUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsCreateManyInput = {
    version: string
  }

  export type schema_migrationsUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type schema_migrationsUncheckedUpdateManyInput = {
    version?: StringFieldUpdateOperationsInput | string
  }

  export type securitiesCreateInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsCreateNestedManyWithoutSecuritiesInput
    security_prices?: security_pricesCreateNestedManyWithoutSecuritiesInput
    trades?: tradesCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesUncheckedCreateInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsUncheckedCreateNestedManyWithoutSecuritiesInput
    security_prices?: security_pricesUncheckedCreateNestedManyWithoutSecuritiesInput
    trades?: tradesUncheckedCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUpdateManyWithoutSecuritiesNestedInput
    security_prices?: security_pricesUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUpdateManyWithoutSecuritiesNestedInput
  }

  export type securitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUncheckedUpdateManyWithoutSecuritiesNestedInput
    security_prices?: security_pricesUncheckedUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUncheckedUpdateManyWithoutSecuritiesNestedInput
  }

  export type securitiesCreateManyInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
  }

  export type securitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type securitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type security_pricesCreateInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    securities?: securitiesCreateNestedOneWithoutSecurity_pricesInput
  }

  export type security_pricesUncheckedCreateInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    security_id?: string | null
  }

  export type security_pricesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    securities?: securitiesUpdateOneWithoutSecurity_pricesNestedInput
  }

  export type security_pricesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    security_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type security_pricesCreateManyInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    security_id?: string | null
  }

  export type security_pricesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type security_pricesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    security_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionsCreateInput = {
    id?: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    impersonation_sessions?: impersonation_sessionsCreateNestedOneWithoutSessionsInput
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    id?: string
    user_id: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    active_impersonator_session_id?: string | null
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    impersonation_sessions?: impersonation_sessionsUpdateOneWithoutSessionsNestedInput
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_impersonator_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsCreateManyInput = {
    id?: string
    user_id: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    active_impersonator_session_id?: string | null
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_impersonator_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type settingsCreateInput = {
    id?: bigint | number
    var: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type settingsUncheckedCreateInput = {
    id?: bigint | number
    var: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type settingsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    var?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    var?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsCreateManyInput = {
    id?: bigint | number
    var: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type settingsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    var?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type settingsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    var?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_exchangesCreateInput = {
    id?: string
    name: string
    acronym?: string | null
    mic: string
    country: string
    country_code: string
    city?: string | null
    website?: string | null
    timezone_name?: string | null
    timezone_abbr?: string | null
    timezone_abbr_dst?: string | null
    currency_code?: string | null
    currency_symbol?: string | null
    currency_name?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type stock_exchangesUncheckedCreateInput = {
    id?: string
    name: string
    acronym?: string | null
    mic: string
    country: string
    country_code: string
    city?: string | null
    website?: string | null
    timezone_name?: string | null
    timezone_abbr?: string | null
    timezone_abbr_dst?: string | null
    currency_code?: string | null
    currency_symbol?: string | null
    currency_name?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type stock_exchangesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr_dst?: NullableStringFieldUpdateOperationsInput | string | null
    currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    currency_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_exchangesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr_dst?: NullableStringFieldUpdateOperationsInput | string | null
    currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    currency_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_exchangesCreateManyInput = {
    id?: string
    name: string
    acronym?: string | null
    mic: string
    country: string
    country_code: string
    city?: string | null
    website?: string | null
    timezone_name?: string | null
    timezone_abbr?: string | null
    timezone_abbr_dst?: string | null
    currency_code?: string | null
    currency_symbol?: string | null
    currency_name?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type stock_exchangesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr_dst?: NullableStringFieldUpdateOperationsInput | string | null
    currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    currency_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_exchangesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    acronym?: NullableStringFieldUpdateOperationsInput | string | null
    mic?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_name?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr?: NullableStringFieldUpdateOperationsInput | string | null
    timezone_abbr_dst?: NullableStringFieldUpdateOperationsInput | string | null
    currency_code?: NullableStringFieldUpdateOperationsInput | string | null
    currency_symbol?: NullableStringFieldUpdateOperationsInput | string | null
    currency_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type syncsCreateInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    syncs?: syncsCreateNestedOneWithoutOther_syncsInput
    other_syncs?: syncsCreateNestedManyWithoutSyncsInput
  }

  export type syncsUncheckedCreateInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    parent_id?: string | null
    other_syncs?: syncsUncheckedCreateNestedManyWithoutSyncsInput
  }

  export type syncsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    syncs?: syncsUpdateOneWithoutOther_syncsNestedInput
    other_syncs?: syncsUpdateManyWithoutSyncsNestedInput
  }

  export type syncsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    other_syncs?: syncsUncheckedUpdateManyWithoutSyncsNestedInput
  }

  export type syncsCreateManyInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    parent_id?: string | null
  }

  export type syncsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
  }

  export type syncsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taggingsCreateInput = {
    id?: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    tags: tagsCreateNestedOneWithoutTaggingsInput
  }

  export type taggingsUncheckedCreateInput = {
    id?: string
    tag_id: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type taggingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: tagsUpdateOneRequiredWithoutTaggingsNestedInput
  }

  export type taggingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taggingsCreateManyInput = {
    id?: string
    tag_id: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type taggingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taggingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag_id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagsCreateInput = {
    id?: string
    name?: string | null
    color?: string
    created_at: Date | string
    updated_at: Date | string
    taggings?: taggingsCreateNestedManyWithoutTagsInput
    families: familiesCreateNestedOneWithoutTagsInput
  }

  export type tagsUncheckedCreateInput = {
    id?: string
    name?: string | null
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
    taggings?: taggingsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    taggings?: taggingsUpdateManyWithoutTagsNestedInput
    families?: familiesUpdateOneRequiredWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    taggings?: taggingsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsCreateManyInput = {
    id?: string
    name?: string | null
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type tagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tool_callsCreateInput = {
    id?: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    messages: messagesCreateNestedOneWithoutTool_callsInput
  }

  export type tool_callsUncheckedCreateInput = {
    id?: string
    message_id: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type tool_callsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messagesUpdateOneRequiredWithoutTool_callsNestedInput
  }

  export type tool_callsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tool_callsCreateManyInput = {
    id?: string
    message_id: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type tool_callsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tool_callsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tradesCreateInput = {
    id?: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    securities: securitiesCreateNestedOneWithoutTradesInput
  }

  export type tradesUncheckedCreateInput = {
    id?: string
    security_id: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    securities?: securitiesUpdateOneRequiredWithoutTradesNestedInput
  }

  export type tradesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesCreateManyInput = {
    id?: string
    security_id: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type transactionsCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
  }

  export type transactionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transfersCreateInput = {
    id?: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    transactions_transfers_outflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput
    transactions_transfers_inflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transfersUncheckedCreateInput = {
    id?: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_transfers_outflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutTransfers_transfers_outflow_transaction_idTotransactionsNestedInput
    transactions_transfers_inflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutTransfers_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transfersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersCreateManyInput = {
    id?: string
    inflow_transaction_id: string
    outflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type valuationsCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type valuationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year?: number | null
    mileage_value?: number | null
    mileage_unit?: string | null
    make?: string | null
    model?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedCreateInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year?: number | null
    mileage_value?: number | null
    mileage_unit?: string | null
    make?: string | null
    model?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_value?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_unit?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_value?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_unit?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesCreateManyInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    year?: number | null
    mileage_value?: number | null
    mileage_unit?: string | null
    make?: string | null
    model?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_value?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_unit?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type vehiclesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_value?: NullableIntFieldUpdateOperationsInput | number | null
    mileage_unit?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FamiliesScalarRelationFilter = {
    is?: familiesWhereInput
    isNot?: familiesWhereInput
  }

  export type ImportsNullableScalarRelationFilter = {
    is?: importsWhereInput | null
    isNot?: importsWhereInput | null
  }

  export type Plaid_accountsNullableScalarRelationFilter = {
    is?: plaid_accountsWhereInput | null
    isNot?: plaid_accountsWhereInput | null
  }

  export type BalancesListRelationFilter = {
    every?: balancesWhereInput
    some?: balancesWhereInput
    none?: balancesWhereInput
  }

  export type EntriesListRelationFilter = {
    every?: entriesWhereInput
    some?: entriesWhereInput
    none?: entriesWhereInput
  }

  export type HoldingsListRelationFilter = {
    every?: holdingsWhereInput
    some?: holdingsWhereInput
    none?: holdingsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type balancesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type holdingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    subtype?: SortOrder
    family_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accountable_type?: SortOrder
    accountable_id?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    classification?: SortOrder
    import_id?: SortOrder
    plaid_account_id?: SortOrder
    scheduled_for_deletion?: SortOrder
    last_synced_at?: SortOrder
    cash_balance?: SortOrder
    locked_attributes?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    balance?: SortOrder
    cash_balance?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    subtype?: SortOrder
    family_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accountable_type?: SortOrder
    accountable_id?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    classification?: SortOrder
    import_id?: SortOrder
    plaid_account_id?: SortOrder
    scheduled_for_deletion?: SortOrder
    last_synced_at?: SortOrder
    cash_balance?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    subtype?: SortOrder
    family_id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    accountable_type?: SortOrder
    accountable_id?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    is_active?: SortOrder
    classification?: SortOrder
    import_id?: SortOrder
    plaid_account_id?: SortOrder
    scheduled_for_deletion?: SortOrder
    last_synced_at?: SortOrder
    cash_balance?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    balance?: SortOrder
    cash_balance?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Active_storage_blobsScalarRelationFilter = {
    is?: active_storage_blobsWhereInput
    isNot?: active_storage_blobsWhereInput
  }

  export type active_storage_attachmentsRecord_typeRecord_idNameBlob_idCompoundUniqueInput = {
    record_type: string
    record_id: string
    name: string
    blob_id: string
  }

  export type active_storage_attachmentsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    record_type?: SortOrder
    record_id?: SortOrder
    blob_id?: SortOrder
    created_at?: SortOrder
  }

  export type active_storage_attachmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    record_type?: SortOrder
    record_id?: SortOrder
    blob_id?: SortOrder
    created_at?: SortOrder
  }

  export type active_storage_attachmentsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    record_type?: SortOrder
    record_id?: SortOrder
    blob_id?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type Active_storage_attachmentsListRelationFilter = {
    every?: active_storage_attachmentsWhereInput
    some?: active_storage_attachmentsWhereInput
    none?: active_storage_attachmentsWhereInput
  }

  export type Active_storage_variant_recordsListRelationFilter = {
    every?: active_storage_variant_recordsWhereInput
    some?: active_storage_variant_recordsWhereInput
    none?: active_storage_variant_recordsWhereInput
  }

  export type active_storage_attachmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type active_storage_variant_recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type active_storage_blobsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    content_type?: SortOrder
    metadata?: SortOrder
    service_name?: SortOrder
    byte_size?: SortOrder
    checksum?: SortOrder
    created_at?: SortOrder
  }

  export type active_storage_blobsAvgOrderByAggregateInput = {
    byte_size?: SortOrder
  }

  export type active_storage_blobsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    content_type?: SortOrder
    metadata?: SortOrder
    service_name?: SortOrder
    byte_size?: SortOrder
    checksum?: SortOrder
    created_at?: SortOrder
  }

  export type active_storage_blobsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    content_type?: SortOrder
    metadata?: SortOrder
    service_name?: SortOrder
    byte_size?: SortOrder
    checksum?: SortOrder
    created_at?: SortOrder
  }

  export type active_storage_blobsSumOrderByAggregateInput = {
    byte_size?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type active_storage_variant_recordsBlob_idVariation_digestCompoundUniqueInput = {
    blob_id: string
    variation_digest: string
  }

  export type active_storage_variant_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    blob_id?: SortOrder
    variation_digest?: SortOrder
  }

  export type active_storage_variant_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    blob_id?: SortOrder
    variation_digest?: SortOrder
  }

  export type active_storage_variant_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    blob_id?: SortOrder
    variation_digest?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type addressesCountOrderByAggregateInput = {
    id?: SortOrder
    addressable_type?: SortOrder
    addressable_id?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    county?: SortOrder
    locality?: SortOrder
    region?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type addressesAvgOrderByAggregateInput = {
    postal_code?: SortOrder
  }

  export type addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    addressable_type?: SortOrder
    addressable_id?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    county?: SortOrder
    locality?: SortOrder
    region?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type addressesMinOrderByAggregateInput = {
    id?: SortOrder
    addressable_type?: SortOrder
    addressable_id?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    county?: SortOrder
    locality?: SortOrder
    region?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type addressesSumOrderByAggregateInput = {
    postal_code?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ar_internal_metadataCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ar_internal_metadataMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ar_internal_metadataMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AccountsScalarRelationFilter = {
    is?: accountsWhereInput
    isNot?: accountsWhereInput
  }

  export type balancesAccount_idDateCurrencyCompoundUniqueInput = {
    account_id: string
    date: Date | string
    currency: string
  }

  export type balancesCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    date?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cash_balance?: SortOrder
  }

  export type balancesAvgOrderByAggregateInput = {
    balance?: SortOrder
    cash_balance?: SortOrder
  }

  export type balancesMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    date?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cash_balance?: SortOrder
  }

  export type balancesMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    date?: SortOrder
    balance?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    cash_balance?: SortOrder
  }

  export type balancesSumOrderByAggregateInput = {
    balance?: SortOrder
    cash_balance?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CategoriesScalarRelationFilter = {
    is?: categoriesWhereInput
    isNot?: categoriesWhereInput
  }

  export type BudgetsScalarRelationFilter = {
    is?: budgetsWhereInput
    isNot?: budgetsWhereInput
  }

  export type budget_categoriesBudget_idCategory_idCompoundUniqueInput = {
    budget_id: string
    category_id: string
  }

  export type budget_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    budget_id?: SortOrder
    category_id?: SortOrder
    budgeted_spending?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budget_categoriesAvgOrderByAggregateInput = {
    budgeted_spending?: SortOrder
  }

  export type budget_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    budget_id?: SortOrder
    category_id?: SortOrder
    budgeted_spending?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budget_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    budget_id?: SortOrder
    category_id?: SortOrder
    budgeted_spending?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budget_categoriesSumOrderByAggregateInput = {
    budgeted_spending?: SortOrder
  }

  export type Budget_categoriesListRelationFilter = {
    every?: budget_categoriesWhereInput
    some?: budget_categoriesWhereInput
    none?: budget_categoriesWhereInput
  }

  export type budget_categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type budgetsFamily_idStart_dateEnd_dateCompoundUniqueInput = {
    family_id: string
    start_date: Date | string
    end_date: Date | string
  }

  export type budgetsCountOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    budgeted_spending?: SortOrder
    expected_income?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budgetsAvgOrderByAggregateInput = {
    budgeted_spending?: SortOrder
    expected_income?: SortOrder
  }

  export type budgetsMaxOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    budgeted_spending?: SortOrder
    expected_income?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budgetsMinOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    budgeted_spending?: SortOrder
    expected_income?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type budgetsSumOrderByAggregateInput = {
    budgeted_spending?: SortOrder
    expected_income?: SortOrder
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrder
    classification?: SortOrder
    lucide_icon?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrder
    classification?: SortOrder
    lucide_icon?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrder
    classification?: SortOrder
    lucide_icon?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    error?: SortOrder
    latest_assistant_response_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chatsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    latest_assistant_response_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chatsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    instructions?: SortOrder
    latest_assistant_response_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type credit_cardsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_credit?: SortOrder
    minimum_payment?: SortOrder
    apr?: SortOrder
    expiration_date?: SortOrder
    annual_fee?: SortOrder
    locked_attributes?: SortOrder
  }

  export type credit_cardsAvgOrderByAggregateInput = {
    available_credit?: SortOrder
    minimum_payment?: SortOrder
    apr?: SortOrder
    annual_fee?: SortOrder
  }

  export type credit_cardsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_credit?: SortOrder
    minimum_payment?: SortOrder
    apr?: SortOrder
    expiration_date?: SortOrder
    annual_fee?: SortOrder
  }

  export type credit_cardsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_credit?: SortOrder
    minimum_payment?: SortOrder
    apr?: SortOrder
    expiration_date?: SortOrder
    annual_fee?: SortOrder
  }

  export type credit_cardsSumOrderByAggregateInput = {
    available_credit?: SortOrder
    minimum_payment?: SortOrder
    apr?: SortOrder
    annual_fee?: SortOrder
  }

  export type cryptosCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type cryptosMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type cryptosMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type data_enrichmentsEnrichable_idEnrichable_typeSourceAttribute_nameCompoundUniqueInput = {
    enrichable_id: string
    enrichable_type: string
    source: string
    attribute_name: string
  }

  export type data_enrichmentsCountOrderByAggregateInput = {
    id?: SortOrder
    enrichable_type?: SortOrder
    enrichable_id?: SortOrder
    source?: SortOrder
    attribute_name?: SortOrder
    value?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type data_enrichmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    enrichable_type?: SortOrder
    enrichable_id?: SortOrder
    source?: SortOrder
    attribute_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type data_enrichmentsMinOrderByAggregateInput = {
    id?: SortOrder
    enrichable_type?: SortOrder
    enrichable_id?: SortOrder
    source?: SortOrder
    attribute_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type depositoriesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type depositoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type depositoriesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type entriesCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entryable_type?: SortOrder
    entryable_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    notes?: SortOrder
    excluded?: SortOrder
    plaid_id?: SortOrder
    locked_attributes?: SortOrder
  }

  export type entriesAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type entriesMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entryable_type?: SortOrder
    entryable_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    notes?: SortOrder
    excluded?: SortOrder
    plaid_id?: SortOrder
  }

  export type entriesMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    entryable_type?: SortOrder
    entryable_id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    date?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_id?: SortOrder
    notes?: SortOrder
    excluded?: SortOrder
    plaid_id?: SortOrder
  }

  export type entriesSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type exchange_ratesFrom_currencyTo_currencyDateCompoundUniqueInput = {
    from_currency: string
    to_currency: string
    date: Date | string
  }

  export type exchange_ratesCountOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type exchange_ratesAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type exchange_ratesMaxOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type exchange_ratesMinOrderByAggregateInput = {
    id?: SortOrder
    from_currency?: SortOrder
    to_currency?: SortOrder
    rate?: SortOrder
    date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type exchange_ratesSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type AccountsListRelationFilter = {
    every?: accountsWhereInput
    some?: accountsWhereInput
    none?: accountsWhereInput
  }

  export type BudgetsListRelationFilter = {
    every?: budgetsWhereInput
    some?: budgetsWhereInput
    none?: budgetsWhereInput
  }

  export type CategoriesListRelationFilter = {
    every?: categoriesWhereInput
    some?: categoriesWhereInput
    none?: categoriesWhereInput
  }

  export type ImportsListRelationFilter = {
    every?: importsWhereInput
    some?: importsWhereInput
    none?: importsWhereInput
  }

  export type InvitationsListRelationFilter = {
    every?: invitationsWhereInput
    some?: invitationsWhereInput
    none?: invitationsWhereInput
  }

  export type MerchantsListRelationFilter = {
    every?: merchantsWhereInput
    some?: merchantsWhereInput
    none?: merchantsWhereInput
  }

  export type Plaid_itemsListRelationFilter = {
    every?: plaid_itemsWhereInput
    some?: plaid_itemsWhereInput
    none?: plaid_itemsWhereInput
  }

  export type RulesListRelationFilter = {
    every?: rulesWhereInput
    some?: rulesWhereInput
    none?: rulesWhereInput
  }

  export type TagsListRelationFilter = {
    every?: tagsWhereInput
    some?: tagsWhereInput
    none?: tagsWhereInput
  }

  export type accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type budgetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type importsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invitationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type merchantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plaid_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type familiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    stripe_plan_id?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_status?: SortOrder
    date_format?: SortOrder
    country?: SortOrder
    last_synced_at?: SortOrder
    timezone?: SortOrder
    data_enrichment_enabled?: SortOrder
    trial_started_at?: SortOrder
    early_access?: SortOrder
  }

  export type familiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    stripe_plan_id?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_status?: SortOrder
    date_format?: SortOrder
    country?: SortOrder
    last_synced_at?: SortOrder
    timezone?: SortOrder
    data_enrichment_enabled?: SortOrder
    trial_started_at?: SortOrder
    early_access?: SortOrder
  }

  export type familiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
    locale?: SortOrder
    stripe_plan_id?: SortOrder
    stripe_customer_id?: SortOrder
    stripe_subscription_status?: SortOrder
    date_format?: SortOrder
    country?: SortOrder
    last_synced_at?: SortOrder
    timezone?: SortOrder
    data_enrichment_enabled?: SortOrder
    trial_started_at?: SortOrder
    early_access?: SortOrder
  }

  export type SecuritiesScalarRelationFilter = {
    is?: securitiesWhereInput
    isNot?: securitiesWhereInput
  }

  export type holdingsAccount_idSecurity_idDateCurrencyCompoundUniqueInput = {
    account_id: string
    security_id: string
    date: Date | string
    currency: string
  }

  export type holdingsCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    security_id?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holdingsAvgOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type holdingsMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    security_id?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holdingsMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    security_id?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type holdingsSumOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
    amount?: SortOrder
  }

  export type Impersonation_sessionsScalarRelationFilter = {
    is?: impersonation_sessionsWhereInput
    isNot?: impersonation_sessionsWhereInput
  }

  export type impersonation_session_logsCountOrderByAggregateInput = {
    id?: SortOrder
    impersonation_session_id?: SortOrder
    controller?: SortOrder
    action?: SortOrder
    path?: SortOrder
    method?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type impersonation_session_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    impersonation_session_id?: SortOrder
    controller?: SortOrder
    action?: SortOrder
    path?: SortOrder
    method?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type impersonation_session_logsMinOrderByAggregateInput = {
    id?: SortOrder
    impersonation_session_id?: SortOrder
    controller?: SortOrder
    action?: SortOrder
    path?: SortOrder
    method?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Impersonation_session_logsListRelationFilter = {
    every?: impersonation_session_logsWhereInput
    some?: impersonation_session_logsWhereInput
    none?: impersonation_session_logsWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type impersonation_session_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type impersonation_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    impersonator_id?: SortOrder
    impersonated_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type impersonation_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    impersonator_id?: SortOrder
    impersonated_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type impersonation_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    impersonator_id?: SortOrder
    impersonated_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type import_mappingsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
    create_when_empty?: SortOrder
    import_id?: SortOrder
    mappable_type?: SortOrder
    mappable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type import_mappingsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
    create_when_empty?: SortOrder
    import_id?: SortOrder
    mappable_type?: SortOrder
    mappable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type import_mappingsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    key?: SortOrder
    value?: SortOrder
    create_when_empty?: SortOrder
    import_id?: SortOrder
    mappable_type?: SortOrder
    mappable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportsScalarRelationFilter = {
    is?: importsWhereInput
    isNot?: importsWhereInput
  }

  export type import_rowsCountOrderByAggregateInput = {
    id?: SortOrder
    import_id?: SortOrder
    account?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    entity_type?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type import_rowsMaxOrderByAggregateInput = {
    id?: SortOrder
    import_id?: SortOrder
    account?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    entity_type?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type import_rowsMinOrderByAggregateInput = {
    id?: SortOrder
    import_id?: SortOrder
    account?: SortOrder
    date?: SortOrder
    qty?: SortOrder
    ticker?: SortOrder
    price?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    entity_type?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type Import_rowsListRelationFilter = {
    every?: import_rowsWhereInput
    some?: import_rowsWhereInput
    none?: import_rowsWhereInput
  }

  export type import_rowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type importsCountOrderByAggregateInput = {
    id?: SortOrder
    column_mappings?: SortOrder
    status?: SortOrder
    raw_file_str?: SortOrder
    normalized_csv_str?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    col_sep?: SortOrder
    family_id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    date_col_label?: SortOrder
    amount_col_label?: SortOrder
    name_col_label?: SortOrder
    category_col_label?: SortOrder
    tags_col_label?: SortOrder
    account_col_label?: SortOrder
    qty_col_label?: SortOrder
    ticker_col_label?: SortOrder
    price_col_label?: SortOrder
    entity_type_col_label?: SortOrder
    notes_col_label?: SortOrder
    currency_col_label?: SortOrder
    date_format?: SortOrder
    signage_convention?: SortOrder
    error?: SortOrder
    number_format?: SortOrder
    exchange_operating_mic_col_label?: SortOrder
    amount_type_strategy?: SortOrder
    amount_type_inflow_value?: SortOrder
  }

  export type importsMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    raw_file_str?: SortOrder
    normalized_csv_str?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    col_sep?: SortOrder
    family_id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    date_col_label?: SortOrder
    amount_col_label?: SortOrder
    name_col_label?: SortOrder
    category_col_label?: SortOrder
    tags_col_label?: SortOrder
    account_col_label?: SortOrder
    qty_col_label?: SortOrder
    ticker_col_label?: SortOrder
    price_col_label?: SortOrder
    entity_type_col_label?: SortOrder
    notes_col_label?: SortOrder
    currency_col_label?: SortOrder
    date_format?: SortOrder
    signage_convention?: SortOrder
    error?: SortOrder
    number_format?: SortOrder
    exchange_operating_mic_col_label?: SortOrder
    amount_type_strategy?: SortOrder
    amount_type_inflow_value?: SortOrder
  }

  export type importsMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    raw_file_str?: SortOrder
    normalized_csv_str?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    col_sep?: SortOrder
    family_id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    date_col_label?: SortOrder
    amount_col_label?: SortOrder
    name_col_label?: SortOrder
    category_col_label?: SortOrder
    tags_col_label?: SortOrder
    account_col_label?: SortOrder
    qty_col_label?: SortOrder
    ticker_col_label?: SortOrder
    price_col_label?: SortOrder
    entity_type_col_label?: SortOrder
    notes_col_label?: SortOrder
    currency_col_label?: SortOrder
    date_format?: SortOrder
    signage_convention?: SortOrder
    error?: SortOrder
    number_format?: SortOrder
    exchange_operating_mic_col_label?: SortOrder
    amount_type_strategy?: SortOrder
    amount_type_inflow_value?: SortOrder
  }

  export type investmentsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type investmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type investmentsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invitationsEmailFamily_idCompoundUniqueInput = {
    email: string
    family_id: string
  }

  export type invitationsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    family_id?: SortOrder
    inviter_id?: SortOrder
    accepted_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invitationsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    family_id?: SortOrder
    inviter_id?: SortOrder
    accepted_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invitationsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    role?: SortOrder
    token?: SortOrder
    family_id?: SortOrder
    inviter_id?: SortOrder
    accepted_at?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invite_codesCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invite_codesMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type invite_codesMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type loansCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rate_type?: SortOrder
    interest_rate?: SortOrder
    term_months?: SortOrder
    initial_balance?: SortOrder
    locked_attributes?: SortOrder
  }

  export type loansAvgOrderByAggregateInput = {
    interest_rate?: SortOrder
    term_months?: SortOrder
    initial_balance?: SortOrder
  }

  export type loansMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rate_type?: SortOrder
    interest_rate?: SortOrder
    term_months?: SortOrder
    initial_balance?: SortOrder
  }

  export type loansMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    rate_type?: SortOrder
    interest_rate?: SortOrder
    term_months?: SortOrder
    initial_balance?: SortOrder
  }

  export type loansSumOrderByAggregateInput = {
    interest_rate?: SortOrder
    term_months?: SortOrder
    initial_balance?: SortOrder
  }

  export type FamiliesNullableScalarRelationFilter = {
    is?: familiesWhereInput | null
    isNot?: familiesWhereInput | null
  }

  export type merchantsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logo_url?: SortOrder
    website_url?: SortOrder
    type?: SortOrder
    source?: SortOrder
    provider_merchant_id?: SortOrder
  }

  export type merchantsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logo_url?: SortOrder
    website_url?: SortOrder
    type?: SortOrder
    source?: SortOrder
    provider_merchant_id?: SortOrder
  }

  export type merchantsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    logo_url?: SortOrder
    website_url?: SortOrder
    type?: SortOrder
    source?: SortOrder
    provider_merchant_id?: SortOrder
  }

  export type ChatsScalarRelationFilter = {
    is?: chatsWhereInput
    isNot?: chatsWhereInput
  }

  export type Tool_callsListRelationFilter = {
    every?: tool_callsWhereInput
    some?: tool_callsWhereInput
    none?: tool_callsWhereInput
  }

  export type tool_callsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    content?: SortOrder
    ai_model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debug?: SortOrder
    provider_id?: SortOrder
    reasoning?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    content?: SortOrder
    ai_model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debug?: SortOrder
    provider_id?: SortOrder
    reasoning?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    content?: SortOrder
    ai_model?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    debug?: SortOrder
    provider_id?: SortOrder
    reasoning?: SortOrder
  }

  export type other_assetsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type other_assetsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type other_assetsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type other_liabilitiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type other_liabilitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type other_liabilitiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Plaid_itemsScalarRelationFilter = {
    is?: plaid_itemsWhereInput
    isNot?: plaid_itemsWhereInput
  }

  export type plaid_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    plaid_item_id?: SortOrder
    plaid_id?: SortOrder
    plaid_type?: SortOrder
    plaid_subtype?: SortOrder
    current_balance?: SortOrder
    available_balance?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    mask?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type plaid_accountsAvgOrderByAggregateInput = {
    current_balance?: SortOrder
    available_balance?: SortOrder
  }

  export type plaid_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    plaid_item_id?: SortOrder
    plaid_id?: SortOrder
    plaid_type?: SortOrder
    plaid_subtype?: SortOrder
    current_balance?: SortOrder
    available_balance?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    mask?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type plaid_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    plaid_item_id?: SortOrder
    plaid_id?: SortOrder
    plaid_type?: SortOrder
    plaid_subtype?: SortOrder
    current_balance?: SortOrder
    available_balance?: SortOrder
    currency?: SortOrder
    name?: SortOrder
    mask?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type plaid_accountsSumOrderByAggregateInput = {
    current_balance?: SortOrder
    available_balance?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Plaid_accountsListRelationFilter = {
    every?: plaid_accountsWhereInput
    some?: plaid_accountsWhereInput
    none?: plaid_accountsWhereInput
  }

  export type plaid_accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plaid_itemsCountOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    access_token?: SortOrder
    plaid_id?: SortOrder
    name?: SortOrder
    next_cursor?: SortOrder
    scheduled_for_deletion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    available_products?: SortOrder
    billed_products?: SortOrder
    last_synced_at?: SortOrder
    plaid_region?: SortOrder
    institution_url?: SortOrder
    institution_id?: SortOrder
    institution_color?: SortOrder
    status?: SortOrder
  }

  export type plaid_itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    access_token?: SortOrder
    plaid_id?: SortOrder
    name?: SortOrder
    next_cursor?: SortOrder
    scheduled_for_deletion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_synced_at?: SortOrder
    plaid_region?: SortOrder
    institution_url?: SortOrder
    institution_id?: SortOrder
    institution_color?: SortOrder
    status?: SortOrder
  }

  export type plaid_itemsMinOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    access_token?: SortOrder
    plaid_id?: SortOrder
    name?: SortOrder
    next_cursor?: SortOrder
    scheduled_for_deletion?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    last_synced_at?: SortOrder
    plaid_region?: SortOrder
    institution_url?: SortOrder
    institution_id?: SortOrder
    institution_color?: SortOrder
    status?: SortOrder
  }

  export type propertiesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year_built?: SortOrder
    area_value?: SortOrder
    area_unit?: SortOrder
    locked_attributes?: SortOrder
  }

  export type propertiesAvgOrderByAggregateInput = {
    year_built?: SortOrder
    area_value?: SortOrder
  }

  export type propertiesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year_built?: SortOrder
    area_value?: SortOrder
    area_unit?: SortOrder
  }

  export type propertiesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year_built?: SortOrder
    area_value?: SortOrder
    area_unit?: SortOrder
  }

  export type propertiesSumOrderByAggregateInput = {
    year_built?: SortOrder
    area_value?: SortOrder
  }

  export type TransactionsScalarRelationFilter = {
    is?: transactionsWhereInput
    isNot?: transactionsWhereInput
  }

  export type rejected_transfersInflow_transaction_idOutflow_transaction_idCompoundUniqueInput = {
    inflow_transaction_id: string
    outflow_transaction_id: string
  }

  export type rejected_transfersCountOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rejected_transfersMaxOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rejected_transfersMinOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RulesScalarRelationFilter = {
    is?: rulesWhereInput
    isNot?: rulesWhereInput
  }

  export type rule_actionsCountOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    action_type?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rule_actionsMaxOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    action_type?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rule_actionsMinOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    action_type?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Rule_conditionsNullableScalarRelationFilter = {
    is?: rule_conditionsWhereInput | null
    isNot?: rule_conditionsWhereInput | null
  }

  export type Rule_conditionsListRelationFilter = {
    every?: rule_conditionsWhereInput
    some?: rule_conditionsWhereInput
    none?: rule_conditionsWhereInput
  }

  export type RulesNullableScalarRelationFilter = {
    is?: rulesWhereInput | null
    isNot?: rulesWhereInput | null
  }

  export type rule_conditionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rule_conditionsCountOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    parent_id?: SortOrder
    condition_type?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rule_conditionsMaxOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    parent_id?: SortOrder
    condition_type?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rule_conditionsMinOrderByAggregateInput = {
    id?: SortOrder
    rule_id?: SortOrder
    parent_id?: SortOrder
    condition_type?: SortOrder
    operator?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Rule_actionsListRelationFilter = {
    every?: rule_actionsWhereInput
    some?: rule_actionsWhereInput
    none?: rule_actionsWhereInput
  }

  export type rule_actionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rulesCountOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    resource_type?: SortOrder
    effective_date?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rulesMaxOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    resource_type?: SortOrder
    effective_date?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rulesMinOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    resource_type?: SortOrder
    effective_date?: SortOrder
    active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type schema_migrationsCountOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMaxOrderByAggregateInput = {
    version?: SortOrder
  }

  export type schema_migrationsMinOrderByAggregateInput = {
    version?: SortOrder
  }

  export type Security_pricesListRelationFilter = {
    every?: security_pricesWhereInput
    some?: security_pricesWhereInput
    none?: security_pricesWhereInput
  }

  export type TradesListRelationFilter = {
    every?: tradesWhereInput
    some?: tradesWhereInput
    none?: tradesWhereInput
  }

  export type security_pricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tradesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type securitiesTickerExchange_operating_micCompoundUniqueInput = {
    ticker: string
    exchange_operating_mic: string
  }

  export type securitiesCountOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country_code?: SortOrder
    exchange_mic?: SortOrder
    exchange_acronym?: SortOrder
    logo_url?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type securitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country_code?: SortOrder
    exchange_mic?: SortOrder
    exchange_acronym?: SortOrder
    logo_url?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type securitiesMinOrderByAggregateInput = {
    id?: SortOrder
    ticker?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    country_code?: SortOrder
    exchange_mic?: SortOrder
    exchange_acronym?: SortOrder
    logo_url?: SortOrder
    exchange_operating_mic?: SortOrder
  }

  export type SecuritiesNullableScalarRelationFilter = {
    is?: securitiesWhereInput | null
    isNot?: securitiesWhereInput | null
  }

  export type security_pricesSecurity_idDateCurrencyCompoundUniqueInput = {
    security_id: string
    date: Date | string
    currency: string
  }

  export type security_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    security_id?: SortOrder
  }

  export type security_pricesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type security_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    security_id?: SortOrder
  }

  export type security_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    security_id?: SortOrder
  }

  export type security_pricesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type Impersonation_sessionsNullableScalarRelationFilter = {
    is?: impersonation_sessionsWhereInput | null
    isNot?: impersonation_sessionsWhereInput | null
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active_impersonator_session_id?: SortOrder
    subscribed_at?: SortOrder
    prev_transaction_page_params?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active_impersonator_session_id?: SortOrder
    subscribed_at?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    active_impersonator_session_id?: SortOrder
    subscribed_at?: SortOrder
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    var?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    var?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    var?: SortOrder
    value?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type settingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type stock_exchangesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    city?: SortOrder
    website?: SortOrder
    timezone_name?: SortOrder
    timezone_abbr?: SortOrder
    timezone_abbr_dst?: SortOrder
    currency_code?: SortOrder
    currency_symbol?: SortOrder
    currency_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stock_exchangesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    city?: SortOrder
    website?: SortOrder
    timezone_name?: SortOrder
    timezone_abbr?: SortOrder
    timezone_abbr_dst?: SortOrder
    currency_code?: SortOrder
    currency_symbol?: SortOrder
    currency_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type stock_exchangesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    acronym?: SortOrder
    mic?: SortOrder
    country?: SortOrder
    country_code?: SortOrder
    city?: SortOrder
    website?: SortOrder
    timezone_name?: SortOrder
    timezone_abbr?: SortOrder
    timezone_abbr_dst?: SortOrder
    currency_code?: SortOrder
    currency_symbol?: SortOrder
    currency_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SyncsNullableScalarRelationFilter = {
    is?: syncsWhereInput | null
    isNot?: syncsWhereInput | null
  }

  export type SyncsListRelationFilter = {
    every?: syncsWhereInput
    some?: syncsWhereInput
    none?: syncsWhereInput
  }

  export type syncsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type syncsCountOrderByAggregateInput = {
    id?: SortOrder
    syncable_type?: SortOrder
    syncable_id?: SortOrder
    last_ran_at?: SortOrder
    start_date?: SortOrder
    status?: SortOrder
    error?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    error_backtrace?: SortOrder
    parent_id?: SortOrder
  }

  export type syncsMaxOrderByAggregateInput = {
    id?: SortOrder
    syncable_type?: SortOrder
    syncable_id?: SortOrder
    last_ran_at?: SortOrder
    start_date?: SortOrder
    status?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrder
  }

  export type syncsMinOrderByAggregateInput = {
    id?: SortOrder
    syncable_type?: SortOrder
    syncable_id?: SortOrder
    last_ran_at?: SortOrder
    start_date?: SortOrder
    status?: SortOrder
    error?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    parent_id?: SortOrder
  }

  export type TagsScalarRelationFilter = {
    is?: tagsWhereInput
    isNot?: tagsWhereInput
  }

  export type taggingsCountOrderByAggregateInput = {
    id?: SortOrder
    tag_id?: SortOrder
    taggable_type?: SortOrder
    taggable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggingsMaxOrderByAggregateInput = {
    id?: SortOrder
    tag_id?: SortOrder
    taggable_type?: SortOrder
    taggable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type taggingsMinOrderByAggregateInput = {
    id?: SortOrder
    tag_id?: SortOrder
    taggable_type?: SortOrder
    taggable_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TaggingsListRelationFilter = {
    every?: taggingsWhereInput
    some?: taggingsWhereInput
    none?: taggingsWhereInput
  }

  export type taggingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    family_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MessagesScalarRelationFilter = {
    is?: messagesWhereInput
    isNot?: messagesWhereInput
  }

  export type tool_callsCountOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    provider_id?: SortOrder
    provider_call_id?: SortOrder
    type?: SortOrder
    function_name?: SortOrder
    function_arguments?: SortOrder
    function_result?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tool_callsMaxOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    provider_id?: SortOrder
    provider_call_id?: SortOrder
    type?: SortOrder
    function_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tool_callsMinOrderByAggregateInput = {
    id?: SortOrder
    message_id?: SortOrder
    provider_id?: SortOrder
    provider_call_id?: SortOrder
    type?: SortOrder
    function_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tradesCountOrderByAggregateInput = {
    id?: SortOrder
    security_id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
    locked_attributes?: SortOrder
  }

  export type tradesAvgOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
  }

  export type tradesMaxOrderByAggregateInput = {
    id?: SortOrder
    security_id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
  }

  export type tradesMinOrderByAggregateInput = {
    id?: SortOrder
    security_id?: SortOrder
    qty?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    currency?: SortOrder
  }

  export type tradesSumOrderByAggregateInput = {
    qty?: SortOrder
    price?: SortOrder
  }

  export type Rejected_transfersListRelationFilter = {
    every?: rejected_transfersWhereInput
    some?: rejected_transfersWhereInput
    none?: rejected_transfersWhereInput
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type MerchantsNullableScalarRelationFilter = {
    is?: merchantsWhereInput | null
    isNot?: merchantsWhereInput | null
  }

  export type TransfersListRelationFilter = {
    every?: transfersWhereInput
    some?: transfersWhereInput
    none?: transfersWhereInput
  }

  export type rejected_transfersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transfersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    merchant_id?: SortOrder
    locked_attributes?: SortOrder
    plaid_category?: SortOrder
    plaid_category_detailed?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    merchant_id?: SortOrder
    plaid_category?: SortOrder
    plaid_category_detailed?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    merchant_id?: SortOrder
    plaid_category?: SortOrder
    plaid_category_detailed?: SortOrder
  }

  export type transfersInflow_transaction_idOutflow_transaction_idCompoundUniqueInput = {
    inflow_transaction_id: string
    outflow_transaction_id: string
  }

  export type transfersCountOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transfersMaxOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type transfersMinOrderByAggregateInput = {
    id?: SortOrder
    inflow_transaction_id?: SortOrder
    outflow_transaction_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatsListRelationFilter = {
    every?: chatsWhereInput
    some?: chatsWhereInput
    none?: chatsWhereInput
  }

  export type Impersonation_sessionsListRelationFilter = {
    every?: impersonation_sessionsWhereInput
    some?: impersonation_sessionsWhereInput
    none?: impersonation_sessionsWhereInput
  }

  export type ChatsNullableScalarRelationFilter = {
    is?: chatsWhereInput | null
    isNot?: chatsWhereInput | null
  }

  export type chatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type impersonation_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_digest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    active?: SortOrder
    onboarded_at?: SortOrder
    unconfirmed_email?: SortOrder
    otp_secret?: SortOrder
    otp_required?: SortOrder
    otp_backup_codes?: SortOrder
    show_sidebar?: SortOrder
    default_period?: SortOrder
    last_viewed_chat_id?: SortOrder
    show_ai_sidebar?: SortOrder
    ai_enabled?: SortOrder
    theme?: SortOrder
    rule_prompts_disabled?: SortOrder
    rule_prompt_dismissed_at?: SortOrder
    goals?: SortOrder
    set_onboarding_preferences_at?: SortOrder
    set_onboarding_goals_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_digest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    active?: SortOrder
    onboarded_at?: SortOrder
    unconfirmed_email?: SortOrder
    otp_secret?: SortOrder
    otp_required?: SortOrder
    show_sidebar?: SortOrder
    default_period?: SortOrder
    last_viewed_chat_id?: SortOrder
    show_ai_sidebar?: SortOrder
    ai_enabled?: SortOrder
    theme?: SortOrder
    rule_prompts_disabled?: SortOrder
    rule_prompt_dismissed_at?: SortOrder
    set_onboarding_preferences_at?: SortOrder
    set_onboarding_goals_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    family_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password_digest?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role?: SortOrder
    active?: SortOrder
    onboarded_at?: SortOrder
    unconfirmed_email?: SortOrder
    otp_secret?: SortOrder
    otp_required?: SortOrder
    show_sidebar?: SortOrder
    default_period?: SortOrder
    last_viewed_chat_id?: SortOrder
    show_ai_sidebar?: SortOrder
    ai_enabled?: SortOrder
    theme?: SortOrder
    rule_prompts_disabled?: SortOrder
    rule_prompt_dismissed_at?: SortOrder
    set_onboarding_preferences_at?: SortOrder
    set_onboarding_goals_at?: SortOrder
  }

  export type valuationsCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locked_attributes?: SortOrder
  }

  export type valuationsMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type valuationsMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type vehiclesCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year?: SortOrder
    mileage_value?: SortOrder
    mileage_unit?: SortOrder
    make?: SortOrder
    model?: SortOrder
    locked_attributes?: SortOrder
  }

  export type vehiclesAvgOrderByAggregateInput = {
    year?: SortOrder
    mileage_value?: SortOrder
  }

  export type vehiclesMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year?: SortOrder
    mileage_value?: SortOrder
    mileage_unit?: SortOrder
    make?: SortOrder
    model?: SortOrder
  }

  export type vehiclesMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    year?: SortOrder
    mileage_value?: SortOrder
    mileage_unit?: SortOrder
    make?: SortOrder
    model?: SortOrder
  }

  export type vehiclesSumOrderByAggregateInput = {
    year?: SortOrder
    mileage_value?: SortOrder
  }

  export type familiesCreateNestedOneWithoutAccountsInput = {
    create?: XOR<familiesCreateWithoutAccountsInput, familiesUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutAccountsInput
    connect?: familiesWhereUniqueInput
  }

  export type importsCreateNestedOneWithoutAccountsInput = {
    create?: XOR<importsCreateWithoutAccountsInput, importsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: importsCreateOrConnectWithoutAccountsInput
    connect?: importsWhereUniqueInput
  }

  export type plaid_accountsCreateNestedOneWithoutAccountsInput = {
    create?: XOR<plaid_accountsCreateWithoutAccountsInput, plaid_accountsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutAccountsInput
    connect?: plaid_accountsWhereUniqueInput
  }

  export type balancesCreateNestedManyWithoutAccountsInput = {
    create?: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput> | balancesCreateWithoutAccountsInput[] | balancesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: balancesCreateOrConnectWithoutAccountsInput | balancesCreateOrConnectWithoutAccountsInput[]
    createMany?: balancesCreateManyAccountsInputEnvelope
    connect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
  }

  export type entriesCreateNestedManyWithoutAccountsInput = {
    create?: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput> | entriesCreateWithoutAccountsInput[] | entriesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutAccountsInput | entriesCreateOrConnectWithoutAccountsInput[]
    createMany?: entriesCreateManyAccountsInputEnvelope
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
  }

  export type holdingsCreateNestedManyWithoutAccountsInput = {
    create?: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput> | holdingsCreateWithoutAccountsInput[] | holdingsUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutAccountsInput | holdingsCreateOrConnectWithoutAccountsInput[]
    createMany?: holdingsCreateManyAccountsInputEnvelope
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
  }

  export type balancesUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput> | balancesCreateWithoutAccountsInput[] | balancesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: balancesCreateOrConnectWithoutAccountsInput | balancesCreateOrConnectWithoutAccountsInput[]
    createMany?: balancesCreateManyAccountsInputEnvelope
    connect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
  }

  export type entriesUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput> | entriesCreateWithoutAccountsInput[] | entriesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutAccountsInput | entriesCreateOrConnectWithoutAccountsInput[]
    createMany?: entriesCreateManyAccountsInputEnvelope
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
  }

  export type holdingsUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput> | holdingsCreateWithoutAccountsInput[] | holdingsUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutAccountsInput | holdingsCreateOrConnectWithoutAccountsInput[]
    createMany?: holdingsCreateManyAccountsInputEnvelope
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type familiesUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<familiesCreateWithoutAccountsInput, familiesUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutAccountsInput
    upsert?: familiesUpsertWithoutAccountsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutAccountsInput, familiesUpdateWithoutAccountsInput>, familiesUncheckedUpdateWithoutAccountsInput>
  }

  export type importsUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<importsCreateWithoutAccountsInput, importsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: importsCreateOrConnectWithoutAccountsInput
    upsert?: importsUpsertWithoutAccountsInput
    disconnect?: importsWhereInput | boolean
    delete?: importsWhereInput | boolean
    connect?: importsWhereUniqueInput
    update?: XOR<XOR<importsUpdateToOneWithWhereWithoutAccountsInput, importsUpdateWithoutAccountsInput>, importsUncheckedUpdateWithoutAccountsInput>
  }

  export type plaid_accountsUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<plaid_accountsCreateWithoutAccountsInput, plaid_accountsUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutAccountsInput
    upsert?: plaid_accountsUpsertWithoutAccountsInput
    disconnect?: plaid_accountsWhereInput | boolean
    delete?: plaid_accountsWhereInput | boolean
    connect?: plaid_accountsWhereUniqueInput
    update?: XOR<XOR<plaid_accountsUpdateToOneWithWhereWithoutAccountsInput, plaid_accountsUpdateWithoutAccountsInput>, plaid_accountsUncheckedUpdateWithoutAccountsInput>
  }

  export type balancesUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput> | balancesCreateWithoutAccountsInput[] | balancesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: balancesCreateOrConnectWithoutAccountsInput | balancesCreateOrConnectWithoutAccountsInput[]
    upsert?: balancesUpsertWithWhereUniqueWithoutAccountsInput | balancesUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: balancesCreateManyAccountsInputEnvelope
    set?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    disconnect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    delete?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    connect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    update?: balancesUpdateWithWhereUniqueWithoutAccountsInput | balancesUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: balancesUpdateManyWithWhereWithoutAccountsInput | balancesUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: balancesScalarWhereInput | balancesScalarWhereInput[]
  }

  export type entriesUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput> | entriesCreateWithoutAccountsInput[] | entriesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutAccountsInput | entriesCreateOrConnectWithoutAccountsInput[]
    upsert?: entriesUpsertWithWhereUniqueWithoutAccountsInput | entriesUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: entriesCreateManyAccountsInputEnvelope
    set?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    disconnect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    delete?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    update?: entriesUpdateWithWhereUniqueWithoutAccountsInput | entriesUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: entriesUpdateManyWithWhereWithoutAccountsInput | entriesUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: entriesScalarWhereInput | entriesScalarWhereInput[]
  }

  export type holdingsUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput> | holdingsCreateWithoutAccountsInput[] | holdingsUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutAccountsInput | holdingsCreateOrConnectWithoutAccountsInput[]
    upsert?: holdingsUpsertWithWhereUniqueWithoutAccountsInput | holdingsUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: holdingsCreateManyAccountsInputEnvelope
    set?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    disconnect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    delete?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    update?: holdingsUpdateWithWhereUniqueWithoutAccountsInput | holdingsUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: holdingsUpdateManyWithWhereWithoutAccountsInput | holdingsUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
  }

  export type balancesUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput> | balancesCreateWithoutAccountsInput[] | balancesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: balancesCreateOrConnectWithoutAccountsInput | balancesCreateOrConnectWithoutAccountsInput[]
    upsert?: balancesUpsertWithWhereUniqueWithoutAccountsInput | balancesUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: balancesCreateManyAccountsInputEnvelope
    set?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    disconnect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    delete?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    connect?: balancesWhereUniqueInput | balancesWhereUniqueInput[]
    update?: balancesUpdateWithWhereUniqueWithoutAccountsInput | balancesUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: balancesUpdateManyWithWhereWithoutAccountsInput | balancesUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: balancesScalarWhereInput | balancesScalarWhereInput[]
  }

  export type entriesUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput> | entriesCreateWithoutAccountsInput[] | entriesUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutAccountsInput | entriesCreateOrConnectWithoutAccountsInput[]
    upsert?: entriesUpsertWithWhereUniqueWithoutAccountsInput | entriesUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: entriesCreateManyAccountsInputEnvelope
    set?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    disconnect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    delete?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    update?: entriesUpdateWithWhereUniqueWithoutAccountsInput | entriesUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: entriesUpdateManyWithWhereWithoutAccountsInput | entriesUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: entriesScalarWhereInput | entriesScalarWhereInput[]
  }

  export type holdingsUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput> | holdingsCreateWithoutAccountsInput[] | holdingsUncheckedCreateWithoutAccountsInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutAccountsInput | holdingsCreateOrConnectWithoutAccountsInput[]
    upsert?: holdingsUpsertWithWhereUniqueWithoutAccountsInput | holdingsUpsertWithWhereUniqueWithoutAccountsInput[]
    createMany?: holdingsCreateManyAccountsInputEnvelope
    set?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    disconnect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    delete?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    update?: holdingsUpdateWithWhereUniqueWithoutAccountsInput | holdingsUpdateWithWhereUniqueWithoutAccountsInput[]
    updateMany?: holdingsUpdateManyWithWhereWithoutAccountsInput | holdingsUpdateManyWithWhereWithoutAccountsInput[]
    deleteMany?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
  }

  export type active_storage_blobsCreateNestedOneWithoutActive_storage_attachmentsInput = {
    create?: XOR<active_storage_blobsCreateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_attachmentsInput>
    connectOrCreate?: active_storage_blobsCreateOrConnectWithoutActive_storage_attachmentsInput
    connect?: active_storage_blobsWhereUniqueInput
  }

  export type active_storage_blobsUpdateOneRequiredWithoutActive_storage_attachmentsNestedInput = {
    create?: XOR<active_storage_blobsCreateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_attachmentsInput>
    connectOrCreate?: active_storage_blobsCreateOrConnectWithoutActive_storage_attachmentsInput
    upsert?: active_storage_blobsUpsertWithoutActive_storage_attachmentsInput
    connect?: active_storage_blobsWhereUniqueInput
    update?: XOR<XOR<active_storage_blobsUpdateToOneWithWhereWithoutActive_storage_attachmentsInput, active_storage_blobsUpdateWithoutActive_storage_attachmentsInput>, active_storage_blobsUncheckedUpdateWithoutActive_storage_attachmentsInput>
  }

  export type active_storage_attachmentsCreateNestedManyWithoutActive_storage_blobsInput = {
    create?: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_attachmentsCreateWithoutActive_storage_blobsInput[] | active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput[]
    createMany?: active_storage_attachmentsCreateManyActive_storage_blobsInputEnvelope
    connect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
  }

  export type active_storage_variant_recordsCreateNestedManyWithoutActive_storage_blobsInput = {
    create?: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_variant_recordsCreateWithoutActive_storage_blobsInput[] | active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput[]
    createMany?: active_storage_variant_recordsCreateManyActive_storage_blobsInputEnvelope
    connect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
  }

  export type active_storage_attachmentsUncheckedCreateNestedManyWithoutActive_storage_blobsInput = {
    create?: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_attachmentsCreateWithoutActive_storage_blobsInput[] | active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput[]
    createMany?: active_storage_attachmentsCreateManyActive_storage_blobsInputEnvelope
    connect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
  }

  export type active_storage_variant_recordsUncheckedCreateNestedManyWithoutActive_storage_blobsInput = {
    create?: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_variant_recordsCreateWithoutActive_storage_blobsInput[] | active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput[]
    createMany?: active_storage_variant_recordsCreateManyActive_storage_blobsInputEnvelope
    connect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type active_storage_attachmentsUpdateManyWithoutActive_storage_blobsNestedInput = {
    create?: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_attachmentsCreateWithoutActive_storage_blobsInput[] | active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput[]
    upsert?: active_storage_attachmentsUpsertWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_attachmentsUpsertWithWhereUniqueWithoutActive_storage_blobsInput[]
    createMany?: active_storage_attachmentsCreateManyActive_storage_blobsInputEnvelope
    set?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    disconnect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    delete?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    connect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    update?: active_storage_attachmentsUpdateWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_attachmentsUpdateWithWhereUniqueWithoutActive_storage_blobsInput[]
    updateMany?: active_storage_attachmentsUpdateManyWithWhereWithoutActive_storage_blobsInput | active_storage_attachmentsUpdateManyWithWhereWithoutActive_storage_blobsInput[]
    deleteMany?: active_storage_attachmentsScalarWhereInput | active_storage_attachmentsScalarWhereInput[]
  }

  export type active_storage_variant_recordsUpdateManyWithoutActive_storage_blobsNestedInput = {
    create?: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_variant_recordsCreateWithoutActive_storage_blobsInput[] | active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput[]
    upsert?: active_storage_variant_recordsUpsertWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_variant_recordsUpsertWithWhereUniqueWithoutActive_storage_blobsInput[]
    createMany?: active_storage_variant_recordsCreateManyActive_storage_blobsInputEnvelope
    set?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    disconnect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    delete?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    connect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    update?: active_storage_variant_recordsUpdateWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_variant_recordsUpdateWithWhereUniqueWithoutActive_storage_blobsInput[]
    updateMany?: active_storage_variant_recordsUpdateManyWithWhereWithoutActive_storage_blobsInput | active_storage_variant_recordsUpdateManyWithWhereWithoutActive_storage_blobsInput[]
    deleteMany?: active_storage_variant_recordsScalarWhereInput | active_storage_variant_recordsScalarWhereInput[]
  }

  export type active_storage_attachmentsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput = {
    create?: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_attachmentsCreateWithoutActive_storage_blobsInput[] | active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput[]
    upsert?: active_storage_attachmentsUpsertWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_attachmentsUpsertWithWhereUniqueWithoutActive_storage_blobsInput[]
    createMany?: active_storage_attachmentsCreateManyActive_storage_blobsInputEnvelope
    set?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    disconnect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    delete?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    connect?: active_storage_attachmentsWhereUniqueInput | active_storage_attachmentsWhereUniqueInput[]
    update?: active_storage_attachmentsUpdateWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_attachmentsUpdateWithWhereUniqueWithoutActive_storage_blobsInput[]
    updateMany?: active_storage_attachmentsUpdateManyWithWhereWithoutActive_storage_blobsInput | active_storage_attachmentsUpdateManyWithWhereWithoutActive_storage_blobsInput[]
    deleteMany?: active_storage_attachmentsScalarWhereInput | active_storage_attachmentsScalarWhereInput[]
  }

  export type active_storage_variant_recordsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput = {
    create?: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput> | active_storage_variant_recordsCreateWithoutActive_storage_blobsInput[] | active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput[]
    connectOrCreate?: active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput | active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput[]
    upsert?: active_storage_variant_recordsUpsertWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_variant_recordsUpsertWithWhereUniqueWithoutActive_storage_blobsInput[]
    createMany?: active_storage_variant_recordsCreateManyActive_storage_blobsInputEnvelope
    set?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    disconnect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    delete?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    connect?: active_storage_variant_recordsWhereUniqueInput | active_storage_variant_recordsWhereUniqueInput[]
    update?: active_storage_variant_recordsUpdateWithWhereUniqueWithoutActive_storage_blobsInput | active_storage_variant_recordsUpdateWithWhereUniqueWithoutActive_storage_blobsInput[]
    updateMany?: active_storage_variant_recordsUpdateManyWithWhereWithoutActive_storage_blobsInput | active_storage_variant_recordsUpdateManyWithWhereWithoutActive_storage_blobsInput[]
    deleteMany?: active_storage_variant_recordsScalarWhereInput | active_storage_variant_recordsScalarWhereInput[]
  }

  export type active_storage_blobsCreateNestedOneWithoutActive_storage_variant_recordsInput = {
    create?: XOR<active_storage_blobsCreateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_variant_recordsInput>
    connectOrCreate?: active_storage_blobsCreateOrConnectWithoutActive_storage_variant_recordsInput
    connect?: active_storage_blobsWhereUniqueInput
  }

  export type active_storage_blobsUpdateOneRequiredWithoutActive_storage_variant_recordsNestedInput = {
    create?: XOR<active_storage_blobsCreateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_variant_recordsInput>
    connectOrCreate?: active_storage_blobsCreateOrConnectWithoutActive_storage_variant_recordsInput
    upsert?: active_storage_blobsUpsertWithoutActive_storage_variant_recordsInput
    connect?: active_storage_blobsWhereUniqueInput
    update?: XOR<XOR<active_storage_blobsUpdateToOneWithWhereWithoutActive_storage_variant_recordsInput, active_storage_blobsUpdateWithoutActive_storage_variant_recordsInput>, active_storage_blobsUncheckedUpdateWithoutActive_storage_variant_recordsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type accountsCreateNestedOneWithoutBalancesInput = {
    create?: XOR<accountsCreateWithoutBalancesInput, accountsUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutBalancesInput
    connect?: accountsWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type accountsUpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<accountsCreateWithoutBalancesInput, accountsUncheckedCreateWithoutBalancesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutBalancesInput
    upsert?: accountsUpsertWithoutBalancesInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutBalancesInput, accountsUpdateWithoutBalancesInput>, accountsUncheckedUpdateWithoutBalancesInput>
  }

  export type categoriesCreateNestedOneWithoutBudget_categoriesInput = {
    create?: XOR<categoriesCreateWithoutBudget_categoriesInput, categoriesUncheckedCreateWithoutBudget_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutBudget_categoriesInput
    connect?: categoriesWhereUniqueInput
  }

  export type budgetsCreateNestedOneWithoutBudget_categoriesInput = {
    create?: XOR<budgetsCreateWithoutBudget_categoriesInput, budgetsUncheckedCreateWithoutBudget_categoriesInput>
    connectOrCreate?: budgetsCreateOrConnectWithoutBudget_categoriesInput
    connect?: budgetsWhereUniqueInput
  }

  export type categoriesUpdateOneRequiredWithoutBudget_categoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutBudget_categoriesInput, categoriesUncheckedCreateWithoutBudget_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutBudget_categoriesInput
    upsert?: categoriesUpsertWithoutBudget_categoriesInput
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutBudget_categoriesInput, categoriesUpdateWithoutBudget_categoriesInput>, categoriesUncheckedUpdateWithoutBudget_categoriesInput>
  }

  export type budgetsUpdateOneRequiredWithoutBudget_categoriesNestedInput = {
    create?: XOR<budgetsCreateWithoutBudget_categoriesInput, budgetsUncheckedCreateWithoutBudget_categoriesInput>
    connectOrCreate?: budgetsCreateOrConnectWithoutBudget_categoriesInput
    upsert?: budgetsUpsertWithoutBudget_categoriesInput
    connect?: budgetsWhereUniqueInput
    update?: XOR<XOR<budgetsUpdateToOneWithWhereWithoutBudget_categoriesInput, budgetsUpdateWithoutBudget_categoriesInput>, budgetsUncheckedUpdateWithoutBudget_categoriesInput>
  }

  export type budget_categoriesCreateNestedManyWithoutBudgetsInput = {
    create?: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput> | budget_categoriesCreateWithoutBudgetsInput[] | budget_categoriesUncheckedCreateWithoutBudgetsInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutBudgetsInput | budget_categoriesCreateOrConnectWithoutBudgetsInput[]
    createMany?: budget_categoriesCreateManyBudgetsInputEnvelope
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<familiesCreateWithoutBudgetsInput, familiesUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutBudgetsInput
    connect?: familiesWhereUniqueInput
  }

  export type budget_categoriesUncheckedCreateNestedManyWithoutBudgetsInput = {
    create?: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput> | budget_categoriesCreateWithoutBudgetsInput[] | budget_categoriesUncheckedCreateWithoutBudgetsInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutBudgetsInput | budget_categoriesCreateOrConnectWithoutBudgetsInput[]
    createMany?: budget_categoriesCreateManyBudgetsInputEnvelope
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
  }

  export type budget_categoriesUpdateManyWithoutBudgetsNestedInput = {
    create?: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput> | budget_categoriesCreateWithoutBudgetsInput[] | budget_categoriesUncheckedCreateWithoutBudgetsInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutBudgetsInput | budget_categoriesCreateOrConnectWithoutBudgetsInput[]
    upsert?: budget_categoriesUpsertWithWhereUniqueWithoutBudgetsInput | budget_categoriesUpsertWithWhereUniqueWithoutBudgetsInput[]
    createMany?: budget_categoriesCreateManyBudgetsInputEnvelope
    set?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    disconnect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    delete?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    update?: budget_categoriesUpdateWithWhereUniqueWithoutBudgetsInput | budget_categoriesUpdateWithWhereUniqueWithoutBudgetsInput[]
    updateMany?: budget_categoriesUpdateManyWithWhereWithoutBudgetsInput | budget_categoriesUpdateManyWithWhereWithoutBudgetsInput[]
    deleteMany?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<familiesCreateWithoutBudgetsInput, familiesUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutBudgetsInput
    upsert?: familiesUpsertWithoutBudgetsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutBudgetsInput, familiesUpdateWithoutBudgetsInput>, familiesUncheckedUpdateWithoutBudgetsInput>
  }

  export type budget_categoriesUncheckedUpdateManyWithoutBudgetsNestedInput = {
    create?: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput> | budget_categoriesCreateWithoutBudgetsInput[] | budget_categoriesUncheckedCreateWithoutBudgetsInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutBudgetsInput | budget_categoriesCreateOrConnectWithoutBudgetsInput[]
    upsert?: budget_categoriesUpsertWithWhereUniqueWithoutBudgetsInput | budget_categoriesUpsertWithWhereUniqueWithoutBudgetsInput[]
    createMany?: budget_categoriesCreateManyBudgetsInputEnvelope
    set?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    disconnect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    delete?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    update?: budget_categoriesUpdateWithWhereUniqueWithoutBudgetsInput | budget_categoriesUpdateWithWhereUniqueWithoutBudgetsInput[]
    updateMany?: budget_categoriesUpdateManyWithWhereWithoutBudgetsInput | budget_categoriesUpdateManyWithWhereWithoutBudgetsInput[]
    deleteMany?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
  }

  export type budget_categoriesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput> | budget_categoriesCreateWithoutCategoriesInput[] | budget_categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutCategoriesInput | budget_categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: budget_categoriesCreateManyCategoriesInputEnvelope
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<familiesCreateWithoutCategoriesInput, familiesUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: familiesCreateOrConnectWithoutCategoriesInput
    connect?: familiesWhereUniqueInput
  }

  export type transactionsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput> | transactionsCreateWithoutCategoriesInput[] | transactionsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCategoriesInput | transactionsCreateOrConnectWithoutCategoriesInput[]
    createMany?: transactionsCreateManyCategoriesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type budget_categoriesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput> | budget_categoriesCreateWithoutCategoriesInput[] | budget_categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutCategoriesInput | budget_categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: budget_categoriesCreateManyCategoriesInputEnvelope
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput> | transactionsCreateWithoutCategoriesInput[] | transactionsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCategoriesInput | transactionsCreateOrConnectWithoutCategoriesInput[]
    createMany?: transactionsCreateManyCategoriesInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type budget_categoriesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput> | budget_categoriesCreateWithoutCategoriesInput[] | budget_categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutCategoriesInput | budget_categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: budget_categoriesUpsertWithWhereUniqueWithoutCategoriesInput | budget_categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: budget_categoriesCreateManyCategoriesInputEnvelope
    set?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    disconnect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    delete?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    update?: budget_categoriesUpdateWithWhereUniqueWithoutCategoriesInput | budget_categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: budget_categoriesUpdateManyWithWhereWithoutCategoriesInput | budget_categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<familiesCreateWithoutCategoriesInput, familiesUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: familiesCreateOrConnectWithoutCategoriesInput
    upsert?: familiesUpsertWithoutCategoriesInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutCategoriesInput, familiesUpdateWithoutCategoriesInput>, familiesUncheckedUpdateWithoutCategoriesInput>
  }

  export type transactionsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput> | transactionsCreateWithoutCategoriesInput[] | transactionsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCategoriesInput | transactionsCreateOrConnectWithoutCategoriesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCategoriesInput | transactionsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: transactionsCreateManyCategoriesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCategoriesInput | transactionsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCategoriesInput | transactionsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type budget_categoriesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput> | budget_categoriesCreateWithoutCategoriesInput[] | budget_categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: budget_categoriesCreateOrConnectWithoutCategoriesInput | budget_categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: budget_categoriesUpsertWithWhereUniqueWithoutCategoriesInput | budget_categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: budget_categoriesCreateManyCategoriesInputEnvelope
    set?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    disconnect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    delete?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    connect?: budget_categoriesWhereUniqueInput | budget_categoriesWhereUniqueInput[]
    update?: budget_categoriesUpdateWithWhereUniqueWithoutCategoriesInput | budget_categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: budget_categoriesUpdateManyWithWhereWithoutCategoriesInput | budget_categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput> | transactionsCreateWithoutCategoriesInput[] | transactionsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCategoriesInput | transactionsCreateOrConnectWithoutCategoriesInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCategoriesInput | transactionsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: transactionsCreateManyCategoriesInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCategoriesInput | transactionsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCategoriesInput | transactionsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutChats_chats_user_idTousersInput = {
    create?: XOR<usersCreateWithoutChats_chats_user_idTousersInput, usersUncheckedCreateWithoutChats_chats_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutChats_chats_user_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type messagesCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput = {
    create?: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput> | usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput[] | usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput | usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput[]
    createMany?: usersCreateManyChats_users_last_viewed_chat_idTochatsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput = {
    create?: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput> | usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput[] | usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput | usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput[]
    createMany?: usersCreateManyChats_users_last_viewed_chat_idTochatsInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutChats_chats_user_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutChats_chats_user_idTousersInput, usersUncheckedCreateWithoutChats_chats_user_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutChats_chats_user_idTousersInput
    upsert?: usersUpsertWithoutChats_chats_user_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChats_chats_user_idTousersInput, usersUpdateWithoutChats_chats_user_idTousersInput>, usersUncheckedUpdateWithoutChats_chats_user_idTousersInput>
  }

  export type messagesUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type usersUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput = {
    create?: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput> | usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput[] | usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput | usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpsertWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput[]
    createMany?: usersCreateManyChats_users_last_viewed_chat_idTochatsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpdateWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpdateManyWithWhereWithoutChats_users_last_viewed_chat_idTochatsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput = {
    create?: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput> | usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput[] | usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput[]
    connectOrCreate?: usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput | usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpsertWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput[]
    createMany?: usersCreateManyChats_users_last_viewed_chat_idTochatsInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpdateWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput[]
    updateMany?: usersUpdateManyWithWhereWithoutChats_users_last_viewed_chat_idTochatsInput | usersUpdateManyWithWhereWithoutChats_users_last_viewed_chat_idTochatsInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type accountsCreateNestedOneWithoutEntriesInput = {
    create?: XOR<accountsCreateWithoutEntriesInput, accountsUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutEntriesInput
    connect?: accountsWhereUniqueInput
  }

  export type importsCreateNestedOneWithoutEntriesInput = {
    create?: XOR<importsCreateWithoutEntriesInput, importsUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: importsCreateOrConnectWithoutEntriesInput
    connect?: importsWhereUniqueInput
  }

  export type accountsUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<accountsCreateWithoutEntriesInput, accountsUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: accountsCreateOrConnectWithoutEntriesInput
    upsert?: accountsUpsertWithoutEntriesInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutEntriesInput, accountsUpdateWithoutEntriesInput>, accountsUncheckedUpdateWithoutEntriesInput>
  }

  export type importsUpdateOneWithoutEntriesNestedInput = {
    create?: XOR<importsCreateWithoutEntriesInput, importsUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: importsCreateOrConnectWithoutEntriesInput
    upsert?: importsUpsertWithoutEntriesInput
    disconnect?: importsWhereInput | boolean
    delete?: importsWhereInput | boolean
    connect?: importsWhereUniqueInput
    update?: XOR<XOR<importsUpdateToOneWithWhereWithoutEntriesInput, importsUpdateWithoutEntriesInput>, importsUncheckedUpdateWithoutEntriesInput>
  }

  export type accountsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput> | accountsCreateWithoutFamiliesInput[] | accountsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutFamiliesInput | accountsCreateOrConnectWithoutFamiliesInput[]
    createMany?: accountsCreateManyFamiliesInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type budgetsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput> | budgetsCreateWithoutFamiliesInput[] | budgetsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: budgetsCreateOrConnectWithoutFamiliesInput | budgetsCreateOrConnectWithoutFamiliesInput[]
    createMany?: budgetsCreateManyFamiliesInputEnvelope
    connect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
  }

  export type categoriesCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput> | categoriesCreateWithoutFamiliesInput[] | categoriesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutFamiliesInput | categoriesCreateOrConnectWithoutFamiliesInput[]
    createMany?: categoriesCreateManyFamiliesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type importsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput> | importsCreateWithoutFamiliesInput[] | importsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: importsCreateOrConnectWithoutFamiliesInput | importsCreateOrConnectWithoutFamiliesInput[]
    createMany?: importsCreateManyFamiliesInputEnvelope
    connect?: importsWhereUniqueInput | importsWhereUniqueInput[]
  }

  export type invitationsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput> | invitationsCreateWithoutFamiliesInput[] | invitationsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutFamiliesInput | invitationsCreateOrConnectWithoutFamiliesInput[]
    createMany?: invitationsCreateManyFamiliesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type merchantsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput> | merchantsCreateWithoutFamiliesInput[] | merchantsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: merchantsCreateOrConnectWithoutFamiliesInput | merchantsCreateOrConnectWithoutFamiliesInput[]
    createMany?: merchantsCreateManyFamiliesInputEnvelope
    connect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
  }

  export type plaid_itemsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput> | plaid_itemsCreateWithoutFamiliesInput[] | plaid_itemsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutFamiliesInput | plaid_itemsCreateOrConnectWithoutFamiliesInput[]
    createMany?: plaid_itemsCreateManyFamiliesInputEnvelope
    connect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
  }

  export type rulesCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput> | rulesCreateWithoutFamiliesInput[] | rulesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: rulesCreateOrConnectWithoutFamiliesInput | rulesCreateOrConnectWithoutFamiliesInput[]
    createMany?: rulesCreateManyFamiliesInputEnvelope
    connect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
  }

  export type tagsCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput> | tagsCreateWithoutFamiliesInput[] | tagsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutFamiliesInput | tagsCreateOrConnectWithoutFamiliesInput[]
    createMany?: tagsCreateManyFamiliesInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput> | usersCreateWithoutFamiliesInput[] | usersUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFamiliesInput | usersCreateOrConnectWithoutFamiliesInput[]
    createMany?: usersCreateManyFamiliesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type accountsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput> | accountsCreateWithoutFamiliesInput[] | accountsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutFamiliesInput | accountsCreateOrConnectWithoutFamiliesInput[]
    createMany?: accountsCreateManyFamiliesInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type budgetsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput> | budgetsCreateWithoutFamiliesInput[] | budgetsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: budgetsCreateOrConnectWithoutFamiliesInput | budgetsCreateOrConnectWithoutFamiliesInput[]
    createMany?: budgetsCreateManyFamiliesInputEnvelope
    connect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput> | categoriesCreateWithoutFamiliesInput[] | categoriesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutFamiliesInput | categoriesCreateOrConnectWithoutFamiliesInput[]
    createMany?: categoriesCreateManyFamiliesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type importsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput> | importsCreateWithoutFamiliesInput[] | importsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: importsCreateOrConnectWithoutFamiliesInput | importsCreateOrConnectWithoutFamiliesInput[]
    createMany?: importsCreateManyFamiliesInputEnvelope
    connect?: importsWhereUniqueInput | importsWhereUniqueInput[]
  }

  export type invitationsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput> | invitationsCreateWithoutFamiliesInput[] | invitationsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutFamiliesInput | invitationsCreateOrConnectWithoutFamiliesInput[]
    createMany?: invitationsCreateManyFamiliesInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type merchantsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput> | merchantsCreateWithoutFamiliesInput[] | merchantsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: merchantsCreateOrConnectWithoutFamiliesInput | merchantsCreateOrConnectWithoutFamiliesInput[]
    createMany?: merchantsCreateManyFamiliesInputEnvelope
    connect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
  }

  export type plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput> | plaid_itemsCreateWithoutFamiliesInput[] | plaid_itemsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutFamiliesInput | plaid_itemsCreateOrConnectWithoutFamiliesInput[]
    createMany?: plaid_itemsCreateManyFamiliesInputEnvelope
    connect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
  }

  export type rulesUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput> | rulesCreateWithoutFamiliesInput[] | rulesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: rulesCreateOrConnectWithoutFamiliesInput | rulesCreateOrConnectWithoutFamiliesInput[]
    createMany?: rulesCreateManyFamiliesInputEnvelope
    connect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
  }

  export type tagsUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput> | tagsCreateWithoutFamiliesInput[] | tagsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutFamiliesInput | tagsCreateOrConnectWithoutFamiliesInput[]
    createMany?: tagsCreateManyFamiliesInputEnvelope
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutFamiliesInput = {
    create?: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput> | usersCreateWithoutFamiliesInput[] | usersUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFamiliesInput | usersCreateOrConnectWithoutFamiliesInput[]
    createMany?: usersCreateManyFamiliesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput> | accountsCreateWithoutFamiliesInput[] | accountsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutFamiliesInput | accountsCreateOrConnectWithoutFamiliesInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutFamiliesInput | accountsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: accountsCreateManyFamiliesInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutFamiliesInput | accountsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutFamiliesInput | accountsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type budgetsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput> | budgetsCreateWithoutFamiliesInput[] | budgetsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: budgetsCreateOrConnectWithoutFamiliesInput | budgetsCreateOrConnectWithoutFamiliesInput[]
    upsert?: budgetsUpsertWithWhereUniqueWithoutFamiliesInput | budgetsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: budgetsCreateManyFamiliesInputEnvelope
    set?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    disconnect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    delete?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    connect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    update?: budgetsUpdateWithWhereUniqueWithoutFamiliesInput | budgetsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: budgetsUpdateManyWithWhereWithoutFamiliesInput | budgetsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: budgetsScalarWhereInput | budgetsScalarWhereInput[]
  }

  export type categoriesUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput> | categoriesCreateWithoutFamiliesInput[] | categoriesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutFamiliesInput | categoriesCreateOrConnectWithoutFamiliesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutFamiliesInput | categoriesUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: categoriesCreateManyFamiliesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutFamiliesInput | categoriesUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutFamiliesInput | categoriesUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type importsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput> | importsCreateWithoutFamiliesInput[] | importsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: importsCreateOrConnectWithoutFamiliesInput | importsCreateOrConnectWithoutFamiliesInput[]
    upsert?: importsUpsertWithWhereUniqueWithoutFamiliesInput | importsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: importsCreateManyFamiliesInputEnvelope
    set?: importsWhereUniqueInput | importsWhereUniqueInput[]
    disconnect?: importsWhereUniqueInput | importsWhereUniqueInput[]
    delete?: importsWhereUniqueInput | importsWhereUniqueInput[]
    connect?: importsWhereUniqueInput | importsWhereUniqueInput[]
    update?: importsUpdateWithWhereUniqueWithoutFamiliesInput | importsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: importsUpdateManyWithWhereWithoutFamiliesInput | importsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: importsScalarWhereInput | importsScalarWhereInput[]
  }

  export type invitationsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput> | invitationsCreateWithoutFamiliesInput[] | invitationsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutFamiliesInput | invitationsCreateOrConnectWithoutFamiliesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutFamiliesInput | invitationsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: invitationsCreateManyFamiliesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutFamiliesInput | invitationsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutFamiliesInput | invitationsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type merchantsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput> | merchantsCreateWithoutFamiliesInput[] | merchantsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: merchantsCreateOrConnectWithoutFamiliesInput | merchantsCreateOrConnectWithoutFamiliesInput[]
    upsert?: merchantsUpsertWithWhereUniqueWithoutFamiliesInput | merchantsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: merchantsCreateManyFamiliesInputEnvelope
    set?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    disconnect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    delete?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    connect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    update?: merchantsUpdateWithWhereUniqueWithoutFamiliesInput | merchantsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: merchantsUpdateManyWithWhereWithoutFamiliesInput | merchantsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: merchantsScalarWhereInput | merchantsScalarWhereInput[]
  }

  export type plaid_itemsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput> | plaid_itemsCreateWithoutFamiliesInput[] | plaid_itemsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutFamiliesInput | plaid_itemsCreateOrConnectWithoutFamiliesInput[]
    upsert?: plaid_itemsUpsertWithWhereUniqueWithoutFamiliesInput | plaid_itemsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: plaid_itemsCreateManyFamiliesInputEnvelope
    set?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    disconnect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    delete?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    connect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    update?: plaid_itemsUpdateWithWhereUniqueWithoutFamiliesInput | plaid_itemsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: plaid_itemsUpdateManyWithWhereWithoutFamiliesInput | plaid_itemsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: plaid_itemsScalarWhereInput | plaid_itemsScalarWhereInput[]
  }

  export type rulesUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput> | rulesCreateWithoutFamiliesInput[] | rulesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: rulesCreateOrConnectWithoutFamiliesInput | rulesCreateOrConnectWithoutFamiliesInput[]
    upsert?: rulesUpsertWithWhereUniqueWithoutFamiliesInput | rulesUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: rulesCreateManyFamiliesInputEnvelope
    set?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    disconnect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    delete?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    connect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    update?: rulesUpdateWithWhereUniqueWithoutFamiliesInput | rulesUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: rulesUpdateManyWithWhereWithoutFamiliesInput | rulesUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: rulesScalarWhereInput | rulesScalarWhereInput[]
  }

  export type tagsUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput> | tagsCreateWithoutFamiliesInput[] | tagsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutFamiliesInput | tagsCreateOrConnectWithoutFamiliesInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutFamiliesInput | tagsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: tagsCreateManyFamiliesInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutFamiliesInput | tagsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutFamiliesInput | tagsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput> | usersCreateWithoutFamiliesInput[] | usersUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFamiliesInput | usersCreateOrConnectWithoutFamiliesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutFamiliesInput | usersUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: usersCreateManyFamiliesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutFamiliesInput | usersUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutFamiliesInput | usersUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type accountsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput> | accountsCreateWithoutFamiliesInput[] | accountsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutFamiliesInput | accountsCreateOrConnectWithoutFamiliesInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutFamiliesInput | accountsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: accountsCreateManyFamiliesInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutFamiliesInput | accountsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutFamiliesInput | accountsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type budgetsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput> | budgetsCreateWithoutFamiliesInput[] | budgetsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: budgetsCreateOrConnectWithoutFamiliesInput | budgetsCreateOrConnectWithoutFamiliesInput[]
    upsert?: budgetsUpsertWithWhereUniqueWithoutFamiliesInput | budgetsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: budgetsCreateManyFamiliesInputEnvelope
    set?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    disconnect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    delete?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    connect?: budgetsWhereUniqueInput | budgetsWhereUniqueInput[]
    update?: budgetsUpdateWithWhereUniqueWithoutFamiliesInput | budgetsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: budgetsUpdateManyWithWhereWithoutFamiliesInput | budgetsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: budgetsScalarWhereInput | budgetsScalarWhereInput[]
  }

  export type categoriesUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput> | categoriesCreateWithoutFamiliesInput[] | categoriesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutFamiliesInput | categoriesCreateOrConnectWithoutFamiliesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutFamiliesInput | categoriesUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: categoriesCreateManyFamiliesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutFamiliesInput | categoriesUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutFamiliesInput | categoriesUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type importsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput> | importsCreateWithoutFamiliesInput[] | importsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: importsCreateOrConnectWithoutFamiliesInput | importsCreateOrConnectWithoutFamiliesInput[]
    upsert?: importsUpsertWithWhereUniqueWithoutFamiliesInput | importsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: importsCreateManyFamiliesInputEnvelope
    set?: importsWhereUniqueInput | importsWhereUniqueInput[]
    disconnect?: importsWhereUniqueInput | importsWhereUniqueInput[]
    delete?: importsWhereUniqueInput | importsWhereUniqueInput[]
    connect?: importsWhereUniqueInput | importsWhereUniqueInput[]
    update?: importsUpdateWithWhereUniqueWithoutFamiliesInput | importsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: importsUpdateManyWithWhereWithoutFamiliesInput | importsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: importsScalarWhereInput | importsScalarWhereInput[]
  }

  export type invitationsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput> | invitationsCreateWithoutFamiliesInput[] | invitationsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutFamiliesInput | invitationsCreateOrConnectWithoutFamiliesInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutFamiliesInput | invitationsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: invitationsCreateManyFamiliesInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutFamiliesInput | invitationsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutFamiliesInput | invitationsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type merchantsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput> | merchantsCreateWithoutFamiliesInput[] | merchantsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: merchantsCreateOrConnectWithoutFamiliesInput | merchantsCreateOrConnectWithoutFamiliesInput[]
    upsert?: merchantsUpsertWithWhereUniqueWithoutFamiliesInput | merchantsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: merchantsCreateManyFamiliesInputEnvelope
    set?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    disconnect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    delete?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    connect?: merchantsWhereUniqueInput | merchantsWhereUniqueInput[]
    update?: merchantsUpdateWithWhereUniqueWithoutFamiliesInput | merchantsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: merchantsUpdateManyWithWhereWithoutFamiliesInput | merchantsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: merchantsScalarWhereInput | merchantsScalarWhereInput[]
  }

  export type plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput> | plaid_itemsCreateWithoutFamiliesInput[] | plaid_itemsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutFamiliesInput | plaid_itemsCreateOrConnectWithoutFamiliesInput[]
    upsert?: plaid_itemsUpsertWithWhereUniqueWithoutFamiliesInput | plaid_itemsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: plaid_itemsCreateManyFamiliesInputEnvelope
    set?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    disconnect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    delete?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    connect?: plaid_itemsWhereUniqueInput | plaid_itemsWhereUniqueInput[]
    update?: plaid_itemsUpdateWithWhereUniqueWithoutFamiliesInput | plaid_itemsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: plaid_itemsUpdateManyWithWhereWithoutFamiliesInput | plaid_itemsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: plaid_itemsScalarWhereInput | plaid_itemsScalarWhereInput[]
  }

  export type rulesUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput> | rulesCreateWithoutFamiliesInput[] | rulesUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: rulesCreateOrConnectWithoutFamiliesInput | rulesCreateOrConnectWithoutFamiliesInput[]
    upsert?: rulesUpsertWithWhereUniqueWithoutFamiliesInput | rulesUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: rulesCreateManyFamiliesInputEnvelope
    set?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    disconnect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    delete?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    connect?: rulesWhereUniqueInput | rulesWhereUniqueInput[]
    update?: rulesUpdateWithWhereUniqueWithoutFamiliesInput | rulesUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: rulesUpdateManyWithWhereWithoutFamiliesInput | rulesUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: rulesScalarWhereInput | rulesScalarWhereInput[]
  }

  export type tagsUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput> | tagsCreateWithoutFamiliesInput[] | tagsUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: tagsCreateOrConnectWithoutFamiliesInput | tagsCreateOrConnectWithoutFamiliesInput[]
    upsert?: tagsUpsertWithWhereUniqueWithoutFamiliesInput | tagsUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: tagsCreateManyFamiliesInputEnvelope
    set?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    disconnect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    delete?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    connect?: tagsWhereUniqueInput | tagsWhereUniqueInput[]
    update?: tagsUpdateWithWhereUniqueWithoutFamiliesInput | tagsUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: tagsUpdateManyWithWhereWithoutFamiliesInput | tagsUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: tagsScalarWhereInput | tagsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutFamiliesNestedInput = {
    create?: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput> | usersCreateWithoutFamiliesInput[] | usersUncheckedCreateWithoutFamiliesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutFamiliesInput | usersCreateOrConnectWithoutFamiliesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutFamiliesInput | usersUpsertWithWhereUniqueWithoutFamiliesInput[]
    createMany?: usersCreateManyFamiliesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutFamiliesInput | usersUpdateWithWhereUniqueWithoutFamiliesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutFamiliesInput | usersUpdateManyWithWhereWithoutFamiliesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type securitiesCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<securitiesCreateWithoutHoldingsInput, securitiesUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutHoldingsInput
    connect?: securitiesWhereUniqueInput
  }

  export type accountsCreateNestedOneWithoutHoldingsInput = {
    create?: XOR<accountsCreateWithoutHoldingsInput, accountsUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutHoldingsInput
    connect?: accountsWhereUniqueInput
  }

  export type securitiesUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<securitiesCreateWithoutHoldingsInput, securitiesUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutHoldingsInput
    upsert?: securitiesUpsertWithoutHoldingsInput
    connect?: securitiesWhereUniqueInput
    update?: XOR<XOR<securitiesUpdateToOneWithWhereWithoutHoldingsInput, securitiesUpdateWithoutHoldingsInput>, securitiesUncheckedUpdateWithoutHoldingsInput>
  }

  export type accountsUpdateOneRequiredWithoutHoldingsNestedInput = {
    create?: XOR<accountsCreateWithoutHoldingsInput, accountsUncheckedCreateWithoutHoldingsInput>
    connectOrCreate?: accountsCreateOrConnectWithoutHoldingsInput
    upsert?: accountsUpsertWithoutHoldingsInput
    connect?: accountsWhereUniqueInput
    update?: XOR<XOR<accountsUpdateToOneWithWhereWithoutHoldingsInput, accountsUpdateWithoutHoldingsInput>, accountsUncheckedUpdateWithoutHoldingsInput>
  }

  export type impersonation_sessionsCreateNestedOneWithoutImpersonation_session_logsInput = {
    create?: XOR<impersonation_sessionsCreateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedCreateWithoutImpersonation_session_logsInput>
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutImpersonation_session_logsInput
    connect?: impersonation_sessionsWhereUniqueInput
  }

  export type impersonation_sessionsUpdateOneRequiredWithoutImpersonation_session_logsNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedCreateWithoutImpersonation_session_logsInput>
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutImpersonation_session_logsInput
    upsert?: impersonation_sessionsUpsertWithoutImpersonation_session_logsInput
    connect?: impersonation_sessionsWhereUniqueInput
    update?: XOR<XOR<impersonation_sessionsUpdateToOneWithWhereWithoutImpersonation_session_logsInput, impersonation_sessionsUpdateWithoutImpersonation_session_logsInput>, impersonation_sessionsUncheckedUpdateWithoutImpersonation_session_logsInput>
  }

  export type impersonation_session_logsCreateNestedManyWithoutImpersonation_sessionsInput = {
    create?: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput> | impersonation_session_logsCreateWithoutImpersonation_sessionsInput[] | impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput | impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput[]
    createMany?: impersonation_session_logsCreateManyImpersonation_sessionsInputEnvelope
    connect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    create?: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    create?: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type sessionsCreateNestedManyWithoutImpersonation_sessionsInput = {
    create?: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput> | sessionsCreateWithoutImpersonation_sessionsInput[] | sessionsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutImpersonation_sessionsInput | sessionsCreateOrConnectWithoutImpersonation_sessionsInput[]
    createMany?: sessionsCreateManyImpersonation_sessionsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type impersonation_session_logsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput = {
    create?: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput> | impersonation_session_logsCreateWithoutImpersonation_sessionsInput[] | impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput | impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput[]
    createMany?: impersonation_session_logsCreateManyImpersonation_sessionsInputEnvelope
    connect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput = {
    create?: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput> | sessionsCreateWithoutImpersonation_sessionsInput[] | sessionsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutImpersonation_sessionsInput | sessionsCreateOrConnectWithoutImpersonation_sessionsInput[]
    createMany?: sessionsCreateManyImpersonation_sessionsInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type impersonation_session_logsUpdateManyWithoutImpersonation_sessionsNestedInput = {
    create?: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput> | impersonation_session_logsCreateWithoutImpersonation_sessionsInput[] | impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput | impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput[]
    upsert?: impersonation_session_logsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput | impersonation_session_logsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput[]
    createMany?: impersonation_session_logsCreateManyImpersonation_sessionsInputEnvelope
    set?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    disconnect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    delete?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    connect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    update?: impersonation_session_logsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput | impersonation_session_logsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput[]
    updateMany?: impersonation_session_logsUpdateManyWithWhereWithoutImpersonation_sessionsInput | impersonation_session_logsUpdateManyWithWhereWithoutImpersonation_sessionsInput[]
    deleteMany?: impersonation_session_logsScalarWhereInput | impersonation_session_logsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    upsert?: usersUpsertWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
  }

  export type usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    upsert?: usersUpsertWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
  }

  export type sessionsUpdateManyWithoutImpersonation_sessionsNestedInput = {
    create?: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput> | sessionsCreateWithoutImpersonation_sessionsInput[] | sessionsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutImpersonation_sessionsInput | sessionsCreateOrConnectWithoutImpersonation_sessionsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput | sessionsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput[]
    createMany?: sessionsCreateManyImpersonation_sessionsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput | sessionsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutImpersonation_sessionsInput | sessionsUpdateManyWithWhereWithoutImpersonation_sessionsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput = {
    create?: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput> | impersonation_session_logsCreateWithoutImpersonation_sessionsInput[] | impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput | impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput[]
    upsert?: impersonation_session_logsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput | impersonation_session_logsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput[]
    createMany?: impersonation_session_logsCreateManyImpersonation_sessionsInputEnvelope
    set?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    disconnect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    delete?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    connect?: impersonation_session_logsWhereUniqueInput | impersonation_session_logsWhereUniqueInput[]
    update?: impersonation_session_logsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput | impersonation_session_logsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput[]
    updateMany?: impersonation_session_logsUpdateManyWithWhereWithoutImpersonation_sessionsInput | impersonation_session_logsUpdateManyWithWhereWithoutImpersonation_sessionsInput[]
    deleteMany?: impersonation_session_logsScalarWhereInput | impersonation_session_logsScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput = {
    create?: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput> | sessionsCreateWithoutImpersonation_sessionsInput[] | sessionsUncheckedCreateWithoutImpersonation_sessionsInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutImpersonation_sessionsInput | sessionsCreateOrConnectWithoutImpersonation_sessionsInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput | sessionsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput[]
    createMany?: sessionsCreateManyImpersonation_sessionsInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput | sessionsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutImpersonation_sessionsInput | sessionsUpdateManyWithWhereWithoutImpersonation_sessionsInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type importsCreateNestedOneWithoutImport_rowsInput = {
    create?: XOR<importsCreateWithoutImport_rowsInput, importsUncheckedCreateWithoutImport_rowsInput>
    connectOrCreate?: importsCreateOrConnectWithoutImport_rowsInput
    connect?: importsWhereUniqueInput
  }

  export type importsUpdateOneRequiredWithoutImport_rowsNestedInput = {
    create?: XOR<importsCreateWithoutImport_rowsInput, importsUncheckedCreateWithoutImport_rowsInput>
    connectOrCreate?: importsCreateOrConnectWithoutImport_rowsInput
    upsert?: importsUpsertWithoutImport_rowsInput
    connect?: importsWhereUniqueInput
    update?: XOR<XOR<importsUpdateToOneWithWhereWithoutImport_rowsInput, importsUpdateWithoutImport_rowsInput>, importsUncheckedUpdateWithoutImport_rowsInput>
  }

  export type accountsCreateNestedManyWithoutImportsInput = {
    create?: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput> | accountsCreateWithoutImportsInput[] | accountsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutImportsInput | accountsCreateOrConnectWithoutImportsInput[]
    createMany?: accountsCreateManyImportsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type entriesCreateNestedManyWithoutImportsInput = {
    create?: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput> | entriesCreateWithoutImportsInput[] | entriesUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutImportsInput | entriesCreateOrConnectWithoutImportsInput[]
    createMany?: entriesCreateManyImportsInputEnvelope
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
  }

  export type import_rowsCreateNestedManyWithoutImportsInput = {
    create?: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput> | import_rowsCreateWithoutImportsInput[] | import_rowsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: import_rowsCreateOrConnectWithoutImportsInput | import_rowsCreateOrConnectWithoutImportsInput[]
    createMany?: import_rowsCreateManyImportsInputEnvelope
    connect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutImportsInput = {
    create?: XOR<familiesCreateWithoutImportsInput, familiesUncheckedCreateWithoutImportsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutImportsInput
    connect?: familiesWhereUniqueInput
  }

  export type accountsUncheckedCreateNestedManyWithoutImportsInput = {
    create?: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput> | accountsCreateWithoutImportsInput[] | accountsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutImportsInput | accountsCreateOrConnectWithoutImportsInput[]
    createMany?: accountsCreateManyImportsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type entriesUncheckedCreateNestedManyWithoutImportsInput = {
    create?: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput> | entriesCreateWithoutImportsInput[] | entriesUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutImportsInput | entriesCreateOrConnectWithoutImportsInput[]
    createMany?: entriesCreateManyImportsInputEnvelope
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
  }

  export type import_rowsUncheckedCreateNestedManyWithoutImportsInput = {
    create?: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput> | import_rowsCreateWithoutImportsInput[] | import_rowsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: import_rowsCreateOrConnectWithoutImportsInput | import_rowsCreateOrConnectWithoutImportsInput[]
    createMany?: import_rowsCreateManyImportsInputEnvelope
    connect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutImportsNestedInput = {
    create?: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput> | accountsCreateWithoutImportsInput[] | accountsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutImportsInput | accountsCreateOrConnectWithoutImportsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutImportsInput | accountsUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: accountsCreateManyImportsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutImportsInput | accountsUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutImportsInput | accountsUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type entriesUpdateManyWithoutImportsNestedInput = {
    create?: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput> | entriesCreateWithoutImportsInput[] | entriesUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutImportsInput | entriesCreateOrConnectWithoutImportsInput[]
    upsert?: entriesUpsertWithWhereUniqueWithoutImportsInput | entriesUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: entriesCreateManyImportsInputEnvelope
    set?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    disconnect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    delete?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    update?: entriesUpdateWithWhereUniqueWithoutImportsInput | entriesUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: entriesUpdateManyWithWhereWithoutImportsInput | entriesUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: entriesScalarWhereInput | entriesScalarWhereInput[]
  }

  export type import_rowsUpdateManyWithoutImportsNestedInput = {
    create?: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput> | import_rowsCreateWithoutImportsInput[] | import_rowsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: import_rowsCreateOrConnectWithoutImportsInput | import_rowsCreateOrConnectWithoutImportsInput[]
    upsert?: import_rowsUpsertWithWhereUniqueWithoutImportsInput | import_rowsUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: import_rowsCreateManyImportsInputEnvelope
    set?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    disconnect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    delete?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    connect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    update?: import_rowsUpdateWithWhereUniqueWithoutImportsInput | import_rowsUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: import_rowsUpdateManyWithWhereWithoutImportsInput | import_rowsUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: import_rowsScalarWhereInput | import_rowsScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutImportsNestedInput = {
    create?: XOR<familiesCreateWithoutImportsInput, familiesUncheckedCreateWithoutImportsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutImportsInput
    upsert?: familiesUpsertWithoutImportsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutImportsInput, familiesUpdateWithoutImportsInput>, familiesUncheckedUpdateWithoutImportsInput>
  }

  export type accountsUncheckedUpdateManyWithoutImportsNestedInput = {
    create?: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput> | accountsCreateWithoutImportsInput[] | accountsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutImportsInput | accountsCreateOrConnectWithoutImportsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutImportsInput | accountsUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: accountsCreateManyImportsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutImportsInput | accountsUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutImportsInput | accountsUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type entriesUncheckedUpdateManyWithoutImportsNestedInput = {
    create?: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput> | entriesCreateWithoutImportsInput[] | entriesUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: entriesCreateOrConnectWithoutImportsInput | entriesCreateOrConnectWithoutImportsInput[]
    upsert?: entriesUpsertWithWhereUniqueWithoutImportsInput | entriesUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: entriesCreateManyImportsInputEnvelope
    set?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    disconnect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    delete?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    connect?: entriesWhereUniqueInput | entriesWhereUniqueInput[]
    update?: entriesUpdateWithWhereUniqueWithoutImportsInput | entriesUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: entriesUpdateManyWithWhereWithoutImportsInput | entriesUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: entriesScalarWhereInput | entriesScalarWhereInput[]
  }

  export type import_rowsUncheckedUpdateManyWithoutImportsNestedInput = {
    create?: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput> | import_rowsCreateWithoutImportsInput[] | import_rowsUncheckedCreateWithoutImportsInput[]
    connectOrCreate?: import_rowsCreateOrConnectWithoutImportsInput | import_rowsCreateOrConnectWithoutImportsInput[]
    upsert?: import_rowsUpsertWithWhereUniqueWithoutImportsInput | import_rowsUpsertWithWhereUniqueWithoutImportsInput[]
    createMany?: import_rowsCreateManyImportsInputEnvelope
    set?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    disconnect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    delete?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    connect?: import_rowsWhereUniqueInput | import_rowsWhereUniqueInput[]
    update?: import_rowsUpdateWithWhereUniqueWithoutImportsInput | import_rowsUpdateWithWhereUniqueWithoutImportsInput[]
    updateMany?: import_rowsUpdateManyWithWhereWithoutImportsInput | import_rowsUpdateManyWithWhereWithoutImportsInput[]
    deleteMany?: import_rowsScalarWhereInput | import_rowsScalarWhereInput[]
  }

  export type familiesCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<familiesCreateWithoutInvitationsInput, familiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutInvitationsInput
    connect?: familiesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<usersCreateWithoutInvitationsInput, usersUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvitationsInput
    connect?: usersWhereUniqueInput
  }

  export type familiesUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<familiesCreateWithoutInvitationsInput, familiesUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutInvitationsInput
    upsert?: familiesUpsertWithoutInvitationsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutInvitationsInput, familiesUpdateWithoutInvitationsInput>, familiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type usersUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<usersCreateWithoutInvitationsInput, usersUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvitationsInput
    upsert?: usersUpsertWithoutInvitationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInvitationsInput, usersUpdateWithoutInvitationsInput>, usersUncheckedUpdateWithoutInvitationsInput>
  }

  export type familiesCreateNestedOneWithoutMerchantsInput = {
    create?: XOR<familiesCreateWithoutMerchantsInput, familiesUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutMerchantsInput
    connect?: familiesWhereUniqueInput
  }

  export type transactionsCreateNestedManyWithoutMerchantsInput = {
    create?: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput> | transactionsCreateWithoutMerchantsInput[] | transactionsUncheckedCreateWithoutMerchantsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutMerchantsInput | transactionsCreateOrConnectWithoutMerchantsInput[]
    createMany?: transactionsCreateManyMerchantsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutMerchantsInput = {
    create?: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput> | transactionsCreateWithoutMerchantsInput[] | transactionsUncheckedCreateWithoutMerchantsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutMerchantsInput | transactionsCreateOrConnectWithoutMerchantsInput[]
    createMany?: transactionsCreateManyMerchantsInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type familiesUpdateOneWithoutMerchantsNestedInput = {
    create?: XOR<familiesCreateWithoutMerchantsInput, familiesUncheckedCreateWithoutMerchantsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutMerchantsInput
    upsert?: familiesUpsertWithoutMerchantsInput
    disconnect?: familiesWhereInput | boolean
    delete?: familiesWhereInput | boolean
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutMerchantsInput, familiesUpdateWithoutMerchantsInput>, familiesUncheckedUpdateWithoutMerchantsInput>
  }

  export type transactionsUpdateManyWithoutMerchantsNestedInput = {
    create?: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput> | transactionsCreateWithoutMerchantsInput[] | transactionsUncheckedCreateWithoutMerchantsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutMerchantsInput | transactionsCreateOrConnectWithoutMerchantsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutMerchantsInput | transactionsUpsertWithWhereUniqueWithoutMerchantsInput[]
    createMany?: transactionsCreateManyMerchantsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutMerchantsInput | transactionsUpdateWithWhereUniqueWithoutMerchantsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutMerchantsInput | transactionsUpdateManyWithWhereWithoutMerchantsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutMerchantsNestedInput = {
    create?: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput> | transactionsCreateWithoutMerchantsInput[] | transactionsUncheckedCreateWithoutMerchantsInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutMerchantsInput | transactionsCreateOrConnectWithoutMerchantsInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutMerchantsInput | transactionsUpsertWithWhereUniqueWithoutMerchantsInput[]
    createMany?: transactionsCreateManyMerchantsInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutMerchantsInput | transactionsUpdateWithWhereUniqueWithoutMerchantsInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutMerchantsInput | transactionsUpdateManyWithWhereWithoutMerchantsInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type chatsCreateNestedOneWithoutMessagesInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    connect?: chatsWhereUniqueInput
  }

  export type tool_callsCreateNestedManyWithoutMessagesInput = {
    create?: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput> | tool_callsCreateWithoutMessagesInput[] | tool_callsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: tool_callsCreateOrConnectWithoutMessagesInput | tool_callsCreateOrConnectWithoutMessagesInput[]
    createMany?: tool_callsCreateManyMessagesInputEnvelope
    connect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
  }

  export type tool_callsUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput> | tool_callsCreateWithoutMessagesInput[] | tool_callsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: tool_callsCreateOrConnectWithoutMessagesInput | tool_callsCreateOrConnectWithoutMessagesInput[]
    createMany?: tool_callsCreateManyMessagesInputEnvelope
    connect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
  }

  export type chatsUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    upsert?: chatsUpsertWithoutMessagesInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutMessagesInput, chatsUpdateWithoutMessagesInput>, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type tool_callsUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput> | tool_callsCreateWithoutMessagesInput[] | tool_callsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: tool_callsCreateOrConnectWithoutMessagesInput | tool_callsCreateOrConnectWithoutMessagesInput[]
    upsert?: tool_callsUpsertWithWhereUniqueWithoutMessagesInput | tool_callsUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: tool_callsCreateManyMessagesInputEnvelope
    set?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    disconnect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    delete?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    connect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    update?: tool_callsUpdateWithWhereUniqueWithoutMessagesInput | tool_callsUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: tool_callsUpdateManyWithWhereWithoutMessagesInput | tool_callsUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: tool_callsScalarWhereInput | tool_callsScalarWhereInput[]
  }

  export type tool_callsUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput> | tool_callsCreateWithoutMessagesInput[] | tool_callsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: tool_callsCreateOrConnectWithoutMessagesInput | tool_callsCreateOrConnectWithoutMessagesInput[]
    upsert?: tool_callsUpsertWithWhereUniqueWithoutMessagesInput | tool_callsUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: tool_callsCreateManyMessagesInputEnvelope
    set?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    disconnect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    delete?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    connect?: tool_callsWhereUniqueInput | tool_callsWhereUniqueInput[]
    update?: tool_callsUpdateWithWhereUniqueWithoutMessagesInput | tool_callsUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: tool_callsUpdateManyWithWhereWithoutMessagesInput | tool_callsUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: tool_callsScalarWhereInput | tool_callsScalarWhereInput[]
  }

  export type accountsCreateNestedManyWithoutPlaid_accountsInput = {
    create?: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput> | accountsCreateWithoutPlaid_accountsInput[] | accountsUncheckedCreateWithoutPlaid_accountsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutPlaid_accountsInput | accountsCreateOrConnectWithoutPlaid_accountsInput[]
    createMany?: accountsCreateManyPlaid_accountsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type plaid_itemsCreateNestedOneWithoutPlaid_accountsInput = {
    create?: XOR<plaid_itemsCreateWithoutPlaid_accountsInput, plaid_itemsUncheckedCreateWithoutPlaid_accountsInput>
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutPlaid_accountsInput
    connect?: plaid_itemsWhereUniqueInput
  }

  export type accountsUncheckedCreateNestedManyWithoutPlaid_accountsInput = {
    create?: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput> | accountsCreateWithoutPlaid_accountsInput[] | accountsUncheckedCreateWithoutPlaid_accountsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutPlaid_accountsInput | accountsCreateOrConnectWithoutPlaid_accountsInput[]
    createMany?: accountsCreateManyPlaid_accountsInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type accountsUpdateManyWithoutPlaid_accountsNestedInput = {
    create?: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput> | accountsCreateWithoutPlaid_accountsInput[] | accountsUncheckedCreateWithoutPlaid_accountsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutPlaid_accountsInput | accountsCreateOrConnectWithoutPlaid_accountsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutPlaid_accountsInput | accountsUpsertWithWhereUniqueWithoutPlaid_accountsInput[]
    createMany?: accountsCreateManyPlaid_accountsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutPlaid_accountsInput | accountsUpdateWithWhereUniqueWithoutPlaid_accountsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutPlaid_accountsInput | accountsUpdateManyWithWhereWithoutPlaid_accountsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type plaid_itemsUpdateOneRequiredWithoutPlaid_accountsNestedInput = {
    create?: XOR<plaid_itemsCreateWithoutPlaid_accountsInput, plaid_itemsUncheckedCreateWithoutPlaid_accountsInput>
    connectOrCreate?: plaid_itemsCreateOrConnectWithoutPlaid_accountsInput
    upsert?: plaid_itemsUpsertWithoutPlaid_accountsInput
    connect?: plaid_itemsWhereUniqueInput
    update?: XOR<XOR<plaid_itemsUpdateToOneWithWhereWithoutPlaid_accountsInput, plaid_itemsUpdateWithoutPlaid_accountsInput>, plaid_itemsUncheckedUpdateWithoutPlaid_accountsInput>
  }

  export type accountsUncheckedUpdateManyWithoutPlaid_accountsNestedInput = {
    create?: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput> | accountsCreateWithoutPlaid_accountsInput[] | accountsUncheckedCreateWithoutPlaid_accountsInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutPlaid_accountsInput | accountsCreateOrConnectWithoutPlaid_accountsInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutPlaid_accountsInput | accountsUpsertWithWhereUniqueWithoutPlaid_accountsInput[]
    createMany?: accountsCreateManyPlaid_accountsInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutPlaid_accountsInput | accountsUpdateWithWhereUniqueWithoutPlaid_accountsInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutPlaid_accountsInput | accountsUpdateManyWithWhereWithoutPlaid_accountsInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type plaid_itemsCreateavailable_productsInput = {
    set: string[]
  }

  export type plaid_itemsCreatebilled_productsInput = {
    set: string[]
  }

  export type plaid_accountsCreateNestedManyWithoutPlaid_itemsInput = {
    create?: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput> | plaid_accountsCreateWithoutPlaid_itemsInput[] | plaid_accountsUncheckedCreateWithoutPlaid_itemsInput[]
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutPlaid_itemsInput | plaid_accountsCreateOrConnectWithoutPlaid_itemsInput[]
    createMany?: plaid_accountsCreateManyPlaid_itemsInputEnvelope
    connect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutPlaid_itemsInput = {
    create?: XOR<familiesCreateWithoutPlaid_itemsInput, familiesUncheckedCreateWithoutPlaid_itemsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutPlaid_itemsInput
    connect?: familiesWhereUniqueInput
  }

  export type plaid_accountsUncheckedCreateNestedManyWithoutPlaid_itemsInput = {
    create?: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput> | plaid_accountsCreateWithoutPlaid_itemsInput[] | plaid_accountsUncheckedCreateWithoutPlaid_itemsInput[]
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutPlaid_itemsInput | plaid_accountsCreateOrConnectWithoutPlaid_itemsInput[]
    createMany?: plaid_accountsCreateManyPlaid_itemsInputEnvelope
    connect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
  }

  export type plaid_itemsUpdateavailable_productsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type plaid_itemsUpdatebilled_productsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type plaid_accountsUpdateManyWithoutPlaid_itemsNestedInput = {
    create?: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput> | plaid_accountsCreateWithoutPlaid_itemsInput[] | plaid_accountsUncheckedCreateWithoutPlaid_itemsInput[]
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutPlaid_itemsInput | plaid_accountsCreateOrConnectWithoutPlaid_itemsInput[]
    upsert?: plaid_accountsUpsertWithWhereUniqueWithoutPlaid_itemsInput | plaid_accountsUpsertWithWhereUniqueWithoutPlaid_itemsInput[]
    createMany?: plaid_accountsCreateManyPlaid_itemsInputEnvelope
    set?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    disconnect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    delete?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    connect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    update?: plaid_accountsUpdateWithWhereUniqueWithoutPlaid_itemsInput | plaid_accountsUpdateWithWhereUniqueWithoutPlaid_itemsInput[]
    updateMany?: plaid_accountsUpdateManyWithWhereWithoutPlaid_itemsInput | plaid_accountsUpdateManyWithWhereWithoutPlaid_itemsInput[]
    deleteMany?: plaid_accountsScalarWhereInput | plaid_accountsScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutPlaid_itemsNestedInput = {
    create?: XOR<familiesCreateWithoutPlaid_itemsInput, familiesUncheckedCreateWithoutPlaid_itemsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutPlaid_itemsInput
    upsert?: familiesUpsertWithoutPlaid_itemsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutPlaid_itemsInput, familiesUpdateWithoutPlaid_itemsInput>, familiesUncheckedUpdateWithoutPlaid_itemsInput>
  }

  export type plaid_accountsUncheckedUpdateManyWithoutPlaid_itemsNestedInput = {
    create?: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput> | plaid_accountsCreateWithoutPlaid_itemsInput[] | plaid_accountsUncheckedCreateWithoutPlaid_itemsInput[]
    connectOrCreate?: plaid_accountsCreateOrConnectWithoutPlaid_itemsInput | plaid_accountsCreateOrConnectWithoutPlaid_itemsInput[]
    upsert?: plaid_accountsUpsertWithWhereUniqueWithoutPlaid_itemsInput | plaid_accountsUpsertWithWhereUniqueWithoutPlaid_itemsInput[]
    createMany?: plaid_accountsCreateManyPlaid_itemsInputEnvelope
    set?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    disconnect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    delete?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    connect?: plaid_accountsWhereUniqueInput | plaid_accountsWhereUniqueInput[]
    update?: plaid_accountsUpdateWithWhereUniqueWithoutPlaid_itemsInput | plaid_accountsUpdateWithWhereUniqueWithoutPlaid_itemsInput[]
    updateMany?: plaid_accountsUpdateManyWithWhereWithoutPlaid_itemsInput | plaid_accountsUpdateManyWithWhereWithoutPlaid_itemsInput[]
    deleteMany?: plaid_accountsScalarWhereInput | plaid_accountsScalarWhereInput[]
  }

  export type transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput
    upsert?: transactionsUpsertWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput
    upsert?: transactionsUpsertWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type rulesCreateNestedOneWithoutRule_actionsInput = {
    create?: XOR<rulesCreateWithoutRule_actionsInput, rulesUncheckedCreateWithoutRule_actionsInput>
    connectOrCreate?: rulesCreateOrConnectWithoutRule_actionsInput
    connect?: rulesWhereUniqueInput
  }

  export type rulesUpdateOneRequiredWithoutRule_actionsNestedInput = {
    create?: XOR<rulesCreateWithoutRule_actionsInput, rulesUncheckedCreateWithoutRule_actionsInput>
    connectOrCreate?: rulesCreateOrConnectWithoutRule_actionsInput
    upsert?: rulesUpsertWithoutRule_actionsInput
    connect?: rulesWhereUniqueInput
    update?: XOR<XOR<rulesUpdateToOneWithWhereWithoutRule_actionsInput, rulesUpdateWithoutRule_actionsInput>, rulesUncheckedUpdateWithoutRule_actionsInput>
  }

  export type rule_conditionsCreateNestedOneWithoutOther_rule_conditionsInput = {
    create?: XOR<rule_conditionsCreateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedCreateWithoutOther_rule_conditionsInput>
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutOther_rule_conditionsInput
    connect?: rule_conditionsWhereUniqueInput
  }

  export type rule_conditionsCreateNestedManyWithoutRule_conditionsInput = {
    create?: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput> | rule_conditionsCreateWithoutRule_conditionsInput[] | rule_conditionsUncheckedCreateWithoutRule_conditionsInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRule_conditionsInput | rule_conditionsCreateOrConnectWithoutRule_conditionsInput[]
    createMany?: rule_conditionsCreateManyRule_conditionsInputEnvelope
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
  }

  export type rulesCreateNestedOneWithoutRule_conditionsInput = {
    create?: XOR<rulesCreateWithoutRule_conditionsInput, rulesUncheckedCreateWithoutRule_conditionsInput>
    connectOrCreate?: rulesCreateOrConnectWithoutRule_conditionsInput
    connect?: rulesWhereUniqueInput
  }

  export type rule_conditionsUncheckedCreateNestedManyWithoutRule_conditionsInput = {
    create?: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput> | rule_conditionsCreateWithoutRule_conditionsInput[] | rule_conditionsUncheckedCreateWithoutRule_conditionsInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRule_conditionsInput | rule_conditionsCreateOrConnectWithoutRule_conditionsInput[]
    createMany?: rule_conditionsCreateManyRule_conditionsInputEnvelope
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
  }

  export type rule_conditionsUpdateOneWithoutOther_rule_conditionsNestedInput = {
    create?: XOR<rule_conditionsCreateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedCreateWithoutOther_rule_conditionsInput>
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutOther_rule_conditionsInput
    upsert?: rule_conditionsUpsertWithoutOther_rule_conditionsInput
    disconnect?: rule_conditionsWhereInput | boolean
    delete?: rule_conditionsWhereInput | boolean
    connect?: rule_conditionsWhereUniqueInput
    update?: XOR<XOR<rule_conditionsUpdateToOneWithWhereWithoutOther_rule_conditionsInput, rule_conditionsUpdateWithoutOther_rule_conditionsInput>, rule_conditionsUncheckedUpdateWithoutOther_rule_conditionsInput>
  }

  export type rule_conditionsUpdateManyWithoutRule_conditionsNestedInput = {
    create?: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput> | rule_conditionsCreateWithoutRule_conditionsInput[] | rule_conditionsUncheckedCreateWithoutRule_conditionsInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRule_conditionsInput | rule_conditionsCreateOrConnectWithoutRule_conditionsInput[]
    upsert?: rule_conditionsUpsertWithWhereUniqueWithoutRule_conditionsInput | rule_conditionsUpsertWithWhereUniqueWithoutRule_conditionsInput[]
    createMany?: rule_conditionsCreateManyRule_conditionsInputEnvelope
    set?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    disconnect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    delete?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    update?: rule_conditionsUpdateWithWhereUniqueWithoutRule_conditionsInput | rule_conditionsUpdateWithWhereUniqueWithoutRule_conditionsInput[]
    updateMany?: rule_conditionsUpdateManyWithWhereWithoutRule_conditionsInput | rule_conditionsUpdateManyWithWhereWithoutRule_conditionsInput[]
    deleteMany?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
  }

  export type rulesUpdateOneWithoutRule_conditionsNestedInput = {
    create?: XOR<rulesCreateWithoutRule_conditionsInput, rulesUncheckedCreateWithoutRule_conditionsInput>
    connectOrCreate?: rulesCreateOrConnectWithoutRule_conditionsInput
    upsert?: rulesUpsertWithoutRule_conditionsInput
    disconnect?: rulesWhereInput | boolean
    delete?: rulesWhereInput | boolean
    connect?: rulesWhereUniqueInput
    update?: XOR<XOR<rulesUpdateToOneWithWhereWithoutRule_conditionsInput, rulesUpdateWithoutRule_conditionsInput>, rulesUncheckedUpdateWithoutRule_conditionsInput>
  }

  export type rule_conditionsUncheckedUpdateManyWithoutRule_conditionsNestedInput = {
    create?: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput> | rule_conditionsCreateWithoutRule_conditionsInput[] | rule_conditionsUncheckedCreateWithoutRule_conditionsInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRule_conditionsInput | rule_conditionsCreateOrConnectWithoutRule_conditionsInput[]
    upsert?: rule_conditionsUpsertWithWhereUniqueWithoutRule_conditionsInput | rule_conditionsUpsertWithWhereUniqueWithoutRule_conditionsInput[]
    createMany?: rule_conditionsCreateManyRule_conditionsInputEnvelope
    set?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    disconnect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    delete?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    update?: rule_conditionsUpdateWithWhereUniqueWithoutRule_conditionsInput | rule_conditionsUpdateWithWhereUniqueWithoutRule_conditionsInput[]
    updateMany?: rule_conditionsUpdateManyWithWhereWithoutRule_conditionsInput | rule_conditionsUpdateManyWithWhereWithoutRule_conditionsInput[]
    deleteMany?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
  }

  export type rule_actionsCreateNestedManyWithoutRulesInput = {
    create?: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput> | rule_actionsCreateWithoutRulesInput[] | rule_actionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_actionsCreateOrConnectWithoutRulesInput | rule_actionsCreateOrConnectWithoutRulesInput[]
    createMany?: rule_actionsCreateManyRulesInputEnvelope
    connect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
  }

  export type rule_conditionsCreateNestedManyWithoutRulesInput = {
    create?: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput> | rule_conditionsCreateWithoutRulesInput[] | rule_conditionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRulesInput | rule_conditionsCreateOrConnectWithoutRulesInput[]
    createMany?: rule_conditionsCreateManyRulesInputEnvelope
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutRulesInput = {
    create?: XOR<familiesCreateWithoutRulesInput, familiesUncheckedCreateWithoutRulesInput>
    connectOrCreate?: familiesCreateOrConnectWithoutRulesInput
    connect?: familiesWhereUniqueInput
  }

  export type rule_actionsUncheckedCreateNestedManyWithoutRulesInput = {
    create?: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput> | rule_actionsCreateWithoutRulesInput[] | rule_actionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_actionsCreateOrConnectWithoutRulesInput | rule_actionsCreateOrConnectWithoutRulesInput[]
    createMany?: rule_actionsCreateManyRulesInputEnvelope
    connect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
  }

  export type rule_conditionsUncheckedCreateNestedManyWithoutRulesInput = {
    create?: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput> | rule_conditionsCreateWithoutRulesInput[] | rule_conditionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRulesInput | rule_conditionsCreateOrConnectWithoutRulesInput[]
    createMany?: rule_conditionsCreateManyRulesInputEnvelope
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
  }

  export type rule_actionsUpdateManyWithoutRulesNestedInput = {
    create?: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput> | rule_actionsCreateWithoutRulesInput[] | rule_actionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_actionsCreateOrConnectWithoutRulesInput | rule_actionsCreateOrConnectWithoutRulesInput[]
    upsert?: rule_actionsUpsertWithWhereUniqueWithoutRulesInput | rule_actionsUpsertWithWhereUniqueWithoutRulesInput[]
    createMany?: rule_actionsCreateManyRulesInputEnvelope
    set?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    disconnect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    delete?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    connect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    update?: rule_actionsUpdateWithWhereUniqueWithoutRulesInput | rule_actionsUpdateWithWhereUniqueWithoutRulesInput[]
    updateMany?: rule_actionsUpdateManyWithWhereWithoutRulesInput | rule_actionsUpdateManyWithWhereWithoutRulesInput[]
    deleteMany?: rule_actionsScalarWhereInput | rule_actionsScalarWhereInput[]
  }

  export type rule_conditionsUpdateManyWithoutRulesNestedInput = {
    create?: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput> | rule_conditionsCreateWithoutRulesInput[] | rule_conditionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRulesInput | rule_conditionsCreateOrConnectWithoutRulesInput[]
    upsert?: rule_conditionsUpsertWithWhereUniqueWithoutRulesInput | rule_conditionsUpsertWithWhereUniqueWithoutRulesInput[]
    createMany?: rule_conditionsCreateManyRulesInputEnvelope
    set?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    disconnect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    delete?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    update?: rule_conditionsUpdateWithWhereUniqueWithoutRulesInput | rule_conditionsUpdateWithWhereUniqueWithoutRulesInput[]
    updateMany?: rule_conditionsUpdateManyWithWhereWithoutRulesInput | rule_conditionsUpdateManyWithWhereWithoutRulesInput[]
    deleteMany?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutRulesNestedInput = {
    create?: XOR<familiesCreateWithoutRulesInput, familiesUncheckedCreateWithoutRulesInput>
    connectOrCreate?: familiesCreateOrConnectWithoutRulesInput
    upsert?: familiesUpsertWithoutRulesInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutRulesInput, familiesUpdateWithoutRulesInput>, familiesUncheckedUpdateWithoutRulesInput>
  }

  export type rule_actionsUncheckedUpdateManyWithoutRulesNestedInput = {
    create?: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput> | rule_actionsCreateWithoutRulesInput[] | rule_actionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_actionsCreateOrConnectWithoutRulesInput | rule_actionsCreateOrConnectWithoutRulesInput[]
    upsert?: rule_actionsUpsertWithWhereUniqueWithoutRulesInput | rule_actionsUpsertWithWhereUniqueWithoutRulesInput[]
    createMany?: rule_actionsCreateManyRulesInputEnvelope
    set?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    disconnect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    delete?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    connect?: rule_actionsWhereUniqueInput | rule_actionsWhereUniqueInput[]
    update?: rule_actionsUpdateWithWhereUniqueWithoutRulesInput | rule_actionsUpdateWithWhereUniqueWithoutRulesInput[]
    updateMany?: rule_actionsUpdateManyWithWhereWithoutRulesInput | rule_actionsUpdateManyWithWhereWithoutRulesInput[]
    deleteMany?: rule_actionsScalarWhereInput | rule_actionsScalarWhereInput[]
  }

  export type rule_conditionsUncheckedUpdateManyWithoutRulesNestedInput = {
    create?: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput> | rule_conditionsCreateWithoutRulesInput[] | rule_conditionsUncheckedCreateWithoutRulesInput[]
    connectOrCreate?: rule_conditionsCreateOrConnectWithoutRulesInput | rule_conditionsCreateOrConnectWithoutRulesInput[]
    upsert?: rule_conditionsUpsertWithWhereUniqueWithoutRulesInput | rule_conditionsUpsertWithWhereUniqueWithoutRulesInput[]
    createMany?: rule_conditionsCreateManyRulesInputEnvelope
    set?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    disconnect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    delete?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    connect?: rule_conditionsWhereUniqueInput | rule_conditionsWhereUniqueInput[]
    update?: rule_conditionsUpdateWithWhereUniqueWithoutRulesInput | rule_conditionsUpdateWithWhereUniqueWithoutRulesInput[]
    updateMany?: rule_conditionsUpdateManyWithWhereWithoutRulesInput | rule_conditionsUpdateManyWithWhereWithoutRulesInput[]
    deleteMany?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
  }

  export type holdingsCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput> | holdingsCreateWithoutSecuritiesInput[] | holdingsUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutSecuritiesInput | holdingsCreateOrConnectWithoutSecuritiesInput[]
    createMany?: holdingsCreateManySecuritiesInputEnvelope
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
  }

  export type security_pricesCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput> | security_pricesCreateWithoutSecuritiesInput[] | security_pricesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: security_pricesCreateOrConnectWithoutSecuritiesInput | security_pricesCreateOrConnectWithoutSecuritiesInput[]
    createMany?: security_pricesCreateManySecuritiesInputEnvelope
    connect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
  }

  export type tradesCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput> | tradesCreateWithoutSecuritiesInput[] | tradesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutSecuritiesInput | tradesCreateOrConnectWithoutSecuritiesInput[]
    createMany?: tradesCreateManySecuritiesInputEnvelope
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
  }

  export type holdingsUncheckedCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput> | holdingsCreateWithoutSecuritiesInput[] | holdingsUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutSecuritiesInput | holdingsCreateOrConnectWithoutSecuritiesInput[]
    createMany?: holdingsCreateManySecuritiesInputEnvelope
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
  }

  export type security_pricesUncheckedCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput> | security_pricesCreateWithoutSecuritiesInput[] | security_pricesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: security_pricesCreateOrConnectWithoutSecuritiesInput | security_pricesCreateOrConnectWithoutSecuritiesInput[]
    createMany?: security_pricesCreateManySecuritiesInputEnvelope
    connect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
  }

  export type tradesUncheckedCreateNestedManyWithoutSecuritiesInput = {
    create?: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput> | tradesCreateWithoutSecuritiesInput[] | tradesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutSecuritiesInput | tradesCreateOrConnectWithoutSecuritiesInput[]
    createMany?: tradesCreateManySecuritiesInputEnvelope
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
  }

  export type holdingsUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput> | holdingsCreateWithoutSecuritiesInput[] | holdingsUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutSecuritiesInput | holdingsCreateOrConnectWithoutSecuritiesInput[]
    upsert?: holdingsUpsertWithWhereUniqueWithoutSecuritiesInput | holdingsUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: holdingsCreateManySecuritiesInputEnvelope
    set?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    disconnect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    delete?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    update?: holdingsUpdateWithWhereUniqueWithoutSecuritiesInput | holdingsUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: holdingsUpdateManyWithWhereWithoutSecuritiesInput | holdingsUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
  }

  export type security_pricesUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput> | security_pricesCreateWithoutSecuritiesInput[] | security_pricesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: security_pricesCreateOrConnectWithoutSecuritiesInput | security_pricesCreateOrConnectWithoutSecuritiesInput[]
    upsert?: security_pricesUpsertWithWhereUniqueWithoutSecuritiesInput | security_pricesUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: security_pricesCreateManySecuritiesInputEnvelope
    set?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    disconnect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    delete?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    connect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    update?: security_pricesUpdateWithWhereUniqueWithoutSecuritiesInput | security_pricesUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: security_pricesUpdateManyWithWhereWithoutSecuritiesInput | security_pricesUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: security_pricesScalarWhereInput | security_pricesScalarWhereInput[]
  }

  export type tradesUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput> | tradesCreateWithoutSecuritiesInput[] | tradesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutSecuritiesInput | tradesCreateOrConnectWithoutSecuritiesInput[]
    upsert?: tradesUpsertWithWhereUniqueWithoutSecuritiesInput | tradesUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: tradesCreateManySecuritiesInputEnvelope
    set?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    disconnect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    delete?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    update?: tradesUpdateWithWhereUniqueWithoutSecuritiesInput | tradesUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: tradesUpdateManyWithWhereWithoutSecuritiesInput | tradesUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: tradesScalarWhereInput | tradesScalarWhereInput[]
  }

  export type holdingsUncheckedUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput> | holdingsCreateWithoutSecuritiesInput[] | holdingsUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: holdingsCreateOrConnectWithoutSecuritiesInput | holdingsCreateOrConnectWithoutSecuritiesInput[]
    upsert?: holdingsUpsertWithWhereUniqueWithoutSecuritiesInput | holdingsUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: holdingsCreateManySecuritiesInputEnvelope
    set?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    disconnect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    delete?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    connect?: holdingsWhereUniqueInput | holdingsWhereUniqueInput[]
    update?: holdingsUpdateWithWhereUniqueWithoutSecuritiesInput | holdingsUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: holdingsUpdateManyWithWhereWithoutSecuritiesInput | holdingsUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
  }

  export type security_pricesUncheckedUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput> | security_pricesCreateWithoutSecuritiesInput[] | security_pricesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: security_pricesCreateOrConnectWithoutSecuritiesInput | security_pricesCreateOrConnectWithoutSecuritiesInput[]
    upsert?: security_pricesUpsertWithWhereUniqueWithoutSecuritiesInput | security_pricesUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: security_pricesCreateManySecuritiesInputEnvelope
    set?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    disconnect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    delete?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    connect?: security_pricesWhereUniqueInput | security_pricesWhereUniqueInput[]
    update?: security_pricesUpdateWithWhereUniqueWithoutSecuritiesInput | security_pricesUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: security_pricesUpdateManyWithWhereWithoutSecuritiesInput | security_pricesUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: security_pricesScalarWhereInput | security_pricesScalarWhereInput[]
  }

  export type tradesUncheckedUpdateManyWithoutSecuritiesNestedInput = {
    create?: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput> | tradesCreateWithoutSecuritiesInput[] | tradesUncheckedCreateWithoutSecuritiesInput[]
    connectOrCreate?: tradesCreateOrConnectWithoutSecuritiesInput | tradesCreateOrConnectWithoutSecuritiesInput[]
    upsert?: tradesUpsertWithWhereUniqueWithoutSecuritiesInput | tradesUpsertWithWhereUniqueWithoutSecuritiesInput[]
    createMany?: tradesCreateManySecuritiesInputEnvelope
    set?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    disconnect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    delete?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    connect?: tradesWhereUniqueInput | tradesWhereUniqueInput[]
    update?: tradesUpdateWithWhereUniqueWithoutSecuritiesInput | tradesUpdateWithWhereUniqueWithoutSecuritiesInput[]
    updateMany?: tradesUpdateManyWithWhereWithoutSecuritiesInput | tradesUpdateManyWithWhereWithoutSecuritiesInput[]
    deleteMany?: tradesScalarWhereInput | tradesScalarWhereInput[]
  }

  export type securitiesCreateNestedOneWithoutSecurity_pricesInput = {
    create?: XOR<securitiesCreateWithoutSecurity_pricesInput, securitiesUncheckedCreateWithoutSecurity_pricesInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutSecurity_pricesInput
    connect?: securitiesWhereUniqueInput
  }

  export type securitiesUpdateOneWithoutSecurity_pricesNestedInput = {
    create?: XOR<securitiesCreateWithoutSecurity_pricesInput, securitiesUncheckedCreateWithoutSecurity_pricesInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutSecurity_pricesInput
    upsert?: securitiesUpsertWithoutSecurity_pricesInput
    disconnect?: securitiesWhereInput | boolean
    delete?: securitiesWhereInput | boolean
    connect?: securitiesWhereUniqueInput
    update?: XOR<XOR<securitiesUpdateToOneWithWhereWithoutSecurity_pricesInput, securitiesUpdateWithoutSecurity_pricesInput>, securitiesUncheckedUpdateWithoutSecurity_pricesInput>
  }

  export type impersonation_sessionsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<impersonation_sessionsCreateWithoutSessionsInput, impersonation_sessionsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutSessionsInput
    connect?: impersonation_sessionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type impersonation_sessionsUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutSessionsInput, impersonation_sessionsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutSessionsInput
    upsert?: impersonation_sessionsUpsertWithoutSessionsInput
    disconnect?: impersonation_sessionsWhereInput | boolean
    delete?: impersonation_sessionsWhereInput | boolean
    connect?: impersonation_sessionsWhereUniqueInput
    update?: XOR<XOR<impersonation_sessionsUpdateToOneWithWhereWithoutSessionsInput, impersonation_sessionsUpdateWithoutSessionsInput>, impersonation_sessionsUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type syncsCreateerror_backtraceInput = {
    set: string[]
  }

  export type syncsCreateNestedOneWithoutOther_syncsInput = {
    create?: XOR<syncsCreateWithoutOther_syncsInput, syncsUncheckedCreateWithoutOther_syncsInput>
    connectOrCreate?: syncsCreateOrConnectWithoutOther_syncsInput
    connect?: syncsWhereUniqueInput
  }

  export type syncsCreateNestedManyWithoutSyncsInput = {
    create?: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput> | syncsCreateWithoutSyncsInput[] | syncsUncheckedCreateWithoutSyncsInput[]
    connectOrCreate?: syncsCreateOrConnectWithoutSyncsInput | syncsCreateOrConnectWithoutSyncsInput[]
    createMany?: syncsCreateManySyncsInputEnvelope
    connect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
  }

  export type syncsUncheckedCreateNestedManyWithoutSyncsInput = {
    create?: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput> | syncsCreateWithoutSyncsInput[] | syncsUncheckedCreateWithoutSyncsInput[]
    connectOrCreate?: syncsCreateOrConnectWithoutSyncsInput | syncsCreateOrConnectWithoutSyncsInput[]
    createMany?: syncsCreateManySyncsInputEnvelope
    connect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
  }

  export type syncsUpdateerror_backtraceInput = {
    set?: string[]
    push?: string | string[]
  }

  export type syncsUpdateOneWithoutOther_syncsNestedInput = {
    create?: XOR<syncsCreateWithoutOther_syncsInput, syncsUncheckedCreateWithoutOther_syncsInput>
    connectOrCreate?: syncsCreateOrConnectWithoutOther_syncsInput
    upsert?: syncsUpsertWithoutOther_syncsInput
    disconnect?: syncsWhereInput | boolean
    delete?: syncsWhereInput | boolean
    connect?: syncsWhereUniqueInput
    update?: XOR<XOR<syncsUpdateToOneWithWhereWithoutOther_syncsInput, syncsUpdateWithoutOther_syncsInput>, syncsUncheckedUpdateWithoutOther_syncsInput>
  }

  export type syncsUpdateManyWithoutSyncsNestedInput = {
    create?: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput> | syncsCreateWithoutSyncsInput[] | syncsUncheckedCreateWithoutSyncsInput[]
    connectOrCreate?: syncsCreateOrConnectWithoutSyncsInput | syncsCreateOrConnectWithoutSyncsInput[]
    upsert?: syncsUpsertWithWhereUniqueWithoutSyncsInput | syncsUpsertWithWhereUniqueWithoutSyncsInput[]
    createMany?: syncsCreateManySyncsInputEnvelope
    set?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    disconnect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    delete?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    connect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    update?: syncsUpdateWithWhereUniqueWithoutSyncsInput | syncsUpdateWithWhereUniqueWithoutSyncsInput[]
    updateMany?: syncsUpdateManyWithWhereWithoutSyncsInput | syncsUpdateManyWithWhereWithoutSyncsInput[]
    deleteMany?: syncsScalarWhereInput | syncsScalarWhereInput[]
  }

  export type syncsUncheckedUpdateManyWithoutSyncsNestedInput = {
    create?: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput> | syncsCreateWithoutSyncsInput[] | syncsUncheckedCreateWithoutSyncsInput[]
    connectOrCreate?: syncsCreateOrConnectWithoutSyncsInput | syncsCreateOrConnectWithoutSyncsInput[]
    upsert?: syncsUpsertWithWhereUniqueWithoutSyncsInput | syncsUpsertWithWhereUniqueWithoutSyncsInput[]
    createMany?: syncsCreateManySyncsInputEnvelope
    set?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    disconnect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    delete?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    connect?: syncsWhereUniqueInput | syncsWhereUniqueInput[]
    update?: syncsUpdateWithWhereUniqueWithoutSyncsInput | syncsUpdateWithWhereUniqueWithoutSyncsInput[]
    updateMany?: syncsUpdateManyWithWhereWithoutSyncsInput | syncsUpdateManyWithWhereWithoutSyncsInput[]
    deleteMany?: syncsScalarWhereInput | syncsScalarWhereInput[]
  }

  export type tagsCreateNestedOneWithoutTaggingsInput = {
    create?: XOR<tagsCreateWithoutTaggingsInput, tagsUncheckedCreateWithoutTaggingsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutTaggingsInput
    connect?: tagsWhereUniqueInput
  }

  export type tagsUpdateOneRequiredWithoutTaggingsNestedInput = {
    create?: XOR<tagsCreateWithoutTaggingsInput, tagsUncheckedCreateWithoutTaggingsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutTaggingsInput
    upsert?: tagsUpsertWithoutTaggingsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutTaggingsInput, tagsUpdateWithoutTaggingsInput>, tagsUncheckedUpdateWithoutTaggingsInput>
  }

  export type taggingsCreateNestedManyWithoutTagsInput = {
    create?: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput> | taggingsCreateWithoutTagsInput[] | taggingsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: taggingsCreateOrConnectWithoutTagsInput | taggingsCreateOrConnectWithoutTagsInput[]
    createMany?: taggingsCreateManyTagsInputEnvelope
    connect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
  }

  export type familiesCreateNestedOneWithoutTagsInput = {
    create?: XOR<familiesCreateWithoutTagsInput, familiesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutTagsInput
    connect?: familiesWhereUniqueInput
  }

  export type taggingsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput> | taggingsCreateWithoutTagsInput[] | taggingsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: taggingsCreateOrConnectWithoutTagsInput | taggingsCreateOrConnectWithoutTagsInput[]
    createMany?: taggingsCreateManyTagsInputEnvelope
    connect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
  }

  export type taggingsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput> | taggingsCreateWithoutTagsInput[] | taggingsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: taggingsCreateOrConnectWithoutTagsInput | taggingsCreateOrConnectWithoutTagsInput[]
    upsert?: taggingsUpsertWithWhereUniqueWithoutTagsInput | taggingsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: taggingsCreateManyTagsInputEnvelope
    set?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    disconnect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    delete?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    connect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    update?: taggingsUpdateWithWhereUniqueWithoutTagsInput | taggingsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: taggingsUpdateManyWithWhereWithoutTagsInput | taggingsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: taggingsScalarWhereInput | taggingsScalarWhereInput[]
  }

  export type familiesUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<familiesCreateWithoutTagsInput, familiesUncheckedCreateWithoutTagsInput>
    connectOrCreate?: familiesCreateOrConnectWithoutTagsInput
    upsert?: familiesUpsertWithoutTagsInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutTagsInput, familiesUpdateWithoutTagsInput>, familiesUncheckedUpdateWithoutTagsInput>
  }

  export type taggingsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput> | taggingsCreateWithoutTagsInput[] | taggingsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: taggingsCreateOrConnectWithoutTagsInput | taggingsCreateOrConnectWithoutTagsInput[]
    upsert?: taggingsUpsertWithWhereUniqueWithoutTagsInput | taggingsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: taggingsCreateManyTagsInputEnvelope
    set?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    disconnect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    delete?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    connect?: taggingsWhereUniqueInput | taggingsWhereUniqueInput[]
    update?: taggingsUpdateWithWhereUniqueWithoutTagsInput | taggingsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: taggingsUpdateManyWithWhereWithoutTagsInput | taggingsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: taggingsScalarWhereInput | taggingsScalarWhereInput[]
  }

  export type messagesCreateNestedOneWithoutTool_callsInput = {
    create?: XOR<messagesCreateWithoutTool_callsInput, messagesUncheckedCreateWithoutTool_callsInput>
    connectOrCreate?: messagesCreateOrConnectWithoutTool_callsInput
    connect?: messagesWhereUniqueInput
  }

  export type messagesUpdateOneRequiredWithoutTool_callsNestedInput = {
    create?: XOR<messagesCreateWithoutTool_callsInput, messagesUncheckedCreateWithoutTool_callsInput>
    connectOrCreate?: messagesCreateOrConnectWithoutTool_callsInput
    upsert?: messagesUpsertWithoutTool_callsInput
    connect?: messagesWhereUniqueInput
    update?: XOR<XOR<messagesUpdateToOneWithWhereWithoutTool_callsInput, messagesUpdateWithoutTool_callsInput>, messagesUncheckedUpdateWithoutTool_callsInput>
  }

  export type securitiesCreateNestedOneWithoutTradesInput = {
    create?: XOR<securitiesCreateWithoutTradesInput, securitiesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutTradesInput
    connect?: securitiesWhereUniqueInput
  }

  export type securitiesUpdateOneRequiredWithoutTradesNestedInput = {
    create?: XOR<securitiesCreateWithoutTradesInput, securitiesUncheckedCreateWithoutTradesInput>
    connectOrCreate?: securitiesCreateOrConnectWithoutTradesInput
    upsert?: securitiesUpsertWithoutTradesInput
    connect?: securitiesWhereUniqueInput
    update?: XOR<XOR<securitiesUpdateToOneWithWhereWithoutTradesInput, securitiesUpdateWithoutTradesInput>, securitiesUncheckedUpdateWithoutTradesInput>
  }

  export type rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInputEnvelope
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
  }

  export type rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInputEnvelope
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<categoriesCreateWithoutTransactionsInput, categoriesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutTransactionsInput
    connect?: categoriesWhereUniqueInput
  }

  export type merchantsCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<merchantsCreateWithoutTransactionsInput, merchantsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: merchantsCreateOrConnectWithoutTransactionsInput
    connect?: merchantsWhereUniqueInput
  }

  export type transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInputEnvelope
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
  }

  export type transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInputEnvelope
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
  }

  export type rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInputEnvelope
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
  }

  export type rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInputEnvelope
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
  }

  export type transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInputEnvelope
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
  }

  export type transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInputEnvelope
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
  }

  export type rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    upsert?: rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInputEnvelope
    set?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    disconnect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    delete?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    update?: rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    updateMany?: rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    deleteMany?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
  }

  export type rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    upsert?: rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInputEnvelope
    set?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    disconnect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    delete?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    update?: rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    updateMany?: rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    deleteMany?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<categoriesCreateWithoutTransactionsInput, categoriesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutTransactionsInput
    upsert?: categoriesUpsertWithoutTransactionsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutTransactionsInput, categoriesUpdateWithoutTransactionsInput>, categoriesUncheckedUpdateWithoutTransactionsInput>
  }

  export type merchantsUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<merchantsCreateWithoutTransactionsInput, merchantsUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: merchantsCreateOrConnectWithoutTransactionsInput
    upsert?: merchantsUpsertWithoutTransactionsInput
    disconnect?: merchantsWhereInput | boolean
    delete?: merchantsWhereInput | boolean
    connect?: merchantsWhereUniqueInput
    update?: XOR<XOR<merchantsUpdateToOneWithWhereWithoutTransactionsInput, merchantsUpdateWithoutTransactionsInput>, merchantsUncheckedUpdateWithoutTransactionsInput>
  }

  export type transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    upsert?: transfersUpsertWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpsertWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInputEnvelope
    set?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    disconnect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    delete?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    update?: transfersUpdateWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpdateWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    updateMany?: transfersUpdateManyWithWhereWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpdateManyWithWhereWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    deleteMany?: transfersScalarWhereInput | transfersScalarWhereInput[]
  }

  export type transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    upsert?: transfersUpsertWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpsertWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInputEnvelope
    set?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    disconnect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    delete?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    update?: transfersUpdateWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpdateWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    updateMany?: transfersUpdateManyWithWhereWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpdateManyWithWhereWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    deleteMany?: transfersScalarWhereInput | transfersScalarWhereInput[]
  }

  export type rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    upsert?: rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInputEnvelope
    set?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    disconnect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    delete?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    update?: rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    updateMany?: rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    deleteMany?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
  }

  export type rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput> | rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[] | rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    upsert?: rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInputEnvelope
    set?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    disconnect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    delete?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    connect?: rejected_transfersWhereUniqueInput | rejected_transfersWhereUniqueInput[]
    update?: rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    updateMany?: rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    deleteMany?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
  }

  export type transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    upsert?: transfersUpsertWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpsertWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInputEnvelope
    set?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    disconnect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    delete?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    update?: transfersUpdateWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpdateWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    updateMany?: transfersUpdateManyWithWhereWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersUpdateManyWithWhereWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    deleteMany?: transfersScalarWhereInput | transfersScalarWhereInput[]
  }

  export type transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput> | transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[] | transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    connectOrCreate?: transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    upsert?: transfersUpsertWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpsertWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    createMany?: transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInputEnvelope
    set?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    disconnect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    delete?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    connect?: transfersWhereUniqueInput | transfersWhereUniqueInput[]
    update?: transfersUpdateWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpdateWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    updateMany?: transfersUpdateManyWithWhereWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersUpdateManyWithWhereWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    deleteMany?: transfersScalarWhereInput | transfersScalarWhereInput[]
  }

  export type transactionsCreateNestedOneWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    create?: XOR<transactionsCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionsCreateNestedOneWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    create?: XOR<transactionsCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionsUpdateOneRequiredWithoutTransfers_transfers_outflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transactionsCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput
    upsert?: transactionsUpsertWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>, transactionsUncheckedUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateOneRequiredWithoutTransfers_transfers_inflow_transaction_idTotransactionsNestedInput = {
    create?: XOR<transactionsCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput
    upsert?: transactionsUpsertWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>, transactionsUncheckedUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type usersCreateotp_backup_codesInput = {
    set: string[]
  }

  export type usersCreategoalsInput = {
    set: string[]
  }

  export type chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput = {
    create?: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput> | chatsCreateWithoutUsers_chats_user_idTousersInput[] | chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput[]
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput | chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput[]
    createMany?: chatsCreateManyUsers_chats_user_idTousersInputEnvelope
    connect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
  }

  export type impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInputEnvelope
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
  }

  export type impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInputEnvelope
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
  }

  export type invitationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput> | invitationsCreateWithoutUsersInput[] | invitationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutUsersInput | invitationsCreateOrConnectWithoutUsersInput[]
    createMany?: invitationsCreateManyUsersInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    create?: XOR<chatsCreateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedCreateWithoutUsers_users_last_viewed_chat_idTochatsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_users_last_viewed_chat_idTochatsInput
    connect?: chatsWhereUniqueInput
  }

  export type familiesCreateNestedOneWithoutUsersInput = {
    create?: XOR<familiesCreateWithoutUsersInput, familiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: familiesCreateOrConnectWithoutUsersInput
    connect?: familiesWhereUniqueInput
  }

  export type chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput = {
    create?: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput> | chatsCreateWithoutUsers_chats_user_idTousersInput[] | chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput[]
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput | chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput[]
    createMany?: chatsCreateManyUsers_chats_user_idTousersInputEnvelope
    connect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
  }

  export type impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInputEnvelope
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
  }

  export type impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInputEnvelope
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
  }

  export type invitationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput> | invitationsCreateWithoutUsersInput[] | invitationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutUsersInput | invitationsCreateOrConnectWithoutUsersInput[]
    createMany?: invitationsCreateManyUsersInputEnvelope
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type usersUpdateotp_backup_codesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdategoalsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput = {
    create?: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput> | chatsCreateWithoutUsers_chats_user_idTousersInput[] | chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput[]
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput | chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput[]
    upsert?: chatsUpsertWithWhereUniqueWithoutUsers_chats_user_idTousersInput | chatsUpsertWithWhereUniqueWithoutUsers_chats_user_idTousersInput[]
    createMany?: chatsCreateManyUsers_chats_user_idTousersInputEnvelope
    set?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    disconnect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    delete?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    connect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    update?: chatsUpdateWithWhereUniqueWithoutUsers_chats_user_idTousersInput | chatsUpdateWithWhereUniqueWithoutUsers_chats_user_idTousersInput[]
    updateMany?: chatsUpdateManyWithWhereWithoutUsers_chats_user_idTousersInput | chatsUpdateManyWithWhereWithoutUsers_chats_user_idTousersInput[]
    deleteMany?: chatsScalarWhereInput | chatsScalarWhereInput[]
  }

  export type impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    upsert?: impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInputEnvelope
    set?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    disconnect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    delete?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    update?: impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    updateMany?: impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    deleteMany?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
  }

  export type impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    upsert?: impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInputEnvelope
    set?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    disconnect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    delete?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    update?: impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    updateMany?: impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    deleteMany?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
  }

  export type invitationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput> | invitationsCreateWithoutUsersInput[] | invitationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutUsersInput | invitationsCreateOrConnectWithoutUsersInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutUsersInput | invitationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: invitationsCreateManyUsersInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutUsersInput | invitationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutUsersInput | invitationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput = {
    create?: XOR<chatsCreateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedCreateWithoutUsers_users_last_viewed_chat_idTochatsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_users_last_viewed_chat_idTochatsInput
    upsert?: chatsUpsertWithoutUsers_users_last_viewed_chat_idTochatsInput
    disconnect?: chatsWhereInput | boolean
    delete?: chatsWhereInput | boolean
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput>, chatsUncheckedUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput>
  }

  export type familiesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<familiesCreateWithoutUsersInput, familiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: familiesCreateOrConnectWithoutUsersInput
    upsert?: familiesUpsertWithoutUsersInput
    connect?: familiesWhereUniqueInput
    update?: XOR<XOR<familiesUpdateToOneWithWhereWithoutUsersInput, familiesUpdateWithoutUsersInput>, familiesUncheckedUpdateWithoutUsersInput>
  }

  export type chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput = {
    create?: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput> | chatsCreateWithoutUsers_chats_user_idTousersInput[] | chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput[]
    connectOrCreate?: chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput | chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput[]
    upsert?: chatsUpsertWithWhereUniqueWithoutUsers_chats_user_idTousersInput | chatsUpsertWithWhereUniqueWithoutUsers_chats_user_idTousersInput[]
    createMany?: chatsCreateManyUsers_chats_user_idTousersInputEnvelope
    set?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    disconnect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    delete?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    connect?: chatsWhereUniqueInput | chatsWhereUniqueInput[]
    update?: chatsUpdateWithWhereUniqueWithoutUsers_chats_user_idTousersInput | chatsUpdateWithWhereUniqueWithoutUsers_chats_user_idTousersInput[]
    updateMany?: chatsUpdateManyWithWhereWithoutUsers_chats_user_idTousersInput | chatsUpdateManyWithWhereWithoutUsers_chats_user_idTousersInput[]
    deleteMany?: chatsScalarWhereInput | chatsScalarWhereInput[]
  }

  export type impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    upsert?: impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInputEnvelope
    set?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    disconnect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    delete?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    update?: impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    updateMany?: impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonator_idTousersInput[]
    deleteMany?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
  }

  export type impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput = {
    create?: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput> | impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[] | impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    connectOrCreate?: impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    upsert?: impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    createMany?: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInputEnvelope
    set?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    disconnect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    delete?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    connect?: impersonation_sessionsWhereUniqueInput | impersonation_sessionsWhereUniqueInput[]
    update?: impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    updateMany?: impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonated_idTousersInput[]
    deleteMany?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
  }

  export type invitationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput> | invitationsCreateWithoutUsersInput[] | invitationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invitationsCreateOrConnectWithoutUsersInput | invitationsCreateOrConnectWithoutUsersInput[]
    upsert?: invitationsUpsertWithWhereUniqueWithoutUsersInput | invitationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: invitationsCreateManyUsersInputEnvelope
    set?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    disconnect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    delete?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    connect?: invitationsWhereUniqueInput | invitationsWhereUniqueInput[]
    update?: invitationsUpdateWithWhereUniqueWithoutUsersInput | invitationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invitationsUpdateManyWithWhereWithoutUsersInput | invitationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type familiesCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutAccountsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutAccountsInput, familiesUncheckedCreateWithoutAccountsInput>
  }

  export type importsCreateWithoutAccountsInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    entries?: entriesCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsCreateNestedManyWithoutImportsInput
    families: familiesCreateNestedOneWithoutImportsInput
  }

  export type importsUncheckedCreateWithoutAccountsInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    family_id: string
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    entries?: entriesUncheckedCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsUncheckedCreateNestedManyWithoutImportsInput
  }

  export type importsCreateOrConnectWithoutAccountsInput = {
    where: importsWhereUniqueInput
    create: XOR<importsCreateWithoutAccountsInput, importsUncheckedCreateWithoutAccountsInput>
  }

  export type plaid_accountsCreateWithoutAccountsInput = {
    id?: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
    plaid_items: plaid_itemsCreateNestedOneWithoutPlaid_accountsInput
  }

  export type plaid_accountsUncheckedCreateWithoutAccountsInput = {
    id?: string
    plaid_item_id: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type plaid_accountsCreateOrConnectWithoutAccountsInput = {
    where: plaid_accountsWhereUniqueInput
    create: XOR<plaid_accountsCreateWithoutAccountsInput, plaid_accountsUncheckedCreateWithoutAccountsInput>
  }

  export type balancesCreateWithoutAccountsInput = {
    id?: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUncheckedCreateWithoutAccountsInput = {
    id?: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type balancesCreateOrConnectWithoutAccountsInput = {
    where: balancesWhereUniqueInput
    create: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput>
  }

  export type balancesCreateManyAccountsInputEnvelope = {
    data: balancesCreateManyAccountsInput | balancesCreateManyAccountsInput[]
    skipDuplicates?: boolean
  }

  export type entriesCreateWithoutAccountsInput = {
    id?: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    imports?: importsCreateNestedOneWithoutEntriesInput
  }

  export type entriesUncheckedCreateWithoutAccountsInput = {
    id?: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    import_id?: string | null
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesCreateOrConnectWithoutAccountsInput = {
    where: entriesWhereUniqueInput
    create: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput>
  }

  export type entriesCreateManyAccountsInputEnvelope = {
    data: entriesCreateManyAccountsInput | entriesCreateManyAccountsInput[]
    skipDuplicates?: boolean
  }

  export type holdingsCreateWithoutAccountsInput = {
    id?: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    securities: securitiesCreateNestedOneWithoutHoldingsInput
  }

  export type holdingsUncheckedCreateWithoutAccountsInput = {
    id?: string
    security_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type holdingsCreateOrConnectWithoutAccountsInput = {
    where: holdingsWhereUniqueInput
    create: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput>
  }

  export type holdingsCreateManyAccountsInputEnvelope = {
    data: holdingsCreateManyAccountsInput | holdingsCreateManyAccountsInput[]
    skipDuplicates?: boolean
  }

  export type familiesUpsertWithoutAccountsInput = {
    update: XOR<familiesUpdateWithoutAccountsInput, familiesUncheckedUpdateWithoutAccountsInput>
    create: XOR<familiesCreateWithoutAccountsInput, familiesUncheckedCreateWithoutAccountsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutAccountsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutAccountsInput, familiesUncheckedUpdateWithoutAccountsInput>
  }

  export type familiesUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type importsUpsertWithoutAccountsInput = {
    update: XOR<importsUpdateWithoutAccountsInput, importsUncheckedUpdateWithoutAccountsInput>
    create: XOR<importsCreateWithoutAccountsInput, importsUncheckedCreateWithoutAccountsInput>
    where?: importsWhereInput
  }

  export type importsUpdateToOneWithWhereWithoutAccountsInput = {
    where?: importsWhereInput
    data: XOR<importsUpdateWithoutAccountsInput, importsUncheckedUpdateWithoutAccountsInput>
  }

  export type importsUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: entriesUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUpdateManyWithoutImportsNestedInput
    families?: familiesUpdateOneRequiredWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    entries?: entriesUncheckedUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUncheckedUpdateManyWithoutImportsNestedInput
  }

  export type plaid_accountsUpsertWithoutAccountsInput = {
    update: XOR<plaid_accountsUpdateWithoutAccountsInput, plaid_accountsUncheckedUpdateWithoutAccountsInput>
    create: XOR<plaid_accountsCreateWithoutAccountsInput, plaid_accountsUncheckedCreateWithoutAccountsInput>
    where?: plaid_accountsWhereInput
  }

  export type plaid_accountsUpdateToOneWithWhereWithoutAccountsInput = {
    where?: plaid_accountsWhereInput
    data: XOR<plaid_accountsUpdateWithoutAccountsInput, plaid_accountsUncheckedUpdateWithoutAccountsInput>
  }

  export type plaid_accountsUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    plaid_items?: plaid_itemsUpdateOneRequiredWithoutPlaid_accountsNestedInput
  }

  export type plaid_accountsUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_item_id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type balancesUpsertWithWhereUniqueWithoutAccountsInput = {
    where: balancesWhereUniqueInput
    update: XOR<balancesUpdateWithoutAccountsInput, balancesUncheckedUpdateWithoutAccountsInput>
    create: XOR<balancesCreateWithoutAccountsInput, balancesUncheckedCreateWithoutAccountsInput>
  }

  export type balancesUpdateWithWhereUniqueWithoutAccountsInput = {
    where: balancesWhereUniqueInput
    data: XOR<balancesUpdateWithoutAccountsInput, balancesUncheckedUpdateWithoutAccountsInput>
  }

  export type balancesUpdateManyWithWhereWithoutAccountsInput = {
    where: balancesScalarWhereInput
    data: XOR<balancesUpdateManyMutationInput, balancesUncheckedUpdateManyWithoutAccountsInput>
  }

  export type balancesScalarWhereInput = {
    AND?: balancesScalarWhereInput | balancesScalarWhereInput[]
    OR?: balancesScalarWhereInput[]
    NOT?: balancesScalarWhereInput | balancesScalarWhereInput[]
    id?: UuidFilter<"balances"> | string
    account_id?: UuidFilter<"balances"> | string
    date?: DateTimeFilter<"balances"> | Date | string
    balance?: DecimalFilter<"balances"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"balances"> | string
    created_at?: DateTimeFilter<"balances"> | Date | string
    updated_at?: DateTimeFilter<"balances"> | Date | string
    cash_balance?: DecimalNullableFilter<"balances"> | Decimal | DecimalJsLike | number | string | null
  }

  export type entriesUpsertWithWhereUniqueWithoutAccountsInput = {
    where: entriesWhereUniqueInput
    update: XOR<entriesUpdateWithoutAccountsInput, entriesUncheckedUpdateWithoutAccountsInput>
    create: XOR<entriesCreateWithoutAccountsInput, entriesUncheckedCreateWithoutAccountsInput>
  }

  export type entriesUpdateWithWhereUniqueWithoutAccountsInput = {
    where: entriesWhereUniqueInput
    data: XOR<entriesUpdateWithoutAccountsInput, entriesUncheckedUpdateWithoutAccountsInput>
  }

  export type entriesUpdateManyWithWhereWithoutAccountsInput = {
    where: entriesScalarWhereInput
    data: XOR<entriesUpdateManyMutationInput, entriesUncheckedUpdateManyWithoutAccountsInput>
  }

  export type entriesScalarWhereInput = {
    AND?: entriesScalarWhereInput | entriesScalarWhereInput[]
    OR?: entriesScalarWhereInput[]
    NOT?: entriesScalarWhereInput | entriesScalarWhereInput[]
    id?: UuidFilter<"entries"> | string
    account_id?: UuidFilter<"entries"> | string
    entryable_type?: StringNullableFilter<"entries"> | string | null
    entryable_id?: UuidNullableFilter<"entries"> | string | null
    amount?: DecimalNullableFilter<"entries"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"entries"> | string | null
    date?: DateTimeNullableFilter<"entries"> | Date | string | null
    name?: StringFilter<"entries"> | string
    created_at?: DateTimeFilter<"entries"> | Date | string
    updated_at?: DateTimeFilter<"entries"> | Date | string
    import_id?: UuidNullableFilter<"entries"> | string | null
    notes?: StringNullableFilter<"entries"> | string | null
    excluded?: BoolNullableFilter<"entries"> | boolean | null
    plaid_id?: StringNullableFilter<"entries"> | string | null
    locked_attributes?: JsonNullableFilter<"entries">
  }

  export type holdingsUpsertWithWhereUniqueWithoutAccountsInput = {
    where: holdingsWhereUniqueInput
    update: XOR<holdingsUpdateWithoutAccountsInput, holdingsUncheckedUpdateWithoutAccountsInput>
    create: XOR<holdingsCreateWithoutAccountsInput, holdingsUncheckedCreateWithoutAccountsInput>
  }

  export type holdingsUpdateWithWhereUniqueWithoutAccountsInput = {
    where: holdingsWhereUniqueInput
    data: XOR<holdingsUpdateWithoutAccountsInput, holdingsUncheckedUpdateWithoutAccountsInput>
  }

  export type holdingsUpdateManyWithWhereWithoutAccountsInput = {
    where: holdingsScalarWhereInput
    data: XOR<holdingsUpdateManyMutationInput, holdingsUncheckedUpdateManyWithoutAccountsInput>
  }

  export type holdingsScalarWhereInput = {
    AND?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
    OR?: holdingsScalarWhereInput[]
    NOT?: holdingsScalarWhereInput | holdingsScalarWhereInput[]
    id?: UuidFilter<"holdings"> | string
    account_id?: UuidFilter<"holdings"> | string
    security_id?: UuidFilter<"holdings"> | string
    date?: DateTimeFilter<"holdings"> | Date | string
    qty?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    amount?: DecimalFilter<"holdings"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"holdings"> | string
    created_at?: DateTimeFilter<"holdings"> | Date | string
    updated_at?: DateTimeFilter<"holdings"> | Date | string
  }

  export type active_storage_blobsCreateWithoutActive_storage_attachmentsInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_variant_records?: active_storage_variant_recordsCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsUncheckedCreateWithoutActive_storage_attachmentsInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_variant_records?: active_storage_variant_recordsUncheckedCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsCreateOrConnectWithoutActive_storage_attachmentsInput = {
    where: active_storage_blobsWhereUniqueInput
    create: XOR<active_storage_blobsCreateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_attachmentsInput>
  }

  export type active_storage_blobsUpsertWithoutActive_storage_attachmentsInput = {
    update: XOR<active_storage_blobsUpdateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedUpdateWithoutActive_storage_attachmentsInput>
    create: XOR<active_storage_blobsCreateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_attachmentsInput>
    where?: active_storage_blobsWhereInput
  }

  export type active_storage_blobsUpdateToOneWithWhereWithoutActive_storage_attachmentsInput = {
    where?: active_storage_blobsWhereInput
    data: XOR<active_storage_blobsUpdateWithoutActive_storage_attachmentsInput, active_storage_blobsUncheckedUpdateWithoutActive_storage_attachmentsInput>
  }

  export type active_storage_blobsUpdateWithoutActive_storage_attachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_variant_records?: active_storage_variant_recordsUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type active_storage_blobsUncheckedUpdateWithoutActive_storage_attachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_variant_records?: active_storage_variant_recordsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type active_storage_attachmentsCreateWithoutActive_storage_blobsInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    created_at: Date | string
  }

  export type active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    created_at: Date | string
  }

  export type active_storage_attachmentsCreateOrConnectWithoutActive_storage_blobsInput = {
    where: active_storage_attachmentsWhereUniqueInput
    create: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput>
  }

  export type active_storage_attachmentsCreateManyActive_storage_blobsInputEnvelope = {
    data: active_storage_attachmentsCreateManyActive_storage_blobsInput | active_storage_attachmentsCreateManyActive_storage_blobsInput[]
    skipDuplicates?: boolean
  }

  export type active_storage_variant_recordsCreateWithoutActive_storage_blobsInput = {
    id?: string
    variation_digest: string
  }

  export type active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput = {
    id?: string
    variation_digest: string
  }

  export type active_storage_variant_recordsCreateOrConnectWithoutActive_storage_blobsInput = {
    where: active_storage_variant_recordsWhereUniqueInput
    create: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput>
  }

  export type active_storage_variant_recordsCreateManyActive_storage_blobsInputEnvelope = {
    data: active_storage_variant_recordsCreateManyActive_storage_blobsInput | active_storage_variant_recordsCreateManyActive_storage_blobsInput[]
    skipDuplicates?: boolean
  }

  export type active_storage_attachmentsUpsertWithWhereUniqueWithoutActive_storage_blobsInput = {
    where: active_storage_attachmentsWhereUniqueInput
    update: XOR<active_storage_attachmentsUpdateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedUpdateWithoutActive_storage_blobsInput>
    create: XOR<active_storage_attachmentsCreateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedCreateWithoutActive_storage_blobsInput>
  }

  export type active_storage_attachmentsUpdateWithWhereUniqueWithoutActive_storage_blobsInput = {
    where: active_storage_attachmentsWhereUniqueInput
    data: XOR<active_storage_attachmentsUpdateWithoutActive_storage_blobsInput, active_storage_attachmentsUncheckedUpdateWithoutActive_storage_blobsInput>
  }

  export type active_storage_attachmentsUpdateManyWithWhereWithoutActive_storage_blobsInput = {
    where: active_storage_attachmentsScalarWhereInput
    data: XOR<active_storage_attachmentsUpdateManyMutationInput, active_storage_attachmentsUncheckedUpdateManyWithoutActive_storage_blobsInput>
  }

  export type active_storage_attachmentsScalarWhereInput = {
    AND?: active_storage_attachmentsScalarWhereInput | active_storage_attachmentsScalarWhereInput[]
    OR?: active_storage_attachmentsScalarWhereInput[]
    NOT?: active_storage_attachmentsScalarWhereInput | active_storage_attachmentsScalarWhereInput[]
    id?: UuidFilter<"active_storage_attachments"> | string
    name?: StringFilter<"active_storage_attachments"> | string
    record_type?: StringFilter<"active_storage_attachments"> | string
    record_id?: UuidFilter<"active_storage_attachments"> | string
    blob_id?: UuidFilter<"active_storage_attachments"> | string
    created_at?: DateTimeFilter<"active_storage_attachments"> | Date | string
  }

  export type active_storage_variant_recordsUpsertWithWhereUniqueWithoutActive_storage_blobsInput = {
    where: active_storage_variant_recordsWhereUniqueInput
    update: XOR<active_storage_variant_recordsUpdateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedUpdateWithoutActive_storage_blobsInput>
    create: XOR<active_storage_variant_recordsCreateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedCreateWithoutActive_storage_blobsInput>
  }

  export type active_storage_variant_recordsUpdateWithWhereUniqueWithoutActive_storage_blobsInput = {
    where: active_storage_variant_recordsWhereUniqueInput
    data: XOR<active_storage_variant_recordsUpdateWithoutActive_storage_blobsInput, active_storage_variant_recordsUncheckedUpdateWithoutActive_storage_blobsInput>
  }

  export type active_storage_variant_recordsUpdateManyWithWhereWithoutActive_storage_blobsInput = {
    where: active_storage_variant_recordsScalarWhereInput
    data: XOR<active_storage_variant_recordsUpdateManyMutationInput, active_storage_variant_recordsUncheckedUpdateManyWithoutActive_storage_blobsInput>
  }

  export type active_storage_variant_recordsScalarWhereInput = {
    AND?: active_storage_variant_recordsScalarWhereInput | active_storage_variant_recordsScalarWhereInput[]
    OR?: active_storage_variant_recordsScalarWhereInput[]
    NOT?: active_storage_variant_recordsScalarWhereInput | active_storage_variant_recordsScalarWhereInput[]
    id?: UuidFilter<"active_storage_variant_records"> | string
    blob_id?: UuidFilter<"active_storage_variant_records"> | string
    variation_digest?: StringFilter<"active_storage_variant_records"> | string
  }

  export type active_storage_blobsCreateWithoutActive_storage_variant_recordsInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_attachments?: active_storage_attachmentsCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsUncheckedCreateWithoutActive_storage_variant_recordsInput = {
    id?: string
    key: string
    filename: string
    content_type?: string | null
    metadata?: string | null
    service_name: string
    byte_size: bigint | number
    checksum?: string | null
    created_at: Date | string
    active_storage_attachments?: active_storage_attachmentsUncheckedCreateNestedManyWithoutActive_storage_blobsInput
  }

  export type active_storage_blobsCreateOrConnectWithoutActive_storage_variant_recordsInput = {
    where: active_storage_blobsWhereUniqueInput
    create: XOR<active_storage_blobsCreateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_variant_recordsInput>
  }

  export type active_storage_blobsUpsertWithoutActive_storage_variant_recordsInput = {
    update: XOR<active_storage_blobsUpdateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedUpdateWithoutActive_storage_variant_recordsInput>
    create: XOR<active_storage_blobsCreateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedCreateWithoutActive_storage_variant_recordsInput>
    where?: active_storage_blobsWhereInput
  }

  export type active_storage_blobsUpdateToOneWithWhereWithoutActive_storage_variant_recordsInput = {
    where?: active_storage_blobsWhereInput
    data: XOR<active_storage_blobsUpdateWithoutActive_storage_variant_recordsInput, active_storage_blobsUncheckedUpdateWithoutActive_storage_variant_recordsInput>
  }

  export type active_storage_blobsUpdateWithoutActive_storage_variant_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_attachments?: active_storage_attachmentsUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type active_storage_blobsUncheckedUpdateWithoutActive_storage_variant_recordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    service_name?: StringFieldUpdateOperationsInput | string
    byte_size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_storage_attachments?: active_storage_attachmentsUncheckedUpdateManyWithoutActive_storage_blobsNestedInput
  }

  export type accountsCreateWithoutBalancesInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    imports?: importsCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutBalancesInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutBalancesInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutBalancesInput, accountsUncheckedCreateWithoutBalancesInput>
  }

  export type accountsUpsertWithoutBalancesInput = {
    update: XOR<accountsUpdateWithoutBalancesInput, accountsUncheckedUpdateWithoutBalancesInput>
    create: XOR<accountsCreateWithoutBalancesInput, accountsUncheckedCreateWithoutBalancesInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutBalancesInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutBalancesInput, accountsUncheckedUpdateWithoutBalancesInput>
  }

  export type accountsUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    imports?: importsUpdateOneWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type categoriesCreateWithoutBudget_categoriesInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    families: familiesCreateNestedOneWithoutCategoriesInput
    transactions?: transactionsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutBudget_categoriesInput = {
    id?: string
    name: string
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    transactions?: transactionsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutBudget_categoriesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutBudget_categoriesInput, categoriesUncheckedCreateWithoutBudget_categoriesInput>
  }

  export type budgetsCreateWithoutBudget_categoriesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
    families: familiesCreateNestedOneWithoutBudgetsInput
  }

  export type budgetsUncheckedCreateWithoutBudget_categoriesInput = {
    id?: string
    family_id: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budgetsCreateOrConnectWithoutBudget_categoriesInput = {
    where: budgetsWhereUniqueInput
    create: XOR<budgetsCreateWithoutBudget_categoriesInput, budgetsUncheckedCreateWithoutBudget_categoriesInput>
  }

  export type categoriesUpsertWithoutBudget_categoriesInput = {
    update: XOR<categoriesUpdateWithoutBudget_categoriesInput, categoriesUncheckedUpdateWithoutBudget_categoriesInput>
    create: XOR<categoriesCreateWithoutBudget_categoriesInput, categoriesUncheckedCreateWithoutBudget_categoriesInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutBudget_categoriesInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutBudget_categoriesInput, categoriesUncheckedUpdateWithoutBudget_categoriesInput>
  }

  export type categoriesUpdateWithoutBudget_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    families?: familiesUpdateOneRequiredWithoutCategoriesNestedInput
    transactions?: transactionsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutBudget_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    transactions?: transactionsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type budgetsUpsertWithoutBudget_categoriesInput = {
    update: XOR<budgetsUpdateWithoutBudget_categoriesInput, budgetsUncheckedUpdateWithoutBudget_categoriesInput>
    create: XOR<budgetsCreateWithoutBudget_categoriesInput, budgetsUncheckedCreateWithoutBudget_categoriesInput>
    where?: budgetsWhereInput
  }

  export type budgetsUpdateToOneWithWhereWithoutBudget_categoriesInput = {
    where?: budgetsWhereInput
    data: XOR<budgetsUpdateWithoutBudget_categoriesInput, budgetsUncheckedUpdateWithoutBudget_categoriesInput>
  }

  export type budgetsUpdateWithoutBudget_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    families?: familiesUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type budgetsUncheckedUpdateWithoutBudget_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesCreateWithoutBudgetsInput = {
    id?: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    categories: categoriesCreateNestedOneWithoutBudget_categoriesInput
  }

  export type budget_categoriesUncheckedCreateWithoutBudgetsInput = {
    id?: string
    category_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budget_categoriesCreateOrConnectWithoutBudgetsInput = {
    where: budget_categoriesWhereUniqueInput
    create: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput>
  }

  export type budget_categoriesCreateManyBudgetsInputEnvelope = {
    data: budget_categoriesCreateManyBudgetsInput | budget_categoriesCreateManyBudgetsInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutBudgetsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutBudgetsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutBudgetsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutBudgetsInput, familiesUncheckedCreateWithoutBudgetsInput>
  }

  export type budget_categoriesUpsertWithWhereUniqueWithoutBudgetsInput = {
    where: budget_categoriesWhereUniqueInput
    update: XOR<budget_categoriesUpdateWithoutBudgetsInput, budget_categoriesUncheckedUpdateWithoutBudgetsInput>
    create: XOR<budget_categoriesCreateWithoutBudgetsInput, budget_categoriesUncheckedCreateWithoutBudgetsInput>
  }

  export type budget_categoriesUpdateWithWhereUniqueWithoutBudgetsInput = {
    where: budget_categoriesWhereUniqueInput
    data: XOR<budget_categoriesUpdateWithoutBudgetsInput, budget_categoriesUncheckedUpdateWithoutBudgetsInput>
  }

  export type budget_categoriesUpdateManyWithWhereWithoutBudgetsInput = {
    where: budget_categoriesScalarWhereInput
    data: XOR<budget_categoriesUpdateManyMutationInput, budget_categoriesUncheckedUpdateManyWithoutBudgetsInput>
  }

  export type budget_categoriesScalarWhereInput = {
    AND?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
    OR?: budget_categoriesScalarWhereInput[]
    NOT?: budget_categoriesScalarWhereInput | budget_categoriesScalarWhereInput[]
    id?: UuidFilter<"budget_categories"> | string
    budget_id?: UuidFilter<"budget_categories"> | string
    category_id?: UuidFilter<"budget_categories"> | string
    budgeted_spending?: DecimalFilter<"budget_categories"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"budget_categories"> | string
    created_at?: DateTimeFilter<"budget_categories"> | Date | string
    updated_at?: DateTimeFilter<"budget_categories"> | Date | string
  }

  export type familiesUpsertWithoutBudgetsInput = {
    update: XOR<familiesUpdateWithoutBudgetsInput, familiesUncheckedUpdateWithoutBudgetsInput>
    create: XOR<familiesCreateWithoutBudgetsInput, familiesUncheckedCreateWithoutBudgetsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutBudgetsInput, familiesUncheckedUpdateWithoutBudgetsInput>
  }

  export type familiesUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type budget_categoriesCreateWithoutCategoriesInput = {
    id?: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    budgets: budgetsCreateNestedOneWithoutBudget_categoriesInput
  }

  export type budget_categoriesUncheckedCreateWithoutCategoriesInput = {
    id?: string
    budget_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budget_categoriesCreateOrConnectWithoutCategoriesInput = {
    where: budget_categoriesWhereUniqueInput
    create: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type budget_categoriesCreateManyCategoriesInputEnvelope = {
    data: budget_categoriesCreateManyCategoriesInput | budget_categoriesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutCategoriesInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutCategoriesInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutCategoriesInput, familiesUncheckedCreateWithoutCategoriesInput>
  }

  export type transactionsCreateWithoutCategoriesInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutCategoriesInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutCategoriesInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput>
  }

  export type transactionsCreateManyCategoriesInputEnvelope = {
    data: transactionsCreateManyCategoriesInput | transactionsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type budget_categoriesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: budget_categoriesWhereUniqueInput
    update: XOR<budget_categoriesUpdateWithoutCategoriesInput, budget_categoriesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<budget_categoriesCreateWithoutCategoriesInput, budget_categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type budget_categoriesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: budget_categoriesWhereUniqueInput
    data: XOR<budget_categoriesUpdateWithoutCategoriesInput, budget_categoriesUncheckedUpdateWithoutCategoriesInput>
  }

  export type budget_categoriesUpdateManyWithWhereWithoutCategoriesInput = {
    where: budget_categoriesScalarWhereInput
    data: XOR<budget_categoriesUpdateManyMutationInput, budget_categoriesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type familiesUpsertWithoutCategoriesInput = {
    update: XOR<familiesUpdateWithoutCategoriesInput, familiesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<familiesCreateWithoutCategoriesInput, familiesUncheckedCreateWithoutCategoriesInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutCategoriesInput, familiesUncheckedUpdateWithoutCategoriesInput>
  }

  export type familiesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type transactionsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutCategoriesInput, transactionsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<transactionsCreateWithoutCategoriesInput, transactionsUncheckedCreateWithoutCategoriesInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutCategoriesInput, transactionsUncheckedUpdateWithoutCategoriesInput>
  }

  export type transactionsUpdateManyWithWhereWithoutCategoriesInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    OR?: transactionsScalarWhereInput[]
    NOT?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    id?: UuidFilter<"transactions"> | string
    created_at?: DateTimeFilter<"transactions"> | Date | string
    updated_at?: DateTimeFilter<"transactions"> | Date | string
    category_id?: UuidNullableFilter<"transactions"> | string | null
    merchant_id?: UuidNullableFilter<"transactions"> | string | null
    locked_attributes?: JsonNullableFilter<"transactions">
    plaid_category?: StringNullableFilter<"transactions"> | string | null
    plaid_category_detailed?: StringNullableFilter<"transactions"> | string | null
  }

  export type usersCreateWithoutChats_chats_user_idTousersInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChats_chats_user_idTousersInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChats_chats_user_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChats_chats_user_idTousersInput, usersUncheckedCreateWithoutChats_chats_user_idTousersInput>
  }

  export type messagesCreateWithoutChatsInput = {
    id?: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
    tool_calls?: tool_callsCreateNestedManyWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutChatsInput = {
    id?: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
    tool_calls?: tool_callsUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesCreateOrConnectWithoutChatsInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesCreateManyChatsInputEnvelope = {
    data: messagesCreateManyChatsInput | messagesCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChats_users_last_viewed_chat_idTochatsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput>
  }

  export type usersCreateManyChats_users_last_viewed_chat_idTochatsInputEnvelope = {
    data: usersCreateManyChats_users_last_viewed_chat_idTochatsInput | usersCreateManyChats_users_last_viewed_chat_idTochatsInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutChats_chats_user_idTousersInput = {
    update: XOR<usersUpdateWithoutChats_chats_user_idTousersInput, usersUncheckedUpdateWithoutChats_chats_user_idTousersInput>
    create: XOR<usersCreateWithoutChats_chats_user_idTousersInput, usersUncheckedCreateWithoutChats_chats_user_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChats_chats_user_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChats_chats_user_idTousersInput, usersUncheckedUpdateWithoutChats_chats_user_idTousersInput>
  }

  export type usersUpdateWithoutChats_chats_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChats_chats_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type messagesUpsertWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
  }

  export type messagesUpdateManyWithWhereWithoutChatsInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutChatsInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: UuidFilter<"messages"> | string
    chat_id?: UuidFilter<"messages"> | string
    type?: StringFilter<"messages"> | string
    status?: StringFilter<"messages"> | string
    content?: StringNullableFilter<"messages"> | string | null
    ai_model?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    updated_at?: DateTimeFilter<"messages"> | Date | string
    debug?: BoolNullableFilter<"messages"> | boolean | null
    provider_id?: StringNullableFilter<"messages"> | string | null
    reasoning?: BoolNullableFilter<"messages"> | boolean | null
  }

  export type usersUpsertWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedUpdateWithoutChats_users_last_viewed_chat_idTochatsInput>
    create: XOR<usersCreateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedCreateWithoutChats_users_last_viewed_chat_idTochatsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutChats_users_last_viewed_chat_idTochatsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutChats_users_last_viewed_chat_idTochatsInput, usersUncheckedUpdateWithoutChats_users_last_viewed_chat_idTochatsInput>
  }

  export type usersUpdateManyWithWhereWithoutChats_users_last_viewed_chat_idTochatsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: UuidFilter<"users"> | string
    family_id?: UuidFilter<"users"> | string
    first_name?: StringNullableFilter<"users"> | string | null
    last_name?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    password_digest?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role?: StringFilter<"users"> | string
    active?: BoolFilter<"users"> | boolean
    onboarded_at?: DateTimeNullableFilter<"users"> | Date | string | null
    unconfirmed_email?: StringNullableFilter<"users"> | string | null
    otp_secret?: StringNullableFilter<"users"> | string | null
    otp_required?: BoolFilter<"users"> | boolean
    otp_backup_codes?: StringNullableListFilter<"users">
    show_sidebar?: BoolNullableFilter<"users"> | boolean | null
    default_period?: StringFilter<"users"> | string
    last_viewed_chat_id?: UuidNullableFilter<"users"> | string | null
    show_ai_sidebar?: BoolNullableFilter<"users"> | boolean | null
    ai_enabled?: BoolFilter<"users"> | boolean
    theme?: StringNullableFilter<"users"> | string | null
    rule_prompts_disabled?: BoolNullableFilter<"users"> | boolean | null
    rule_prompt_dismissed_at?: DateTimeNullableFilter<"users"> | Date | string | null
    goals?: StringNullableListFilter<"users">
    set_onboarding_preferences_at?: DateTimeNullableFilter<"users"> | Date | string | null
    set_onboarding_goals_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type accountsCreateWithoutEntriesInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    imports?: importsCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutEntriesInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutEntriesInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutEntriesInput, accountsUncheckedCreateWithoutEntriesInput>
  }

  export type importsCreateWithoutEntriesInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsCreateNestedManyWithoutImportsInput
    families: familiesCreateNestedOneWithoutImportsInput
  }

  export type importsUncheckedCreateWithoutEntriesInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    family_id: string
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsUncheckedCreateNestedManyWithoutImportsInput
  }

  export type importsCreateOrConnectWithoutEntriesInput = {
    where: importsWhereUniqueInput
    create: XOR<importsCreateWithoutEntriesInput, importsUncheckedCreateWithoutEntriesInput>
  }

  export type accountsUpsertWithoutEntriesInput = {
    update: XOR<accountsUpdateWithoutEntriesInput, accountsUncheckedUpdateWithoutEntriesInput>
    create: XOR<accountsCreateWithoutEntriesInput, accountsUncheckedCreateWithoutEntriesInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutEntriesInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutEntriesInput, accountsUncheckedUpdateWithoutEntriesInput>
  }

  export type accountsUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    imports?: importsUpdateOneWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type importsUpsertWithoutEntriesInput = {
    update: XOR<importsUpdateWithoutEntriesInput, importsUncheckedUpdateWithoutEntriesInput>
    create: XOR<importsCreateWithoutEntriesInput, importsUncheckedCreateWithoutEntriesInput>
    where?: importsWhereInput
  }

  export type importsUpdateToOneWithWhereWithoutEntriesInput = {
    where?: importsWhereInput
    data: XOR<importsUpdateWithoutEntriesInput, importsUncheckedUpdateWithoutEntriesInput>
  }

  export type importsUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUpdateManyWithoutImportsNestedInput
    families?: familiesUpdateOneRequiredWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUncheckedUpdateManyWithoutImportsNestedInput
  }

  export type accountsCreateWithoutFamiliesInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    imports?: importsCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutFamiliesInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput>
  }

  export type accountsCreateManyFamiliesInputEnvelope = {
    data: accountsCreateManyFamiliesInput | accountsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type budgetsCreateWithoutFamiliesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
    budget_categories?: budget_categoriesCreateNestedManyWithoutBudgetsInput
  }

  export type budgetsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
    budget_categories?: budget_categoriesUncheckedCreateNestedManyWithoutBudgetsInput
  }

  export type budgetsCreateOrConnectWithoutFamiliesInput = {
    where: budgetsWhereUniqueInput
    create: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput>
  }

  export type budgetsCreateManyFamiliesInputEnvelope = {
    data: budgetsCreateManyFamiliesInput | budgetsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutFamiliesInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesCreateNestedManyWithoutCategoriesInput
    transactions?: transactionsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutFamiliesInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutFamiliesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput>
  }

  export type categoriesCreateManyFamiliesInputEnvelope = {
    data: categoriesCreateManyFamiliesInput | categoriesCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type importsCreateWithoutFamiliesInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsCreateNestedManyWithoutImportsInput
    entries?: entriesCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsCreateNestedManyWithoutImportsInput
  }

  export type importsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutImportsInput
    entries?: entriesUncheckedCreateNestedManyWithoutImportsInput
    import_rows?: import_rowsUncheckedCreateNestedManyWithoutImportsInput
  }

  export type importsCreateOrConnectWithoutFamiliesInput = {
    where: importsWhereUniqueInput
    create: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput>
  }

  export type importsCreateManyFamiliesInputEnvelope = {
    data: importsCreateManyFamiliesInput | importsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type invitationsCreateWithoutFamiliesInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
    users: usersCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    inviter_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type invitationsCreateOrConnectWithoutFamiliesInput = {
    where: invitationsWhereUniqueInput
    create: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput>
  }

  export type invitationsCreateManyFamiliesInputEnvelope = {
    data: invitationsCreateManyFamiliesInput | invitationsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type merchantsCreateWithoutFamiliesInput = {
    id?: string
    name: string
    color?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
    transactions?: transactionsCreateNestedManyWithoutMerchantsInput
  }

  export type merchantsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    name: string
    color?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutMerchantsInput
  }

  export type merchantsCreateOrConnectWithoutFamiliesInput = {
    where: merchantsWhereUniqueInput
    create: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput>
  }

  export type merchantsCreateManyFamiliesInputEnvelope = {
    data: merchantsCreateManyFamiliesInput | merchantsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type plaid_itemsCreateWithoutFamiliesInput = {
    id?: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
    plaid_accounts?: plaid_accountsCreateNestedManyWithoutPlaid_itemsInput
  }

  export type plaid_itemsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
    plaid_accounts?: plaid_accountsUncheckedCreateNestedManyWithoutPlaid_itemsInput
  }

  export type plaid_itemsCreateOrConnectWithoutFamiliesInput = {
    where: plaid_itemsWhereUniqueInput
    create: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput>
  }

  export type plaid_itemsCreateManyFamiliesInputEnvelope = {
    data: plaid_itemsCreateManyFamiliesInput | plaid_itemsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type rulesCreateWithoutFamiliesInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsCreateNestedManyWithoutRulesInput
    rule_conditions?: rule_conditionsCreateNestedManyWithoutRulesInput
  }

  export type rulesUncheckedCreateWithoutFamiliesInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsUncheckedCreateNestedManyWithoutRulesInput
    rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRulesInput
  }

  export type rulesCreateOrConnectWithoutFamiliesInput = {
    where: rulesWhereUniqueInput
    create: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput>
  }

  export type rulesCreateManyFamiliesInputEnvelope = {
    data: rulesCreateManyFamiliesInput | rulesCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type tagsCreateWithoutFamiliesInput = {
    id?: string
    name?: string | null
    color?: string
    created_at: Date | string
    updated_at: Date | string
    taggings?: taggingsCreateNestedManyWithoutTagsInput
  }

  export type tagsUncheckedCreateWithoutFamiliesInput = {
    id?: string
    name?: string | null
    color?: string
    created_at: Date | string
    updated_at: Date | string
    taggings?: taggingsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsCreateOrConnectWithoutFamiliesInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput>
  }

  export type tagsCreateManyFamiliesInputEnvelope = {
    data: tagsCreateManyFamiliesInput | tagsCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutFamiliesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
  }

  export type usersUncheckedCreateWithoutFamiliesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFamiliesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput>
  }

  export type usersCreateManyFamiliesInputEnvelope = {
    data: usersCreateManyFamiliesInput | usersCreateManyFamiliesInput[]
    skipDuplicates?: boolean
  }

  export type accountsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutFamiliesInput, accountsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<accountsCreateWithoutFamiliesInput, accountsUncheckedCreateWithoutFamiliesInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutFamiliesInput, accountsUncheckedUpdateWithoutFamiliesInput>
  }

  export type accountsUpdateManyWithWhereWithoutFamiliesInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type accountsScalarWhereInput = {
    AND?: accountsScalarWhereInput | accountsScalarWhereInput[]
    OR?: accountsScalarWhereInput[]
    NOT?: accountsScalarWhereInput | accountsScalarWhereInput[]
    id?: UuidFilter<"accounts"> | string
    subtype?: StringNullableFilter<"accounts"> | string | null
    family_id?: UuidFilter<"accounts"> | string
    name?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    accountable_type?: StringNullableFilter<"accounts"> | string | null
    accountable_id?: UuidNullableFilter<"accounts"> | string | null
    balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"accounts"> | string | null
    is_active?: BoolFilter<"accounts"> | boolean
    classification?: StringNullableFilter<"accounts"> | string | null
    import_id?: UuidNullableFilter<"accounts"> | string | null
    plaid_account_id?: UuidNullableFilter<"accounts"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"accounts"> | boolean | null
    last_synced_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    cash_balance?: DecimalNullableFilter<"accounts"> | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: JsonNullableFilter<"accounts">
  }

  export type budgetsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: budgetsWhereUniqueInput
    update: XOR<budgetsUpdateWithoutFamiliesInput, budgetsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<budgetsCreateWithoutFamiliesInput, budgetsUncheckedCreateWithoutFamiliesInput>
  }

  export type budgetsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: budgetsWhereUniqueInput
    data: XOR<budgetsUpdateWithoutFamiliesInput, budgetsUncheckedUpdateWithoutFamiliesInput>
  }

  export type budgetsUpdateManyWithWhereWithoutFamiliesInput = {
    where: budgetsScalarWhereInput
    data: XOR<budgetsUpdateManyMutationInput, budgetsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type budgetsScalarWhereInput = {
    AND?: budgetsScalarWhereInput | budgetsScalarWhereInput[]
    OR?: budgetsScalarWhereInput[]
    NOT?: budgetsScalarWhereInput | budgetsScalarWhereInput[]
    id?: UuidFilter<"budgets"> | string
    family_id?: UuidFilter<"budgets"> | string
    start_date?: DateTimeFilter<"budgets"> | Date | string
    end_date?: DateTimeFilter<"budgets"> | Date | string
    budgeted_spending?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    expected_income?: DecimalNullableFilter<"budgets"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"budgets"> | string
    created_at?: DateTimeFilter<"budgets"> | Date | string
    updated_at?: DateTimeFilter<"budgets"> | Date | string
  }

  export type categoriesUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutFamiliesInput, categoriesUncheckedUpdateWithoutFamiliesInput>
    create: XOR<categoriesCreateWithoutFamiliesInput, categoriesUncheckedCreateWithoutFamiliesInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutFamiliesInput, categoriesUncheckedUpdateWithoutFamiliesInput>
  }

  export type categoriesUpdateManyWithWhereWithoutFamiliesInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type categoriesScalarWhereInput = {
    AND?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    OR?: categoriesScalarWhereInput[]
    NOT?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    id?: UuidFilter<"categories"> | string
    name?: StringFilter<"categories"> | string
    color?: StringFilter<"categories"> | string
    family_id?: UuidFilter<"categories"> | string
    created_at?: DateTimeFilter<"categories"> | Date | string
    updated_at?: DateTimeFilter<"categories"> | Date | string
    parent_id?: UuidNullableFilter<"categories"> | string | null
    classification?: StringFilter<"categories"> | string
    lucide_icon?: StringFilter<"categories"> | string
  }

  export type importsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: importsWhereUniqueInput
    update: XOR<importsUpdateWithoutFamiliesInput, importsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<importsCreateWithoutFamiliesInput, importsUncheckedCreateWithoutFamiliesInput>
  }

  export type importsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: importsWhereUniqueInput
    data: XOR<importsUpdateWithoutFamiliesInput, importsUncheckedUpdateWithoutFamiliesInput>
  }

  export type importsUpdateManyWithWhereWithoutFamiliesInput = {
    where: importsScalarWhereInput
    data: XOR<importsUpdateManyMutationInput, importsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type importsScalarWhereInput = {
    AND?: importsScalarWhereInput | importsScalarWhereInput[]
    OR?: importsScalarWhereInput[]
    NOT?: importsScalarWhereInput | importsScalarWhereInput[]
    id?: UuidFilter<"imports"> | string
    column_mappings?: JsonNullableFilter<"imports">
    status?: StringNullableFilter<"imports"> | string | null
    raw_file_str?: StringNullableFilter<"imports"> | string | null
    normalized_csv_str?: StringNullableFilter<"imports"> | string | null
    created_at?: DateTimeFilter<"imports"> | Date | string
    updated_at?: DateTimeFilter<"imports"> | Date | string
    col_sep?: StringNullableFilter<"imports"> | string | null
    family_id?: UuidFilter<"imports"> | string
    account_id?: UuidNullableFilter<"imports"> | string | null
    type?: StringFilter<"imports"> | string
    date_col_label?: StringNullableFilter<"imports"> | string | null
    amount_col_label?: StringNullableFilter<"imports"> | string | null
    name_col_label?: StringNullableFilter<"imports"> | string | null
    category_col_label?: StringNullableFilter<"imports"> | string | null
    tags_col_label?: StringNullableFilter<"imports"> | string | null
    account_col_label?: StringNullableFilter<"imports"> | string | null
    qty_col_label?: StringNullableFilter<"imports"> | string | null
    ticker_col_label?: StringNullableFilter<"imports"> | string | null
    price_col_label?: StringNullableFilter<"imports"> | string | null
    entity_type_col_label?: StringNullableFilter<"imports"> | string | null
    notes_col_label?: StringNullableFilter<"imports"> | string | null
    currency_col_label?: StringNullableFilter<"imports"> | string | null
    date_format?: StringNullableFilter<"imports"> | string | null
    signage_convention?: StringNullableFilter<"imports"> | string | null
    error?: StringNullableFilter<"imports"> | string | null
    number_format?: StringNullableFilter<"imports"> | string | null
    exchange_operating_mic_col_label?: StringNullableFilter<"imports"> | string | null
    amount_type_strategy?: StringNullableFilter<"imports"> | string | null
    amount_type_inflow_value?: StringNullableFilter<"imports"> | string | null
  }

  export type invitationsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: invitationsWhereUniqueInput
    update: XOR<invitationsUpdateWithoutFamiliesInput, invitationsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<invitationsCreateWithoutFamiliesInput, invitationsUncheckedCreateWithoutFamiliesInput>
  }

  export type invitationsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: invitationsWhereUniqueInput
    data: XOR<invitationsUpdateWithoutFamiliesInput, invitationsUncheckedUpdateWithoutFamiliesInput>
  }

  export type invitationsUpdateManyWithWhereWithoutFamiliesInput = {
    where: invitationsScalarWhereInput
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type invitationsScalarWhereInput = {
    AND?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    OR?: invitationsScalarWhereInput[]
    NOT?: invitationsScalarWhereInput | invitationsScalarWhereInput[]
    id?: UuidFilter<"invitations"> | string
    email?: StringNullableFilter<"invitations"> | string | null
    role?: StringNullableFilter<"invitations"> | string | null
    token?: StringNullableFilter<"invitations"> | string | null
    family_id?: UuidFilter<"invitations"> | string
    inviter_id?: UuidFilter<"invitations"> | string
    accepted_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"invitations"> | Date | string | null
    created_at?: DateTimeFilter<"invitations"> | Date | string
    updated_at?: DateTimeFilter<"invitations"> | Date | string
  }

  export type merchantsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: merchantsWhereUniqueInput
    update: XOR<merchantsUpdateWithoutFamiliesInput, merchantsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<merchantsCreateWithoutFamiliesInput, merchantsUncheckedCreateWithoutFamiliesInput>
  }

  export type merchantsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: merchantsWhereUniqueInput
    data: XOR<merchantsUpdateWithoutFamiliesInput, merchantsUncheckedUpdateWithoutFamiliesInput>
  }

  export type merchantsUpdateManyWithWhereWithoutFamiliesInput = {
    where: merchantsScalarWhereInput
    data: XOR<merchantsUpdateManyMutationInput, merchantsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type merchantsScalarWhereInput = {
    AND?: merchantsScalarWhereInput | merchantsScalarWhereInput[]
    OR?: merchantsScalarWhereInput[]
    NOT?: merchantsScalarWhereInput | merchantsScalarWhereInput[]
    id?: UuidFilter<"merchants"> | string
    name?: StringFilter<"merchants"> | string
    color?: StringNullableFilter<"merchants"> | string | null
    family_id?: UuidNullableFilter<"merchants"> | string | null
    created_at?: DateTimeFilter<"merchants"> | Date | string
    updated_at?: DateTimeFilter<"merchants"> | Date | string
    logo_url?: StringNullableFilter<"merchants"> | string | null
    website_url?: StringNullableFilter<"merchants"> | string | null
    type?: StringFilter<"merchants"> | string
    source?: StringNullableFilter<"merchants"> | string | null
    provider_merchant_id?: StringNullableFilter<"merchants"> | string | null
  }

  export type plaid_itemsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: plaid_itemsWhereUniqueInput
    update: XOR<plaid_itemsUpdateWithoutFamiliesInput, plaid_itemsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<plaid_itemsCreateWithoutFamiliesInput, plaid_itemsUncheckedCreateWithoutFamiliesInput>
  }

  export type plaid_itemsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: plaid_itemsWhereUniqueInput
    data: XOR<plaid_itemsUpdateWithoutFamiliesInput, plaid_itemsUncheckedUpdateWithoutFamiliesInput>
  }

  export type plaid_itemsUpdateManyWithWhereWithoutFamiliesInput = {
    where: plaid_itemsScalarWhereInput
    data: XOR<plaid_itemsUpdateManyMutationInput, plaid_itemsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type plaid_itemsScalarWhereInput = {
    AND?: plaid_itemsScalarWhereInput | plaid_itemsScalarWhereInput[]
    OR?: plaid_itemsScalarWhereInput[]
    NOT?: plaid_itemsScalarWhereInput | plaid_itemsScalarWhereInput[]
    id?: UuidFilter<"plaid_items"> | string
    family_id?: UuidFilter<"plaid_items"> | string
    access_token?: StringNullableFilter<"plaid_items"> | string | null
    plaid_id?: StringNullableFilter<"plaid_items"> | string | null
    name?: StringNullableFilter<"plaid_items"> | string | null
    next_cursor?: StringNullableFilter<"plaid_items"> | string | null
    scheduled_for_deletion?: BoolNullableFilter<"plaid_items"> | boolean | null
    created_at?: DateTimeFilter<"plaid_items"> | Date | string
    updated_at?: DateTimeFilter<"plaid_items"> | Date | string
    available_products?: StringNullableListFilter<"plaid_items">
    billed_products?: StringNullableListFilter<"plaid_items">
    last_synced_at?: DateTimeNullableFilter<"plaid_items"> | Date | string | null
    plaid_region?: StringFilter<"plaid_items"> | string
    institution_url?: StringNullableFilter<"plaid_items"> | string | null
    institution_id?: StringNullableFilter<"plaid_items"> | string | null
    institution_color?: StringNullableFilter<"plaid_items"> | string | null
    status?: StringFilter<"plaid_items"> | string
  }

  export type rulesUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: rulesWhereUniqueInput
    update: XOR<rulesUpdateWithoutFamiliesInput, rulesUncheckedUpdateWithoutFamiliesInput>
    create: XOR<rulesCreateWithoutFamiliesInput, rulesUncheckedCreateWithoutFamiliesInput>
  }

  export type rulesUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: rulesWhereUniqueInput
    data: XOR<rulesUpdateWithoutFamiliesInput, rulesUncheckedUpdateWithoutFamiliesInput>
  }

  export type rulesUpdateManyWithWhereWithoutFamiliesInput = {
    where: rulesScalarWhereInput
    data: XOR<rulesUpdateManyMutationInput, rulesUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type rulesScalarWhereInput = {
    AND?: rulesScalarWhereInput | rulesScalarWhereInput[]
    OR?: rulesScalarWhereInput[]
    NOT?: rulesScalarWhereInput | rulesScalarWhereInput[]
    id?: UuidFilter<"rules"> | string
    family_id?: UuidFilter<"rules"> | string
    resource_type?: StringFilter<"rules"> | string
    effective_date?: DateTimeNullableFilter<"rules"> | Date | string | null
    active?: BoolFilter<"rules"> | boolean
    created_at?: DateTimeFilter<"rules"> | Date | string
    updated_at?: DateTimeFilter<"rules"> | Date | string
  }

  export type tagsUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: tagsWhereUniqueInput
    update: XOR<tagsUpdateWithoutFamiliesInput, tagsUncheckedUpdateWithoutFamiliesInput>
    create: XOR<tagsCreateWithoutFamiliesInput, tagsUncheckedCreateWithoutFamiliesInput>
  }

  export type tagsUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: tagsWhereUniqueInput
    data: XOR<tagsUpdateWithoutFamiliesInput, tagsUncheckedUpdateWithoutFamiliesInput>
  }

  export type tagsUpdateManyWithWhereWithoutFamiliesInput = {
    where: tagsScalarWhereInput
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type tagsScalarWhereInput = {
    AND?: tagsScalarWhereInput | tagsScalarWhereInput[]
    OR?: tagsScalarWhereInput[]
    NOT?: tagsScalarWhereInput | tagsScalarWhereInput[]
    id?: UuidFilter<"tags"> | string
    name?: StringNullableFilter<"tags"> | string | null
    color?: StringFilter<"tags"> | string
    family_id?: UuidFilter<"tags"> | string
    created_at?: DateTimeFilter<"tags"> | Date | string
    updated_at?: DateTimeFilter<"tags"> | Date | string
  }

  export type usersUpsertWithWhereUniqueWithoutFamiliesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutFamiliesInput, usersUncheckedUpdateWithoutFamiliesInput>
    create: XOR<usersCreateWithoutFamiliesInput, usersUncheckedCreateWithoutFamiliesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutFamiliesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutFamiliesInput, usersUncheckedUpdateWithoutFamiliesInput>
  }

  export type usersUpdateManyWithWhereWithoutFamiliesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutFamiliesInput>
  }

  export type securitiesCreateWithoutHoldingsInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    security_prices?: security_pricesCreateNestedManyWithoutSecuritiesInput
    trades?: tradesCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesUncheckedCreateWithoutHoldingsInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    security_prices?: security_pricesUncheckedCreateNestedManyWithoutSecuritiesInput
    trades?: tradesUncheckedCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesCreateOrConnectWithoutHoldingsInput = {
    where: securitiesWhereUniqueInput
    create: XOR<securitiesCreateWithoutHoldingsInput, securitiesUncheckedCreateWithoutHoldingsInput>
  }

  export type accountsCreateWithoutHoldingsInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    imports?: importsCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutHoldingsInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutHoldingsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutHoldingsInput, accountsUncheckedCreateWithoutHoldingsInput>
  }

  export type securitiesUpsertWithoutHoldingsInput = {
    update: XOR<securitiesUpdateWithoutHoldingsInput, securitiesUncheckedUpdateWithoutHoldingsInput>
    create: XOR<securitiesCreateWithoutHoldingsInput, securitiesUncheckedCreateWithoutHoldingsInput>
    where?: securitiesWhereInput
  }

  export type securitiesUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: securitiesWhereInput
    data: XOR<securitiesUpdateWithoutHoldingsInput, securitiesUncheckedUpdateWithoutHoldingsInput>
  }

  export type securitiesUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    security_prices?: security_pricesUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUpdateManyWithoutSecuritiesNestedInput
  }

  export type securitiesUncheckedUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    security_prices?: security_pricesUncheckedUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUncheckedUpdateManyWithoutSecuritiesNestedInput
  }

  export type accountsUpsertWithoutHoldingsInput = {
    update: XOR<accountsUpdateWithoutHoldingsInput, accountsUncheckedUpdateWithoutHoldingsInput>
    create: XOR<accountsCreateWithoutHoldingsInput, accountsUncheckedCreateWithoutHoldingsInput>
    where?: accountsWhereInput
  }

  export type accountsUpdateToOneWithWhereWithoutHoldingsInput = {
    where?: accountsWhereInput
    data: XOR<accountsUpdateWithoutHoldingsInput, accountsUncheckedUpdateWithoutHoldingsInput>
  }

  export type accountsUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    imports?: importsUpdateOneWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type impersonation_sessionsCreateWithoutImpersonation_session_logsInput = {
    id?: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    users_impersonation_sessions_impersonator_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    users_impersonation_sessions_impersonated_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    sessions?: sessionsCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsUncheckedCreateWithoutImpersonation_session_logsInput = {
    id?: string
    impersonator_id: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    sessions?: sessionsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsCreateOrConnectWithoutImpersonation_session_logsInput = {
    where: impersonation_sessionsWhereUniqueInput
    create: XOR<impersonation_sessionsCreateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedCreateWithoutImpersonation_session_logsInput>
  }

  export type impersonation_sessionsUpsertWithoutImpersonation_session_logsInput = {
    update: XOR<impersonation_sessionsUpdateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedUpdateWithoutImpersonation_session_logsInput>
    create: XOR<impersonation_sessionsCreateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedCreateWithoutImpersonation_session_logsInput>
    where?: impersonation_sessionsWhereInput
  }

  export type impersonation_sessionsUpdateToOneWithWhereWithoutImpersonation_session_logsInput = {
    where?: impersonation_sessionsWhereInput
    data: XOR<impersonation_sessionsUpdateWithoutImpersonation_session_logsInput, impersonation_sessionsUncheckedUpdateWithoutImpersonation_session_logsInput>
  }

  export type impersonation_sessionsUpdateWithoutImpersonation_session_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_impersonation_sessions_impersonator_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersNestedInput
    users_impersonation_sessions_impersonated_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersNestedInput
    sessions?: sessionsUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateWithoutImpersonation_session_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: sessionsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_session_logsCreateWithoutImpersonation_sessionsInput = {
    id?: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput = {
    id?: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_session_logsCreateOrConnectWithoutImpersonation_sessionsInput = {
    where: impersonation_session_logsWhereUniqueInput
    create: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput>
  }

  export type impersonation_session_logsCreateManyImpersonation_sessionsInputEnvelope = {
    data: impersonation_session_logsCreateManyImpersonation_sessionsInput | impersonation_session_logsCreateManyImpersonation_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
  }

  export type usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
  }

  export type sessionsCreateWithoutImpersonation_sessionsInput = {
    id?: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutImpersonation_sessionsInput = {
    id?: string
    user_id: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsCreateOrConnectWithoutImpersonation_sessionsInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput>
  }

  export type sessionsCreateManyImpersonation_sessionsInputEnvelope = {
    data: sessionsCreateManyImpersonation_sessionsInput | sessionsCreateManyImpersonation_sessionsInput[]
    skipDuplicates?: boolean
  }

  export type impersonation_session_logsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput = {
    where: impersonation_session_logsWhereUniqueInput
    update: XOR<impersonation_session_logsUpdateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedUpdateWithoutImpersonation_sessionsInput>
    create: XOR<impersonation_session_logsCreateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedCreateWithoutImpersonation_sessionsInput>
  }

  export type impersonation_session_logsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput = {
    where: impersonation_session_logsWhereUniqueInput
    data: XOR<impersonation_session_logsUpdateWithoutImpersonation_sessionsInput, impersonation_session_logsUncheckedUpdateWithoutImpersonation_sessionsInput>
  }

  export type impersonation_session_logsUpdateManyWithWhereWithoutImpersonation_sessionsInput = {
    where: impersonation_session_logsScalarWhereInput
    data: XOR<impersonation_session_logsUpdateManyMutationInput, impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsInput>
  }

  export type impersonation_session_logsScalarWhereInput = {
    AND?: impersonation_session_logsScalarWhereInput | impersonation_session_logsScalarWhereInput[]
    OR?: impersonation_session_logsScalarWhereInput[]
    NOT?: impersonation_session_logsScalarWhereInput | impersonation_session_logsScalarWhereInput[]
    id?: UuidFilter<"impersonation_session_logs"> | string
    impersonation_session_id?: UuidFilter<"impersonation_session_logs"> | string
    controller?: StringNullableFilter<"impersonation_session_logs"> | string | null
    action?: StringNullableFilter<"impersonation_session_logs"> | string | null
    path?: StringNullableFilter<"impersonation_session_logs"> | string | null
    method?: StringNullableFilter<"impersonation_session_logs"> | string | null
    ip_address?: StringNullableFilter<"impersonation_session_logs"> | string | null
    user_agent?: StringNullableFilter<"impersonation_session_logs"> | string | null
    created_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_session_logs"> | Date | string
  }

  export type usersUpsertWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    update: XOR<usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
    create: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput>
  }

  export type usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    update: XOR<usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
    create: XOR<usersCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedCreateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput, usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput>
  }

  export type usersUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type sessionsUpsertWithWhereUniqueWithoutImpersonation_sessionsInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutImpersonation_sessionsInput, sessionsUncheckedUpdateWithoutImpersonation_sessionsInput>
    create: XOR<sessionsCreateWithoutImpersonation_sessionsInput, sessionsUncheckedCreateWithoutImpersonation_sessionsInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutImpersonation_sessionsInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutImpersonation_sessionsInput, sessionsUncheckedUpdateWithoutImpersonation_sessionsInput>
  }

  export type sessionsUpdateManyWithWhereWithoutImpersonation_sessionsInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutImpersonation_sessionsInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidFilter<"sessions"> | string
    user_agent?: StringNullableFilter<"sessions"> | string | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeFilter<"sessions"> | Date | string
    active_impersonator_session_id?: UuidNullableFilter<"sessions"> | string | null
    subscribed_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    prev_transaction_page_params?: JsonNullableFilter<"sessions">
  }

  export type importsCreateWithoutImport_rowsInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsCreateNestedManyWithoutImportsInput
    entries?: entriesCreateNestedManyWithoutImportsInput
    families: familiesCreateNestedOneWithoutImportsInput
  }

  export type importsUncheckedCreateWithoutImport_rowsInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    family_id: string
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutImportsInput
    entries?: entriesUncheckedCreateNestedManyWithoutImportsInput
  }

  export type importsCreateOrConnectWithoutImport_rowsInput = {
    where: importsWhereUniqueInput
    create: XOR<importsCreateWithoutImport_rowsInput, importsUncheckedCreateWithoutImport_rowsInput>
  }

  export type importsUpsertWithoutImport_rowsInput = {
    update: XOR<importsUpdateWithoutImport_rowsInput, importsUncheckedUpdateWithoutImport_rowsInput>
    create: XOR<importsCreateWithoutImport_rowsInput, importsUncheckedCreateWithoutImport_rowsInput>
    where?: importsWhereInput
  }

  export type importsUpdateToOneWithWhereWithoutImport_rowsInput = {
    where?: importsWhereInput
    data: XOR<importsUpdateWithoutImport_rowsInput, importsUncheckedUpdateWithoutImport_rowsInput>
  }

  export type importsUpdateWithoutImport_rowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutImportsNestedInput
    entries?: entriesUpdateManyWithoutImportsNestedInput
    families?: familiesUpdateOneRequiredWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateWithoutImport_rowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutImportsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutImportsNestedInput
  }

  export type accountsCreateWithoutImportsInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    plaid_accounts?: plaid_accountsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutImportsInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutImportsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput>
  }

  export type accountsCreateManyImportsInputEnvelope = {
    data: accountsCreateManyImportsInput | accountsCreateManyImportsInput[]
    skipDuplicates?: boolean
  }

  export type entriesCreateWithoutImportsInput = {
    id?: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    accounts: accountsCreateNestedOneWithoutEntriesInput
  }

  export type entriesUncheckedCreateWithoutImportsInput = {
    id?: string
    account_id: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesCreateOrConnectWithoutImportsInput = {
    where: entriesWhereUniqueInput
    create: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput>
  }

  export type entriesCreateManyImportsInputEnvelope = {
    data: entriesCreateManyImportsInput | entriesCreateManyImportsInput[]
    skipDuplicates?: boolean
  }

  export type import_rowsCreateWithoutImportsInput = {
    id?: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
  }

  export type import_rowsUncheckedCreateWithoutImportsInput = {
    id?: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
  }

  export type import_rowsCreateOrConnectWithoutImportsInput = {
    where: import_rowsWhereUniqueInput
    create: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput>
  }

  export type import_rowsCreateManyImportsInputEnvelope = {
    data: import_rowsCreateManyImportsInput | import_rowsCreateManyImportsInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutImportsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutImportsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutImportsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutImportsInput, familiesUncheckedCreateWithoutImportsInput>
  }

  export type accountsUpsertWithWhereUniqueWithoutImportsInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutImportsInput, accountsUncheckedUpdateWithoutImportsInput>
    create: XOR<accountsCreateWithoutImportsInput, accountsUncheckedCreateWithoutImportsInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutImportsInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutImportsInput, accountsUncheckedUpdateWithoutImportsInput>
  }

  export type accountsUpdateManyWithWhereWithoutImportsInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutImportsInput>
  }

  export type entriesUpsertWithWhereUniqueWithoutImportsInput = {
    where: entriesWhereUniqueInput
    update: XOR<entriesUpdateWithoutImportsInput, entriesUncheckedUpdateWithoutImportsInput>
    create: XOR<entriesCreateWithoutImportsInput, entriesUncheckedCreateWithoutImportsInput>
  }

  export type entriesUpdateWithWhereUniqueWithoutImportsInput = {
    where: entriesWhereUniqueInput
    data: XOR<entriesUpdateWithoutImportsInput, entriesUncheckedUpdateWithoutImportsInput>
  }

  export type entriesUpdateManyWithWhereWithoutImportsInput = {
    where: entriesScalarWhereInput
    data: XOR<entriesUpdateManyMutationInput, entriesUncheckedUpdateManyWithoutImportsInput>
  }

  export type import_rowsUpsertWithWhereUniqueWithoutImportsInput = {
    where: import_rowsWhereUniqueInput
    update: XOR<import_rowsUpdateWithoutImportsInput, import_rowsUncheckedUpdateWithoutImportsInput>
    create: XOR<import_rowsCreateWithoutImportsInput, import_rowsUncheckedCreateWithoutImportsInput>
  }

  export type import_rowsUpdateWithWhereUniqueWithoutImportsInput = {
    where: import_rowsWhereUniqueInput
    data: XOR<import_rowsUpdateWithoutImportsInput, import_rowsUncheckedUpdateWithoutImportsInput>
  }

  export type import_rowsUpdateManyWithWhereWithoutImportsInput = {
    where: import_rowsScalarWhereInput
    data: XOR<import_rowsUpdateManyMutationInput, import_rowsUncheckedUpdateManyWithoutImportsInput>
  }

  export type import_rowsScalarWhereInput = {
    AND?: import_rowsScalarWhereInput | import_rowsScalarWhereInput[]
    OR?: import_rowsScalarWhereInput[]
    NOT?: import_rowsScalarWhereInput | import_rowsScalarWhereInput[]
    id?: UuidFilter<"import_rows"> | string
    import_id?: UuidFilter<"import_rows"> | string
    account?: StringNullableFilter<"import_rows"> | string | null
    date?: StringNullableFilter<"import_rows"> | string | null
    qty?: StringNullableFilter<"import_rows"> | string | null
    ticker?: StringNullableFilter<"import_rows"> | string | null
    price?: StringNullableFilter<"import_rows"> | string | null
    amount?: StringNullableFilter<"import_rows"> | string | null
    currency?: StringNullableFilter<"import_rows"> | string | null
    name?: StringNullableFilter<"import_rows"> | string | null
    category?: StringNullableFilter<"import_rows"> | string | null
    tags?: StringNullableFilter<"import_rows"> | string | null
    entity_type?: StringNullableFilter<"import_rows"> | string | null
    notes?: StringNullableFilter<"import_rows"> | string | null
    created_at?: DateTimeFilter<"import_rows"> | Date | string
    updated_at?: DateTimeFilter<"import_rows"> | Date | string
    exchange_operating_mic?: StringNullableFilter<"import_rows"> | string | null
  }

  export type familiesUpsertWithoutImportsInput = {
    update: XOR<familiesUpdateWithoutImportsInput, familiesUncheckedUpdateWithoutImportsInput>
    create: XOR<familiesCreateWithoutImportsInput, familiesUncheckedCreateWithoutImportsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutImportsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutImportsInput, familiesUncheckedUpdateWithoutImportsInput>
  }

  export type familiesUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutInvitationsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutInvitationsInput, familiesUncheckedCreateWithoutInvitationsInput>
  }

  export type usersCreateWithoutInvitationsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutInvitationsInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutInvitationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInvitationsInput, usersUncheckedCreateWithoutInvitationsInput>
  }

  export type familiesUpsertWithoutInvitationsInput = {
    update: XOR<familiesUpdateWithoutInvitationsInput, familiesUncheckedUpdateWithoutInvitationsInput>
    create: XOR<familiesCreateWithoutInvitationsInput, familiesUncheckedCreateWithoutInvitationsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutInvitationsInput, familiesUncheckedUpdateWithoutInvitationsInput>
  }

  export type familiesUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type usersUpsertWithoutInvitationsInput = {
    update: XOR<usersUpdateWithoutInvitationsInput, usersUncheckedUpdateWithoutInvitationsInput>
    create: XOR<usersCreateWithoutInvitationsInput, usersUncheckedCreateWithoutInvitationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInvitationsInput, usersUncheckedUpdateWithoutInvitationsInput>
  }

  export type usersUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type familiesCreateWithoutMerchantsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutMerchantsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutMerchantsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutMerchantsInput, familiesUncheckedCreateWithoutMerchantsInput>
  }

  export type transactionsCreateWithoutMerchantsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutMerchantsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutMerchantsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput>
  }

  export type transactionsCreateManyMerchantsInputEnvelope = {
    data: transactionsCreateManyMerchantsInput | transactionsCreateManyMerchantsInput[]
    skipDuplicates?: boolean
  }

  export type familiesUpsertWithoutMerchantsInput = {
    update: XOR<familiesUpdateWithoutMerchantsInput, familiesUncheckedUpdateWithoutMerchantsInput>
    create: XOR<familiesCreateWithoutMerchantsInput, familiesUncheckedCreateWithoutMerchantsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutMerchantsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutMerchantsInput, familiesUncheckedUpdateWithoutMerchantsInput>
  }

  export type familiesUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type transactionsUpsertWithWhereUniqueWithoutMerchantsInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutMerchantsInput, transactionsUncheckedUpdateWithoutMerchantsInput>
    create: XOR<transactionsCreateWithoutMerchantsInput, transactionsUncheckedCreateWithoutMerchantsInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutMerchantsInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutMerchantsInput, transactionsUncheckedUpdateWithoutMerchantsInput>
  }

  export type transactionsUpdateManyWithWhereWithoutMerchantsInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutMerchantsInput>
  }

  export type chatsCreateWithoutMessagesInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    users_chats_user_idTousers: usersCreateNestedOneWithoutChats_chats_user_idTousersInput
    users_users_last_viewed_chat_idTochats?: usersCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsUncheckedCreateWithoutMessagesInput = {
    id?: string
    user_id: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    users_users_last_viewed_chat_idTochats?: usersUncheckedCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsCreateOrConnectWithoutMessagesInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
  }

  export type tool_callsCreateWithoutMessagesInput = {
    id?: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type tool_callsUncheckedCreateWithoutMessagesInput = {
    id?: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type tool_callsCreateOrConnectWithoutMessagesInput = {
    where: tool_callsWhereUniqueInput
    create: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput>
  }

  export type tool_callsCreateManyMessagesInputEnvelope = {
    data: tool_callsCreateManyMessagesInput | tool_callsCreateManyMessagesInput[]
    skipDuplicates?: boolean
  }

  export type chatsUpsertWithoutMessagesInput = {
    update: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutMessagesInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type chatsUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_chats_user_idTousers?: usersUpdateOneRequiredWithoutChats_chats_user_idTousersNestedInput
    users_users_last_viewed_chat_idTochats?: usersUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_users_last_viewed_chat_idTochats?: usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type tool_callsUpsertWithWhereUniqueWithoutMessagesInput = {
    where: tool_callsWhereUniqueInput
    update: XOR<tool_callsUpdateWithoutMessagesInput, tool_callsUncheckedUpdateWithoutMessagesInput>
    create: XOR<tool_callsCreateWithoutMessagesInput, tool_callsUncheckedCreateWithoutMessagesInput>
  }

  export type tool_callsUpdateWithWhereUniqueWithoutMessagesInput = {
    where: tool_callsWhereUniqueInput
    data: XOR<tool_callsUpdateWithoutMessagesInput, tool_callsUncheckedUpdateWithoutMessagesInput>
  }

  export type tool_callsUpdateManyWithWhereWithoutMessagesInput = {
    where: tool_callsScalarWhereInput
    data: XOR<tool_callsUpdateManyMutationInput, tool_callsUncheckedUpdateManyWithoutMessagesInput>
  }

  export type tool_callsScalarWhereInput = {
    AND?: tool_callsScalarWhereInput | tool_callsScalarWhereInput[]
    OR?: tool_callsScalarWhereInput[]
    NOT?: tool_callsScalarWhereInput | tool_callsScalarWhereInput[]
    id?: UuidFilter<"tool_calls"> | string
    message_id?: UuidFilter<"tool_calls"> | string
    provider_id?: StringFilter<"tool_calls"> | string
    provider_call_id?: StringNullableFilter<"tool_calls"> | string | null
    type?: StringFilter<"tool_calls"> | string
    function_name?: StringNullableFilter<"tool_calls"> | string | null
    function_arguments?: JsonNullableFilter<"tool_calls">
    function_result?: JsonNullableFilter<"tool_calls">
    created_at?: DateTimeFilter<"tool_calls"> | Date | string
    updated_at?: DateTimeFilter<"tool_calls"> | Date | string
  }

  export type accountsCreateWithoutPlaid_accountsInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families: familiesCreateNestedOneWithoutAccountsInput
    imports?: importsCreateNestedOneWithoutAccountsInput
    balances?: balancesCreateNestedManyWithoutAccountsInput
    entries?: entriesCreateNestedManyWithoutAccountsInput
    holdings?: holdingsCreateNestedManyWithoutAccountsInput
  }

  export type accountsUncheckedCreateWithoutPlaid_accountsInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedCreateNestedManyWithoutAccountsInput
    entries?: entriesUncheckedCreateNestedManyWithoutAccountsInput
    holdings?: holdingsUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type accountsCreateOrConnectWithoutPlaid_accountsInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput>
  }

  export type accountsCreateManyPlaid_accountsInputEnvelope = {
    data: accountsCreateManyPlaid_accountsInput | accountsCreateManyPlaid_accountsInput[]
    skipDuplicates?: boolean
  }

  export type plaid_itemsCreateWithoutPlaid_accountsInput = {
    id?: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
    families: familiesCreateNestedOneWithoutPlaid_itemsInput
  }

  export type plaid_itemsUncheckedCreateWithoutPlaid_accountsInput = {
    id?: string
    family_id: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
  }

  export type plaid_itemsCreateOrConnectWithoutPlaid_accountsInput = {
    where: plaid_itemsWhereUniqueInput
    create: XOR<plaid_itemsCreateWithoutPlaid_accountsInput, plaid_itemsUncheckedCreateWithoutPlaid_accountsInput>
  }

  export type accountsUpsertWithWhereUniqueWithoutPlaid_accountsInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutPlaid_accountsInput, accountsUncheckedUpdateWithoutPlaid_accountsInput>
    create: XOR<accountsCreateWithoutPlaid_accountsInput, accountsUncheckedCreateWithoutPlaid_accountsInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutPlaid_accountsInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutPlaid_accountsInput, accountsUncheckedUpdateWithoutPlaid_accountsInput>
  }

  export type accountsUpdateManyWithWhereWithoutPlaid_accountsInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutPlaid_accountsInput>
  }

  export type plaid_itemsUpsertWithoutPlaid_accountsInput = {
    update: XOR<plaid_itemsUpdateWithoutPlaid_accountsInput, plaid_itemsUncheckedUpdateWithoutPlaid_accountsInput>
    create: XOR<plaid_itemsCreateWithoutPlaid_accountsInput, plaid_itemsUncheckedCreateWithoutPlaid_accountsInput>
    where?: plaid_itemsWhereInput
  }

  export type plaid_itemsUpdateToOneWithWhereWithoutPlaid_accountsInput = {
    where?: plaid_itemsWhereInput
    data: XOR<plaid_itemsUpdateWithoutPlaid_accountsInput, plaid_itemsUncheckedUpdateWithoutPlaid_accountsInput>
  }

  export type plaid_itemsUpdateWithoutPlaid_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    families?: familiesUpdateOneRequiredWithoutPlaid_itemsNestedInput
  }

  export type plaid_itemsUncheckedUpdateWithoutPlaid_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type plaid_accountsCreateWithoutPlaid_itemsInput = {
    id?: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
    accounts?: accountsCreateNestedManyWithoutPlaid_accountsInput
  }

  export type plaid_accountsUncheckedCreateWithoutPlaid_itemsInput = {
    id?: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
    accounts?: accountsUncheckedCreateNestedManyWithoutPlaid_accountsInput
  }

  export type plaid_accountsCreateOrConnectWithoutPlaid_itemsInput = {
    where: plaid_accountsWhereUniqueInput
    create: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput>
  }

  export type plaid_accountsCreateManyPlaid_itemsInputEnvelope = {
    data: plaid_accountsCreateManyPlaid_itemsInput | plaid_accountsCreateManyPlaid_itemsInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutPlaid_itemsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutPlaid_itemsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutPlaid_itemsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutPlaid_itemsInput, familiesUncheckedCreateWithoutPlaid_itemsInput>
  }

  export type plaid_accountsUpsertWithWhereUniqueWithoutPlaid_itemsInput = {
    where: plaid_accountsWhereUniqueInput
    update: XOR<plaid_accountsUpdateWithoutPlaid_itemsInput, plaid_accountsUncheckedUpdateWithoutPlaid_itemsInput>
    create: XOR<plaid_accountsCreateWithoutPlaid_itemsInput, plaid_accountsUncheckedCreateWithoutPlaid_itemsInput>
  }

  export type plaid_accountsUpdateWithWhereUniqueWithoutPlaid_itemsInput = {
    where: plaid_accountsWhereUniqueInput
    data: XOR<plaid_accountsUpdateWithoutPlaid_itemsInput, plaid_accountsUncheckedUpdateWithoutPlaid_itemsInput>
  }

  export type plaid_accountsUpdateManyWithWhereWithoutPlaid_itemsInput = {
    where: plaid_accountsScalarWhereInput
    data: XOR<plaid_accountsUpdateManyMutationInput, plaid_accountsUncheckedUpdateManyWithoutPlaid_itemsInput>
  }

  export type plaid_accountsScalarWhereInput = {
    AND?: plaid_accountsScalarWhereInput | plaid_accountsScalarWhereInput[]
    OR?: plaid_accountsScalarWhereInput[]
    NOT?: plaid_accountsScalarWhereInput | plaid_accountsScalarWhereInput[]
    id?: UuidFilter<"plaid_accounts"> | string
    plaid_item_id?: UuidFilter<"plaid_accounts"> | string
    plaid_id?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_type?: StringNullableFilter<"plaid_accounts"> | string | null
    plaid_subtype?: StringNullableFilter<"plaid_accounts"> | string | null
    current_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    available_balance?: DecimalNullableFilter<"plaid_accounts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"plaid_accounts"> | string | null
    name?: StringNullableFilter<"plaid_accounts"> | string | null
    mask?: StringNullableFilter<"plaid_accounts"> | string | null
    created_at?: DateTimeFilter<"plaid_accounts"> | Date | string
    updated_at?: DateTimeFilter<"plaid_accounts"> | Date | string
  }

  export type familiesUpsertWithoutPlaid_itemsInput = {
    update: XOR<familiesUpdateWithoutPlaid_itemsInput, familiesUncheckedUpdateWithoutPlaid_itemsInput>
    create: XOR<familiesCreateWithoutPlaid_itemsInput, familiesUncheckedCreateWithoutPlaid_itemsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutPlaid_itemsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutPlaid_itemsInput, familiesUncheckedUpdateWithoutPlaid_itemsInput>
  }

  export type familiesUpdateWithoutPlaid_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutPlaid_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type transactionsCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpsertWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    update: XOR<transactionsUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
    create: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUpsertWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    update: XOR<transactionsUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
    create: XOR<transactionsCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type rulesCreateWithoutRule_actionsInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_conditions?: rule_conditionsCreateNestedManyWithoutRulesInput
    families: familiesCreateNestedOneWithoutRulesInput
  }

  export type rulesUncheckedCreateWithoutRule_actionsInput = {
    id?: string
    family_id: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRulesInput
  }

  export type rulesCreateOrConnectWithoutRule_actionsInput = {
    where: rulesWhereUniqueInput
    create: XOR<rulesCreateWithoutRule_actionsInput, rulesUncheckedCreateWithoutRule_actionsInput>
  }

  export type rulesUpsertWithoutRule_actionsInput = {
    update: XOR<rulesUpdateWithoutRule_actionsInput, rulesUncheckedUpdateWithoutRule_actionsInput>
    create: XOR<rulesCreateWithoutRule_actionsInput, rulesUncheckedCreateWithoutRule_actionsInput>
    where?: rulesWhereInput
  }

  export type rulesUpdateToOneWithWhereWithoutRule_actionsInput = {
    where?: rulesWhereInput
    data: XOR<rulesUpdateWithoutRule_actionsInput, rulesUncheckedUpdateWithoutRule_actionsInput>
  }

  export type rulesUpdateWithoutRule_actionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_conditions?: rule_conditionsUpdateManyWithoutRulesNestedInput
    families?: familiesUpdateOneRequiredWithoutRulesNestedInput
  }

  export type rulesUncheckedUpdateWithoutRule_actionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type rule_conditionsCreateWithoutOther_rule_conditionsInput = {
    id?: string
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    rule_conditions?: rule_conditionsCreateNestedOneWithoutOther_rule_conditionsInput
    rules?: rulesCreateNestedOneWithoutRule_conditionsInput
  }

  export type rule_conditionsUncheckedCreateWithoutOther_rule_conditionsInput = {
    id?: string
    rule_id?: string | null
    parent_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_conditionsCreateOrConnectWithoutOther_rule_conditionsInput = {
    where: rule_conditionsWhereUniqueInput
    create: XOR<rule_conditionsCreateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedCreateWithoutOther_rule_conditionsInput>
  }

  export type rule_conditionsCreateWithoutRule_conditionsInput = {
    id?: string
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    other_rule_conditions?: rule_conditionsCreateNestedManyWithoutRule_conditionsInput
    rules?: rulesCreateNestedOneWithoutRule_conditionsInput
  }

  export type rule_conditionsUncheckedCreateWithoutRule_conditionsInput = {
    id?: string
    rule_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    other_rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRule_conditionsInput
  }

  export type rule_conditionsCreateOrConnectWithoutRule_conditionsInput = {
    where: rule_conditionsWhereUniqueInput
    create: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput>
  }

  export type rule_conditionsCreateManyRule_conditionsInputEnvelope = {
    data: rule_conditionsCreateManyRule_conditionsInput | rule_conditionsCreateManyRule_conditionsInput[]
    skipDuplicates?: boolean
  }

  export type rulesCreateWithoutRule_conditionsInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsCreateNestedManyWithoutRulesInput
    families: familiesCreateNestedOneWithoutRulesInput
  }

  export type rulesUncheckedCreateWithoutRule_conditionsInput = {
    id?: string
    family_id: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
    rule_actions?: rule_actionsUncheckedCreateNestedManyWithoutRulesInput
  }

  export type rulesCreateOrConnectWithoutRule_conditionsInput = {
    where: rulesWhereUniqueInput
    create: XOR<rulesCreateWithoutRule_conditionsInput, rulesUncheckedCreateWithoutRule_conditionsInput>
  }

  export type rule_conditionsUpsertWithoutOther_rule_conditionsInput = {
    update: XOR<rule_conditionsUpdateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedUpdateWithoutOther_rule_conditionsInput>
    create: XOR<rule_conditionsCreateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedCreateWithoutOther_rule_conditionsInput>
    where?: rule_conditionsWhereInput
  }

  export type rule_conditionsUpdateToOneWithWhereWithoutOther_rule_conditionsInput = {
    where?: rule_conditionsWhereInput
    data: XOR<rule_conditionsUpdateWithoutOther_rule_conditionsInput, rule_conditionsUncheckedUpdateWithoutOther_rule_conditionsInput>
  }

  export type rule_conditionsUpdateWithoutOther_rule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_conditions?: rule_conditionsUpdateOneWithoutOther_rule_conditionsNestedInput
    rules?: rulesUpdateOneWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateWithoutOther_rule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_conditionsUpsertWithWhereUniqueWithoutRule_conditionsInput = {
    where: rule_conditionsWhereUniqueInput
    update: XOR<rule_conditionsUpdateWithoutRule_conditionsInput, rule_conditionsUncheckedUpdateWithoutRule_conditionsInput>
    create: XOR<rule_conditionsCreateWithoutRule_conditionsInput, rule_conditionsUncheckedCreateWithoutRule_conditionsInput>
  }

  export type rule_conditionsUpdateWithWhereUniqueWithoutRule_conditionsInput = {
    where: rule_conditionsWhereUniqueInput
    data: XOR<rule_conditionsUpdateWithoutRule_conditionsInput, rule_conditionsUncheckedUpdateWithoutRule_conditionsInput>
  }

  export type rule_conditionsUpdateManyWithWhereWithoutRule_conditionsInput = {
    where: rule_conditionsScalarWhereInput
    data: XOR<rule_conditionsUpdateManyMutationInput, rule_conditionsUncheckedUpdateManyWithoutRule_conditionsInput>
  }

  export type rule_conditionsScalarWhereInput = {
    AND?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
    OR?: rule_conditionsScalarWhereInput[]
    NOT?: rule_conditionsScalarWhereInput | rule_conditionsScalarWhereInput[]
    id?: UuidFilter<"rule_conditions"> | string
    rule_id?: UuidNullableFilter<"rule_conditions"> | string | null
    parent_id?: UuidNullableFilter<"rule_conditions"> | string | null
    condition_type?: StringFilter<"rule_conditions"> | string
    operator?: StringFilter<"rule_conditions"> | string
    value?: StringNullableFilter<"rule_conditions"> | string | null
    created_at?: DateTimeFilter<"rule_conditions"> | Date | string
    updated_at?: DateTimeFilter<"rule_conditions"> | Date | string
  }

  export type rulesUpsertWithoutRule_conditionsInput = {
    update: XOR<rulesUpdateWithoutRule_conditionsInput, rulesUncheckedUpdateWithoutRule_conditionsInput>
    create: XOR<rulesCreateWithoutRule_conditionsInput, rulesUncheckedCreateWithoutRule_conditionsInput>
    where?: rulesWhereInput
  }

  export type rulesUpdateToOneWithWhereWithoutRule_conditionsInput = {
    where?: rulesWhereInput
    data: XOR<rulesUpdateWithoutRule_conditionsInput, rulesUncheckedUpdateWithoutRule_conditionsInput>
  }

  export type rulesUpdateWithoutRule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUpdateManyWithoutRulesNestedInput
    families?: familiesUpdateOneRequiredWithoutRulesNestedInput
  }

  export type rulesUncheckedUpdateWithoutRule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type rule_actionsCreateWithoutRulesInput = {
    id?: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_actionsUncheckedCreateWithoutRulesInput = {
    id?: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_actionsCreateOrConnectWithoutRulesInput = {
    where: rule_actionsWhereUniqueInput
    create: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput>
  }

  export type rule_actionsCreateManyRulesInputEnvelope = {
    data: rule_actionsCreateManyRulesInput | rule_actionsCreateManyRulesInput[]
    skipDuplicates?: boolean
  }

  export type rule_conditionsCreateWithoutRulesInput = {
    id?: string
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    rule_conditions?: rule_conditionsCreateNestedOneWithoutOther_rule_conditionsInput
    other_rule_conditions?: rule_conditionsCreateNestedManyWithoutRule_conditionsInput
  }

  export type rule_conditionsUncheckedCreateWithoutRulesInput = {
    id?: string
    parent_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
    other_rule_conditions?: rule_conditionsUncheckedCreateNestedManyWithoutRule_conditionsInput
  }

  export type rule_conditionsCreateOrConnectWithoutRulesInput = {
    where: rule_conditionsWhereUniqueInput
    create: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput>
  }

  export type rule_conditionsCreateManyRulesInputEnvelope = {
    data: rule_conditionsCreateManyRulesInput | rule_conditionsCreateManyRulesInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutRulesInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutRulesInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutRulesInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutRulesInput, familiesUncheckedCreateWithoutRulesInput>
  }

  export type rule_actionsUpsertWithWhereUniqueWithoutRulesInput = {
    where: rule_actionsWhereUniqueInput
    update: XOR<rule_actionsUpdateWithoutRulesInput, rule_actionsUncheckedUpdateWithoutRulesInput>
    create: XOR<rule_actionsCreateWithoutRulesInput, rule_actionsUncheckedCreateWithoutRulesInput>
  }

  export type rule_actionsUpdateWithWhereUniqueWithoutRulesInput = {
    where: rule_actionsWhereUniqueInput
    data: XOR<rule_actionsUpdateWithoutRulesInput, rule_actionsUncheckedUpdateWithoutRulesInput>
  }

  export type rule_actionsUpdateManyWithWhereWithoutRulesInput = {
    where: rule_actionsScalarWhereInput
    data: XOR<rule_actionsUpdateManyMutationInput, rule_actionsUncheckedUpdateManyWithoutRulesInput>
  }

  export type rule_actionsScalarWhereInput = {
    AND?: rule_actionsScalarWhereInput | rule_actionsScalarWhereInput[]
    OR?: rule_actionsScalarWhereInput[]
    NOT?: rule_actionsScalarWhereInput | rule_actionsScalarWhereInput[]
    id?: UuidFilter<"rule_actions"> | string
    rule_id?: UuidFilter<"rule_actions"> | string
    action_type?: StringFilter<"rule_actions"> | string
    value?: StringNullableFilter<"rule_actions"> | string | null
    created_at?: DateTimeFilter<"rule_actions"> | Date | string
    updated_at?: DateTimeFilter<"rule_actions"> | Date | string
  }

  export type rule_conditionsUpsertWithWhereUniqueWithoutRulesInput = {
    where: rule_conditionsWhereUniqueInput
    update: XOR<rule_conditionsUpdateWithoutRulesInput, rule_conditionsUncheckedUpdateWithoutRulesInput>
    create: XOR<rule_conditionsCreateWithoutRulesInput, rule_conditionsUncheckedCreateWithoutRulesInput>
  }

  export type rule_conditionsUpdateWithWhereUniqueWithoutRulesInput = {
    where: rule_conditionsWhereUniqueInput
    data: XOR<rule_conditionsUpdateWithoutRulesInput, rule_conditionsUncheckedUpdateWithoutRulesInput>
  }

  export type rule_conditionsUpdateManyWithWhereWithoutRulesInput = {
    where: rule_conditionsScalarWhereInput
    data: XOR<rule_conditionsUpdateManyMutationInput, rule_conditionsUncheckedUpdateManyWithoutRulesInput>
  }

  export type familiesUpsertWithoutRulesInput = {
    update: XOR<familiesUpdateWithoutRulesInput, familiesUncheckedUpdateWithoutRulesInput>
    create: XOR<familiesCreateWithoutRulesInput, familiesUncheckedCreateWithoutRulesInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutRulesInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutRulesInput, familiesUncheckedUpdateWithoutRulesInput>
  }

  export type familiesUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type holdingsCreateWithoutSecuritiesInput = {
    id?: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
    accounts: accountsCreateNestedOneWithoutHoldingsInput
  }

  export type holdingsUncheckedCreateWithoutSecuritiesInput = {
    id?: string
    account_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type holdingsCreateOrConnectWithoutSecuritiesInput = {
    where: holdingsWhereUniqueInput
    create: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput>
  }

  export type holdingsCreateManySecuritiesInputEnvelope = {
    data: holdingsCreateManySecuritiesInput | holdingsCreateManySecuritiesInput[]
    skipDuplicates?: boolean
  }

  export type security_pricesCreateWithoutSecuritiesInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type security_pricesUncheckedCreateWithoutSecuritiesInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type security_pricesCreateOrConnectWithoutSecuritiesInput = {
    where: security_pricesWhereUniqueInput
    create: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput>
  }

  export type security_pricesCreateManySecuritiesInputEnvelope = {
    data: security_pricesCreateManySecuritiesInput | security_pricesCreateManySecuritiesInput[]
    skipDuplicates?: boolean
  }

  export type tradesCreateWithoutSecuritiesInput = {
    id?: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUncheckedCreateWithoutSecuritiesInput = {
    id?: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesCreateOrConnectWithoutSecuritiesInput = {
    where: tradesWhereUniqueInput
    create: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput>
  }

  export type tradesCreateManySecuritiesInputEnvelope = {
    data: tradesCreateManySecuritiesInput | tradesCreateManySecuritiesInput[]
    skipDuplicates?: boolean
  }

  export type holdingsUpsertWithWhereUniqueWithoutSecuritiesInput = {
    where: holdingsWhereUniqueInput
    update: XOR<holdingsUpdateWithoutSecuritiesInput, holdingsUncheckedUpdateWithoutSecuritiesInput>
    create: XOR<holdingsCreateWithoutSecuritiesInput, holdingsUncheckedCreateWithoutSecuritiesInput>
  }

  export type holdingsUpdateWithWhereUniqueWithoutSecuritiesInput = {
    where: holdingsWhereUniqueInput
    data: XOR<holdingsUpdateWithoutSecuritiesInput, holdingsUncheckedUpdateWithoutSecuritiesInput>
  }

  export type holdingsUpdateManyWithWhereWithoutSecuritiesInput = {
    where: holdingsScalarWhereInput
    data: XOR<holdingsUpdateManyMutationInput, holdingsUncheckedUpdateManyWithoutSecuritiesInput>
  }

  export type security_pricesUpsertWithWhereUniqueWithoutSecuritiesInput = {
    where: security_pricesWhereUniqueInput
    update: XOR<security_pricesUpdateWithoutSecuritiesInput, security_pricesUncheckedUpdateWithoutSecuritiesInput>
    create: XOR<security_pricesCreateWithoutSecuritiesInput, security_pricesUncheckedCreateWithoutSecuritiesInput>
  }

  export type security_pricesUpdateWithWhereUniqueWithoutSecuritiesInput = {
    where: security_pricesWhereUniqueInput
    data: XOR<security_pricesUpdateWithoutSecuritiesInput, security_pricesUncheckedUpdateWithoutSecuritiesInput>
  }

  export type security_pricesUpdateManyWithWhereWithoutSecuritiesInput = {
    where: security_pricesScalarWhereInput
    data: XOR<security_pricesUpdateManyMutationInput, security_pricesUncheckedUpdateManyWithoutSecuritiesInput>
  }

  export type security_pricesScalarWhereInput = {
    AND?: security_pricesScalarWhereInput | security_pricesScalarWhereInput[]
    OR?: security_pricesScalarWhereInput[]
    NOT?: security_pricesScalarWhereInput | security_pricesScalarWhereInput[]
    id?: UuidFilter<"security_prices"> | string
    date?: DateTimeFilter<"security_prices"> | Date | string
    price?: DecimalFilter<"security_prices"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"security_prices"> | string
    created_at?: DateTimeFilter<"security_prices"> | Date | string
    updated_at?: DateTimeFilter<"security_prices"> | Date | string
    security_id?: UuidNullableFilter<"security_prices"> | string | null
  }

  export type tradesUpsertWithWhereUniqueWithoutSecuritiesInput = {
    where: tradesWhereUniqueInput
    update: XOR<tradesUpdateWithoutSecuritiesInput, tradesUncheckedUpdateWithoutSecuritiesInput>
    create: XOR<tradesCreateWithoutSecuritiesInput, tradesUncheckedCreateWithoutSecuritiesInput>
  }

  export type tradesUpdateWithWhereUniqueWithoutSecuritiesInput = {
    where: tradesWhereUniqueInput
    data: XOR<tradesUpdateWithoutSecuritiesInput, tradesUncheckedUpdateWithoutSecuritiesInput>
  }

  export type tradesUpdateManyWithWhereWithoutSecuritiesInput = {
    where: tradesScalarWhereInput
    data: XOR<tradesUpdateManyMutationInput, tradesUncheckedUpdateManyWithoutSecuritiesInput>
  }

  export type tradesScalarWhereInput = {
    AND?: tradesScalarWhereInput | tradesScalarWhereInput[]
    OR?: tradesScalarWhereInput[]
    NOT?: tradesScalarWhereInput | tradesScalarWhereInput[]
    id?: UuidFilter<"trades"> | string
    security_id?: UuidFilter<"trades"> | string
    qty?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    price?: DecimalNullableFilter<"trades"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"trades"> | Date | string
    updated_at?: DateTimeFilter<"trades"> | Date | string
    currency?: StringNullableFilter<"trades"> | string | null
    locked_attributes?: JsonNullableFilter<"trades">
  }

  export type securitiesCreateWithoutSecurity_pricesInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsCreateNestedManyWithoutSecuritiesInput
    trades?: tradesCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesUncheckedCreateWithoutSecurity_pricesInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsUncheckedCreateNestedManyWithoutSecuritiesInput
    trades?: tradesUncheckedCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesCreateOrConnectWithoutSecurity_pricesInput = {
    where: securitiesWhereUniqueInput
    create: XOR<securitiesCreateWithoutSecurity_pricesInput, securitiesUncheckedCreateWithoutSecurity_pricesInput>
  }

  export type securitiesUpsertWithoutSecurity_pricesInput = {
    update: XOR<securitiesUpdateWithoutSecurity_pricesInput, securitiesUncheckedUpdateWithoutSecurity_pricesInput>
    create: XOR<securitiesCreateWithoutSecurity_pricesInput, securitiesUncheckedCreateWithoutSecurity_pricesInput>
    where?: securitiesWhereInput
  }

  export type securitiesUpdateToOneWithWhereWithoutSecurity_pricesInput = {
    where?: securitiesWhereInput
    data: XOR<securitiesUpdateWithoutSecurity_pricesInput, securitiesUncheckedUpdateWithoutSecurity_pricesInput>
  }

  export type securitiesUpdateWithoutSecurity_pricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUpdateManyWithoutSecuritiesNestedInput
  }

  export type securitiesUncheckedUpdateWithoutSecurity_pricesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUncheckedUpdateManyWithoutSecuritiesNestedInput
    trades?: tradesUncheckedUpdateManyWithoutSecuritiesNestedInput
  }

  export type impersonation_sessionsCreateWithoutSessionsInput = {
    id?: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsCreateNestedManyWithoutImpersonation_sessionsInput
    users_impersonation_sessions_impersonator_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    users_impersonation_sessions_impersonated_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
  }

  export type impersonation_sessionsUncheckedCreateWithoutSessionsInput = {
    id?: string
    impersonator_id: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsCreateOrConnectWithoutSessionsInput = {
    where: impersonation_sessionsWhereUniqueInput
    create: XOR<impersonation_sessionsCreateWithoutSessionsInput, impersonation_sessionsUncheckedCreateWithoutSessionsInput>
  }

  export type usersCreateWithoutSessionsInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsCreateNestedManyWithoutUsersInput
    chats_users_last_viewed_chat_idTochats?: chatsCreateNestedOneWithoutUsers_users_last_viewed_chat_idTochatsInput
    families: familiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedCreateNestedManyWithoutUsers_chats_user_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedCreateNestedManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type impersonation_sessionsUpsertWithoutSessionsInput = {
    update: XOR<impersonation_sessionsUpdateWithoutSessionsInput, impersonation_sessionsUncheckedUpdateWithoutSessionsInput>
    create: XOR<impersonation_sessionsCreateWithoutSessionsInput, impersonation_sessionsUncheckedCreateWithoutSessionsInput>
    where?: impersonation_sessionsWhereInput
  }

  export type impersonation_sessionsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: impersonation_sessionsWhereInput
    data: XOR<impersonation_sessionsUpdateWithoutSessionsInput, impersonation_sessionsUncheckedUpdateWithoutSessionsInput>
  }

  export type impersonation_sessionsUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUpdateManyWithoutImpersonation_sessionsNestedInput
    users_impersonation_sessions_impersonator_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersNestedInput
    users_impersonation_sessions_impersonated_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type syncsCreateWithoutOther_syncsInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    syncs?: syncsCreateNestedOneWithoutOther_syncsInput
  }

  export type syncsUncheckedCreateWithoutOther_syncsInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    parent_id?: string | null
  }

  export type syncsCreateOrConnectWithoutOther_syncsInput = {
    where: syncsWhereUniqueInput
    create: XOR<syncsCreateWithoutOther_syncsInput, syncsUncheckedCreateWithoutOther_syncsInput>
  }

  export type syncsCreateWithoutSyncsInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    other_syncs?: syncsCreateNestedManyWithoutSyncsInput
  }

  export type syncsUncheckedCreateWithoutSyncsInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
    other_syncs?: syncsUncheckedCreateNestedManyWithoutSyncsInput
  }

  export type syncsCreateOrConnectWithoutSyncsInput = {
    where: syncsWhereUniqueInput
    create: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput>
  }

  export type syncsCreateManySyncsInputEnvelope = {
    data: syncsCreateManySyncsInput | syncsCreateManySyncsInput[]
    skipDuplicates?: boolean
  }

  export type syncsUpsertWithoutOther_syncsInput = {
    update: XOR<syncsUpdateWithoutOther_syncsInput, syncsUncheckedUpdateWithoutOther_syncsInput>
    create: XOR<syncsCreateWithoutOther_syncsInput, syncsUncheckedCreateWithoutOther_syncsInput>
    where?: syncsWhereInput
  }

  export type syncsUpdateToOneWithWhereWithoutOther_syncsInput = {
    where?: syncsWhereInput
    data: XOR<syncsUpdateWithoutOther_syncsInput, syncsUncheckedUpdateWithoutOther_syncsInput>
  }

  export type syncsUpdateWithoutOther_syncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    syncs?: syncsUpdateOneWithoutOther_syncsNestedInput
  }

  export type syncsUncheckedUpdateWithoutOther_syncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type syncsUpsertWithWhereUniqueWithoutSyncsInput = {
    where: syncsWhereUniqueInput
    update: XOR<syncsUpdateWithoutSyncsInput, syncsUncheckedUpdateWithoutSyncsInput>
    create: XOR<syncsCreateWithoutSyncsInput, syncsUncheckedCreateWithoutSyncsInput>
  }

  export type syncsUpdateWithWhereUniqueWithoutSyncsInput = {
    where: syncsWhereUniqueInput
    data: XOR<syncsUpdateWithoutSyncsInput, syncsUncheckedUpdateWithoutSyncsInput>
  }

  export type syncsUpdateManyWithWhereWithoutSyncsInput = {
    where: syncsScalarWhereInput
    data: XOR<syncsUpdateManyMutationInput, syncsUncheckedUpdateManyWithoutSyncsInput>
  }

  export type syncsScalarWhereInput = {
    AND?: syncsScalarWhereInput | syncsScalarWhereInput[]
    OR?: syncsScalarWhereInput[]
    NOT?: syncsScalarWhereInput | syncsScalarWhereInput[]
    id?: UuidFilter<"syncs"> | string
    syncable_type?: StringFilter<"syncs"> | string
    syncable_id?: UuidFilter<"syncs"> | string
    last_ran_at?: DateTimeNullableFilter<"syncs"> | Date | string | null
    start_date?: DateTimeNullableFilter<"syncs"> | Date | string | null
    status?: StringNullableFilter<"syncs"> | string | null
    error?: StringNullableFilter<"syncs"> | string | null
    data?: JsonNullableFilter<"syncs">
    created_at?: DateTimeFilter<"syncs"> | Date | string
    updated_at?: DateTimeFilter<"syncs"> | Date | string
    error_backtrace?: StringNullableListFilter<"syncs">
    parent_id?: UuidNullableFilter<"syncs"> | string | null
  }

  export type tagsCreateWithoutTaggingsInput = {
    id?: string
    name?: string | null
    color?: string
    created_at: Date | string
    updated_at: Date | string
    families: familiesCreateNestedOneWithoutTagsInput
  }

  export type tagsUncheckedCreateWithoutTaggingsInput = {
    id?: string
    name?: string | null
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type tagsCreateOrConnectWithoutTaggingsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutTaggingsInput, tagsUncheckedCreateWithoutTaggingsInput>
  }

  export type tagsUpsertWithoutTaggingsInput = {
    update: XOR<tagsUpdateWithoutTaggingsInput, tagsUncheckedUpdateWithoutTaggingsInput>
    create: XOR<tagsCreateWithoutTaggingsInput, tagsUncheckedCreateWithoutTaggingsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutTaggingsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutTaggingsInput, tagsUncheckedUpdateWithoutTaggingsInput>
  }

  export type tagsUpdateWithoutTaggingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    families?: familiesUpdateOneRequiredWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateWithoutTaggingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taggingsCreateWithoutTagsInput = {
    id?: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type taggingsUncheckedCreateWithoutTagsInput = {
    id?: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type taggingsCreateOrConnectWithoutTagsInput = {
    where: taggingsWhereUniqueInput
    create: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput>
  }

  export type taggingsCreateManyTagsInputEnvelope = {
    data: taggingsCreateManyTagsInput | taggingsCreateManyTagsInput[]
    skipDuplicates?: boolean
  }

  export type familiesCreateWithoutTagsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    users?: usersCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutTagsInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    users?: usersUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutTagsInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutTagsInput, familiesUncheckedCreateWithoutTagsInput>
  }

  export type taggingsUpsertWithWhereUniqueWithoutTagsInput = {
    where: taggingsWhereUniqueInput
    update: XOR<taggingsUpdateWithoutTagsInput, taggingsUncheckedUpdateWithoutTagsInput>
    create: XOR<taggingsCreateWithoutTagsInput, taggingsUncheckedCreateWithoutTagsInput>
  }

  export type taggingsUpdateWithWhereUniqueWithoutTagsInput = {
    where: taggingsWhereUniqueInput
    data: XOR<taggingsUpdateWithoutTagsInput, taggingsUncheckedUpdateWithoutTagsInput>
  }

  export type taggingsUpdateManyWithWhereWithoutTagsInput = {
    where: taggingsScalarWhereInput
    data: XOR<taggingsUpdateManyMutationInput, taggingsUncheckedUpdateManyWithoutTagsInput>
  }

  export type taggingsScalarWhereInput = {
    AND?: taggingsScalarWhereInput | taggingsScalarWhereInput[]
    OR?: taggingsScalarWhereInput[]
    NOT?: taggingsScalarWhereInput | taggingsScalarWhereInput[]
    id?: UuidFilter<"taggings"> | string
    tag_id?: UuidFilter<"taggings"> | string
    taggable_type?: StringNullableFilter<"taggings"> | string | null
    taggable_id?: UuidNullableFilter<"taggings"> | string | null
    created_at?: DateTimeFilter<"taggings"> | Date | string
    updated_at?: DateTimeFilter<"taggings"> | Date | string
  }

  export type familiesUpsertWithoutTagsInput = {
    update: XOR<familiesUpdateWithoutTagsInput, familiesUncheckedUpdateWithoutTagsInput>
    create: XOR<familiesCreateWithoutTagsInput, familiesUncheckedCreateWithoutTagsInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutTagsInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutTagsInput, familiesUncheckedUpdateWithoutTagsInput>
  }

  export type familiesUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    users?: usersUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    users?: usersUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type messagesCreateWithoutTool_callsInput = {
    id?: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
    chats: chatsCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutTool_callsInput = {
    id?: string
    chat_id: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
  }

  export type messagesCreateOrConnectWithoutTool_callsInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutTool_callsInput, messagesUncheckedCreateWithoutTool_callsInput>
  }

  export type messagesUpsertWithoutTool_callsInput = {
    update: XOR<messagesUpdateWithoutTool_callsInput, messagesUncheckedUpdateWithoutTool_callsInput>
    create: XOR<messagesCreateWithoutTool_callsInput, messagesUncheckedCreateWithoutTool_callsInput>
    where?: messagesWhereInput
  }

  export type messagesUpdateToOneWithWhereWithoutTool_callsInput = {
    where?: messagesWhereInput
    data: XOR<messagesUpdateWithoutTool_callsInput, messagesUncheckedUpdateWithoutTool_callsInput>
  }

  export type messagesUpdateWithoutTool_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chats?: chatsUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutTool_callsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type securitiesCreateWithoutTradesInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsCreateNestedManyWithoutSecuritiesInput
    security_prices?: security_pricesCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesUncheckedCreateWithoutTradesInput = {
    id?: string
    ticker: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    country_code?: string | null
    exchange_mic?: string | null
    exchange_acronym?: string | null
    logo_url?: string | null
    exchange_operating_mic?: string | null
    holdings?: holdingsUncheckedCreateNestedManyWithoutSecuritiesInput
    security_prices?: security_pricesUncheckedCreateNestedManyWithoutSecuritiesInput
  }

  export type securitiesCreateOrConnectWithoutTradesInput = {
    where: securitiesWhereUniqueInput
    create: XOR<securitiesCreateWithoutTradesInput, securitiesUncheckedCreateWithoutTradesInput>
  }

  export type securitiesUpsertWithoutTradesInput = {
    update: XOR<securitiesUpdateWithoutTradesInput, securitiesUncheckedUpdateWithoutTradesInput>
    create: XOR<securitiesCreateWithoutTradesInput, securitiesUncheckedCreateWithoutTradesInput>
    where?: securitiesWhereInput
  }

  export type securitiesUpdateToOneWithWhereWithoutTradesInput = {
    where?: securitiesWhereInput
    data: XOR<securitiesUpdateWithoutTradesInput, securitiesUncheckedUpdateWithoutTradesInput>
  }

  export type securitiesUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUpdateManyWithoutSecuritiesNestedInput
    security_prices?: security_pricesUpdateManyWithoutSecuritiesNestedInput
  }

  export type securitiesUncheckedUpdateWithoutTradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    country_code?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_mic?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_acronym?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
    holdings?: holdingsUncheckedUpdateManyWithoutSecuritiesNestedInput
    security_prices?: security_pricesUncheckedUpdateManyWithoutSecuritiesNestedInput
  }

  export type rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    transactions_rejected_transfers_inflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsInput
  }

  export type rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    inflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    create: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInputEnvelope = {
    data: rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput | rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput[]
    skipDuplicates?: boolean
  }

  export type rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsInput
  }

  export type rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    outflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersCreateOrConnectWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    create: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInputEnvelope = {
    data: rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput | rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutTransactionsInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesCreateNestedManyWithoutCategoriesInput
    families: familiesCreateNestedOneWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    color?: string
    family_id: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
    budget_categories?: budget_categoriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutTransactionsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutTransactionsInput, categoriesUncheckedCreateWithoutTransactionsInput>
  }

  export type merchantsCreateWithoutTransactionsInput = {
    id?: string
    name: string
    color?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
    families?: familiesCreateNestedOneWithoutMerchantsInput
  }

  export type merchantsUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    color?: string | null
    family_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
  }

  export type merchantsCreateOrConnectWithoutTransactionsInput = {
    where: merchantsWhereUniqueInput
    create: XOR<merchantsCreateWithoutTransactionsInput, merchantsUncheckedCreateWithoutTransactionsInput>
  }

  export type transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    transactions_transfers_inflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    inflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersCreateOrConnectWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    create: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInputEnvelope = {
    data: transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInput | transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInput[]
    skipDuplicates?: boolean
  }

  export type transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    transactions_transfers_outflow_transaction_idTotransactions: transactionsCreateNestedOneWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput
  }

  export type transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    outflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersCreateOrConnectWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    create: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInputEnvelope = {
    data: transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInput | transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInput[]
    skipDuplicates?: boolean
  }

  export type rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    update: XOR<rejected_transfersUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput>
    create: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    data: XOR<rejected_transfersUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput, rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    where: rejected_transfersScalarWhereInput
    data: XOR<rejected_transfersUpdateManyMutationInput, rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersScalarWhereInput = {
    AND?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
    OR?: rejected_transfersScalarWhereInput[]
    NOT?: rejected_transfersScalarWhereInput | rejected_transfersScalarWhereInput[]
    id?: UuidFilter<"rejected_transfers"> | string
    inflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    outflow_transaction_id?: UuidFilter<"rejected_transfers"> | string
    created_at?: DateTimeFilter<"rejected_transfers"> | Date | string
    updated_at?: DateTimeFilter<"rejected_transfers"> | Date | string
  }

  export type rejected_transfersUpsertWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    update: XOR<rejected_transfersUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput>
    create: XOR<rejected_transfersCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedCreateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersUpdateWithWhereUniqueWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where: rejected_transfersWhereUniqueInput
    data: XOR<rejected_transfersUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput, rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type rejected_transfersUpdateManyWithWhereWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    where: rejected_transfersScalarWhereInput
    data: XOR<rejected_transfersUpdateManyMutationInput, rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type categoriesUpsertWithoutTransactionsInput = {
    update: XOR<categoriesUpdateWithoutTransactionsInput, categoriesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<categoriesCreateWithoutTransactionsInput, categoriesUncheckedCreateWithoutTransactionsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutTransactionsInput, categoriesUncheckedUpdateWithoutTransactionsInput>
  }

  export type categoriesUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUpdateManyWithoutCategoriesNestedInput
    families?: familiesUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type merchantsUpsertWithoutTransactionsInput = {
    update: XOR<merchantsUpdateWithoutTransactionsInput, merchantsUncheckedUpdateWithoutTransactionsInput>
    create: XOR<merchantsCreateWithoutTransactionsInput, merchantsUncheckedCreateWithoutTransactionsInput>
    where?: merchantsWhereInput
  }

  export type merchantsUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: merchantsWhereInput
    data: XOR<merchantsUpdateWithoutTransactionsInput, merchantsUncheckedUpdateWithoutTransactionsInput>
  }

  export type merchantsUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    families?: familiesUpdateOneWithoutMerchantsNestedInput
  }

  export type merchantsUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transfersUpsertWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    update: XOR<transfersUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput>
    create: XOR<transfersCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transfersUpdateWithWhereUniqueWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    data: XOR<transfersUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput, transfersUncheckedUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transfersUpdateManyWithWhereWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    where: transfersScalarWhereInput
    data: XOR<transfersUpdateManyMutationInput, transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transfersScalarWhereInput = {
    AND?: transfersScalarWhereInput | transfersScalarWhereInput[]
    OR?: transfersScalarWhereInput[]
    NOT?: transfersScalarWhereInput | transfersScalarWhereInput[]
    id?: UuidFilter<"transfers"> | string
    inflow_transaction_id?: UuidFilter<"transfers"> | string
    outflow_transaction_id?: UuidFilter<"transfers"> | string
    status?: StringFilter<"transfers"> | string
    notes?: StringNullableFilter<"transfers"> | string | null
    created_at?: DateTimeFilter<"transfers"> | Date | string
    updated_at?: DateTimeFilter<"transfers"> | Date | string
  }

  export type transfersUpsertWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    update: XOR<transfersUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput>
    create: XOR<transfersCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedCreateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transfersUpdateWithWhereUniqueWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    where: transfersWhereUniqueInput
    data: XOR<transfersUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput, transfersUncheckedUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transfersUpdateManyWithWhereWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    where: transfersScalarWhereInput
    data: XOR<transfersUpdateManyMutationInput, transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transactionsCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    categories?: categoriesCreateNestedOneWithoutTransactionsInput
    merchants?: merchantsCreateNestedOneWithoutTransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedCreateNestedManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedCreateNestedManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput
  }

  export type transactionsCreateOrConnectWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpsertWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    update: XOR<transactionsUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
    create: XOR<transactionsCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransfers_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUpsertWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    update: XOR<transactionsUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
    create: XOR<transactionsCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedCreateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput, transactionsUncheckedUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput>
  }

  export type transactionsUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransfers_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
  }

  export type chatsCreateWithoutUsers_chats_user_idTousersInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    messages?: messagesCreateNestedManyWithoutChatsInput
    users_users_last_viewed_chat_idTochats?: usersCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
    users_users_last_viewed_chat_idTochats?: usersUncheckedCreateNestedManyWithoutChats_users_last_viewed_chat_idTochatsInput
  }

  export type chatsCreateOrConnectWithoutUsers_chats_user_idTousersInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput>
  }

  export type chatsCreateManyUsers_chats_user_idTousersInputEnvelope = {
    data: chatsCreateManyUsers_chats_user_idTousersInput | chatsCreateManyUsers_chats_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsCreateNestedManyWithoutImpersonation_sessionsInput
    users_impersonation_sessions_impersonated_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersInput
    sessions?: sessionsCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    create: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput>
  }

  export type impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInputEnvelope = {
    data: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInput | impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsCreateNestedManyWithoutImpersonation_sessionsInput
    users_impersonation_sessions_impersonator_idTousers: usersCreateNestedOneWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersInput
    sessions?: sessionsCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: string
    impersonator_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutImpersonation_sessionsInput
  }

  export type impersonation_sessionsCreateOrConnectWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    create: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput>
  }

  export type impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInputEnvelope = {
    data: impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInput | impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type invitationsCreateWithoutUsersInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
    families: familiesCreateNestedOneWithoutInvitationsInput
  }

  export type invitationsUncheckedCreateWithoutUsersInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    family_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type invitationsCreateOrConnectWithoutUsersInput = {
    where: invitationsWhereUniqueInput
    create: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput>
  }

  export type invitationsCreateManyUsersInputEnvelope = {
    data: invitationsCreateManyUsersInput | invitationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUsersInput = {
    id?: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    impersonation_sessions?: impersonation_sessionsCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutUsersInput = {
    id?: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    active_impersonator_session_id?: string | null
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsCreateOrConnectWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsCreateManyUsersInputEnvelope = {
    data: sessionsCreateManyUsersInput | sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type chatsCreateWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    users_chats_user_idTousers: usersCreateNestedOneWithoutChats_chats_user_idTousersInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    id?: string
    user_id: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedCreateWithoutUsers_users_last_viewed_chat_idTochatsInput>
  }

  export type familiesCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsCreateNestedManyWithoutFamiliesInput
    categories?: categoriesCreateNestedManyWithoutFamiliesInput
    imports?: importsCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsCreateNestedManyWithoutFamiliesInput
    rules?: rulesCreateNestedManyWithoutFamiliesInput
    tags?: tagsCreateNestedManyWithoutFamiliesInput
  }

  export type familiesUncheckedCreateWithoutUsersInput = {
    id?: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locale?: string | null
    stripe_plan_id?: string | null
    stripe_customer_id?: string | null
    stripe_subscription_status?: string | null
    date_format?: string | null
    country?: string | null
    last_synced_at?: Date | string | null
    timezone?: string | null
    data_enrichment_enabled?: boolean | null
    trial_started_at?: Date | string | null
    early_access?: boolean | null
    accounts?: accountsUncheckedCreateNestedManyWithoutFamiliesInput
    budgets?: budgetsUncheckedCreateNestedManyWithoutFamiliesInput
    categories?: categoriesUncheckedCreateNestedManyWithoutFamiliesInput
    imports?: importsUncheckedCreateNestedManyWithoutFamiliesInput
    invitations?: invitationsUncheckedCreateNestedManyWithoutFamiliesInput
    merchants?: merchantsUncheckedCreateNestedManyWithoutFamiliesInput
    plaid_items?: plaid_itemsUncheckedCreateNestedManyWithoutFamiliesInput
    rules?: rulesUncheckedCreateNestedManyWithoutFamiliesInput
    tags?: tagsUncheckedCreateNestedManyWithoutFamiliesInput
  }

  export type familiesCreateOrConnectWithoutUsersInput = {
    where: familiesWhereUniqueInput
    create: XOR<familiesCreateWithoutUsersInput, familiesUncheckedCreateWithoutUsersInput>
  }

  export type chatsUpsertWithWhereUniqueWithoutUsers_chats_user_idTousersInput = {
    where: chatsWhereUniqueInput
    update: XOR<chatsUpdateWithoutUsers_chats_user_idTousersInput, chatsUncheckedUpdateWithoutUsers_chats_user_idTousersInput>
    create: XOR<chatsCreateWithoutUsers_chats_user_idTousersInput, chatsUncheckedCreateWithoutUsers_chats_user_idTousersInput>
  }

  export type chatsUpdateWithWhereUniqueWithoutUsers_chats_user_idTousersInput = {
    where: chatsWhereUniqueInput
    data: XOR<chatsUpdateWithoutUsers_chats_user_idTousersInput, chatsUncheckedUpdateWithoutUsers_chats_user_idTousersInput>
  }

  export type chatsUpdateManyWithWhereWithoutUsers_chats_user_idTousersInput = {
    where: chatsScalarWhereInput
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersInput>
  }

  export type chatsScalarWhereInput = {
    AND?: chatsScalarWhereInput | chatsScalarWhereInput[]
    OR?: chatsScalarWhereInput[]
    NOT?: chatsScalarWhereInput | chatsScalarWhereInput[]
    id?: UuidFilter<"chats"> | string
    user_id?: UuidFilter<"chats"> | string
    title?: StringFilter<"chats"> | string
    instructions?: StringNullableFilter<"chats"> | string | null
    error?: JsonNullableFilter<"chats">
    latest_assistant_response_id?: StringNullableFilter<"chats"> | string | null
    created_at?: DateTimeFilter<"chats"> | Date | string
    updated_at?: DateTimeFilter<"chats"> | Date | string
  }

  export type impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    update: XOR<impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput>
    create: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonator_idTousersInput>
  }

  export type impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    data: XOR<impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput, impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput>
  }

  export type impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    where: impersonation_sessionsScalarWhereInput
    data: XOR<impersonation_sessionsUpdateManyMutationInput, impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput>
  }

  export type impersonation_sessionsScalarWhereInput = {
    AND?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
    OR?: impersonation_sessionsScalarWhereInput[]
    NOT?: impersonation_sessionsScalarWhereInput | impersonation_sessionsScalarWhereInput[]
    id?: UuidFilter<"impersonation_sessions"> | string
    impersonator_id?: UuidFilter<"impersonation_sessions"> | string
    impersonated_id?: UuidFilter<"impersonation_sessions"> | string
    status?: StringFilter<"impersonation_sessions"> | string
    created_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
    updated_at?: DateTimeFilter<"impersonation_sessions"> | Date | string
  }

  export type impersonation_sessionsUpsertWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    update: XOR<impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput>
    create: XOR<impersonation_sessionsCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedCreateWithoutUsers_impersonation_sessions_impersonated_idTousersInput>
  }

  export type impersonation_sessionsUpdateWithWhereUniqueWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    where: impersonation_sessionsWhereUniqueInput
    data: XOR<impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput, impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput>
  }

  export type impersonation_sessionsUpdateManyWithWhereWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    where: impersonation_sessionsScalarWhereInput
    data: XOR<impersonation_sessionsUpdateManyMutationInput, impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput>
  }

  export type invitationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: invitationsWhereUniqueInput
    update: XOR<invitationsUpdateWithoutUsersInput, invitationsUncheckedUpdateWithoutUsersInput>
    create: XOR<invitationsCreateWithoutUsersInput, invitationsUncheckedCreateWithoutUsersInput>
  }

  export type invitationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: invitationsWhereUniqueInput
    data: XOR<invitationsUpdateWithoutUsersInput, invitationsUncheckedUpdateWithoutUsersInput>
  }

  export type invitationsUpdateManyWithWhereWithoutUsersInput = {
    where: invitationsScalarWhereInput
    data: XOR<invitationsUpdateManyMutationInput, invitationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type chatsUpsertWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    update: XOR<chatsUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput>
    create: XOR<chatsCreateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedCreateWithoutUsers_users_last_viewed_chat_idTochatsInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput, chatsUncheckedUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput>
  }

  export type chatsUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users_chats_user_idTousers?: usersUpdateOneRequiredWithoutChats_chats_user_idTousersNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutUsers_users_last_viewed_chat_idTochatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type familiesUpsertWithoutUsersInput = {
    update: XOR<familiesUpdateWithoutUsersInput, familiesUncheckedUpdateWithoutUsersInput>
    create: XOR<familiesCreateWithoutUsersInput, familiesUncheckedCreateWithoutUsersInput>
    where?: familiesWhereInput
  }

  export type familiesUpdateToOneWithWhereWithoutUsersInput = {
    where?: familiesWhereInput
    data: XOR<familiesUpdateWithoutUsersInput, familiesUncheckedUpdateWithoutUsersInput>
  }

  export type familiesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUpdateManyWithoutFamiliesNestedInput
    imports?: importsUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUpdateManyWithoutFamiliesNestedInput
  }

  export type familiesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_subscription_status?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    data_enrichment_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    trial_started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    early_access?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accounts?: accountsUncheckedUpdateManyWithoutFamiliesNestedInput
    budgets?: budgetsUncheckedUpdateManyWithoutFamiliesNestedInput
    categories?: categoriesUncheckedUpdateManyWithoutFamiliesNestedInput
    imports?: importsUncheckedUpdateManyWithoutFamiliesNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutFamiliesNestedInput
    merchants?: merchantsUncheckedUpdateManyWithoutFamiliesNestedInput
    plaid_items?: plaid_itemsUncheckedUpdateManyWithoutFamiliesNestedInput
    rules?: rulesUncheckedUpdateManyWithoutFamiliesNestedInput
    tags?: tagsUncheckedUpdateManyWithoutFamiliesNestedInput
  }

  export type balancesCreateManyAccountsInput = {
    id?: string
    date: Date | string
    balance: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
    cash_balance?: Decimal | DecimalJsLike | number | string | null
  }

  export type entriesCreateManyAccountsInput = {
    id?: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    import_id?: string | null
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type holdingsCreateManyAccountsInput = {
    id?: string
    security_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type balancesUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type balancesUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type entriesUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    imports?: importsUpdateOneWithoutEntriesNestedInput
  }

  export type entriesUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type holdingsUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    securities?: securitiesUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type holdingsUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type holdingsUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    security_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_attachmentsCreateManyActive_storage_blobsInput = {
    id?: string
    name: string
    record_type: string
    record_id: string
    created_at: Date | string
  }

  export type active_storage_variant_recordsCreateManyActive_storage_blobsInput = {
    id?: string
    variation_digest: string
  }

  export type active_storage_attachmentsUpdateWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_attachmentsUncheckedUpdateWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_attachmentsUncheckedUpdateManyWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    record_type?: StringFieldUpdateOperationsInput | string
    record_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type active_storage_variant_recordsUpdateWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type active_storage_variant_recordsUncheckedUpdateWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type active_storage_variant_recordsUncheckedUpdateManyWithoutActive_storage_blobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    variation_digest?: StringFieldUpdateOperationsInput | string
  }

  export type budget_categoriesCreateManyBudgetsInput = {
    id?: string
    category_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type budget_categoriesUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneRequiredWithoutBudget_categoriesNestedInput
  }

  export type budget_categoriesUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesUncheckedUpdateManyWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesCreateManyCategoriesInput = {
    id?: string
    budget_id: string
    budgeted_spending: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type transactionsCreateManyCategoriesInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    merchant_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
  }

  export type budget_categoriesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    budgets?: budgetsUpdateOneRequiredWithoutBudget_categoriesNestedInput
  }

  export type budget_categoriesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type budget_categoriesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    budget_id?: StringFieldUpdateOperationsInput | string
    budgeted_spending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    merchants?: merchantsUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesCreateManyChatsInput = {
    id?: string
    type: string
    status?: string
    content?: string | null
    ai_model?: string | null
    created_at: Date | string
    updated_at: Date | string
    debug?: boolean | null
    provider_id?: string | null
    reasoning?: boolean | null
  }

  export type usersCreateManyChats_users_last_viewed_chat_idTochatsInput = {
    id?: string
    family_id: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
  }

  export type messagesUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tool_calls?: tool_callsUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tool_calls?: tool_callsUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ai_model?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    debug?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    reasoning?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpdateWithoutChats_users_last_viewed_chat_idTochatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    families?: familiesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChats_users_last_viewed_chat_idTochatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    family_id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsCreateManyFamiliesInput = {
    id?: string
    subtype?: string | null
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type budgetsCreateManyFamiliesInput = {
    id?: string
    start_date: Date | string
    end_date: Date | string
    budgeted_spending?: Decimal | DecimalJsLike | number | string | null
    expected_income?: Decimal | DecimalJsLike | number | string | null
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type categoriesCreateManyFamiliesInput = {
    id?: string
    name: string
    color?: string
    created_at: Date | string
    updated_at: Date | string
    parent_id?: string | null
    classification?: string
    lucide_icon?: string
  }

  export type importsCreateManyFamiliesInput = {
    id?: string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: string | null
    raw_file_str?: string | null
    normalized_csv_str?: string | null
    created_at: Date | string
    updated_at: Date | string
    col_sep?: string | null
    account_id?: string | null
    type: string
    date_col_label?: string | null
    amount_col_label?: string | null
    name_col_label?: string | null
    category_col_label?: string | null
    tags_col_label?: string | null
    account_col_label?: string | null
    qty_col_label?: string | null
    ticker_col_label?: string | null
    price_col_label?: string | null
    entity_type_col_label?: string | null
    notes_col_label?: string | null
    currency_col_label?: string | null
    date_format?: string | null
    signage_convention?: string | null
    error?: string | null
    number_format?: string | null
    exchange_operating_mic_col_label?: string | null
    amount_type_strategy?: string | null
    amount_type_inflow_value?: string | null
  }

  export type invitationsCreateManyFamiliesInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    inviter_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type merchantsCreateManyFamiliesInput = {
    id?: string
    name: string
    color?: string | null
    created_at: Date | string
    updated_at: Date | string
    logo_url?: string | null
    website_url?: string | null
    type: string
    source?: string | null
    provider_merchant_id?: string | null
  }

  export type plaid_itemsCreateManyFamiliesInput = {
    id?: string
    access_token?: string | null
    plaid_id?: string | null
    name?: string | null
    next_cursor?: string | null
    scheduled_for_deletion?: boolean | null
    created_at: Date | string
    updated_at: Date | string
    available_products?: plaid_itemsCreateavailable_productsInput | string[]
    billed_products?: plaid_itemsCreatebilled_productsInput | string[]
    last_synced_at?: Date | string | null
    plaid_region?: string
    institution_url?: string | null
    institution_id?: string | null
    institution_color?: string | null
    status?: string
  }

  export type rulesCreateManyFamiliesInput = {
    id?: string
    resource_type: string
    effective_date?: Date | string | null
    active?: boolean
    created_at: Date | string
    updated_at: Date | string
  }

  export type tagsCreateManyFamiliesInput = {
    id?: string
    name?: string | null
    color?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type usersCreateManyFamiliesInput = {
    id?: string
    first_name?: string | null
    last_name?: string | null
    email?: string | null
    password_digest?: string | null
    created_at: Date | string
    updated_at: Date | string
    role?: string
    active?: boolean
    onboarded_at?: Date | string | null
    unconfirmed_email?: string | null
    otp_secret?: string | null
    otp_required?: boolean
    otp_backup_codes?: usersCreateotp_backup_codesInput | string[]
    show_sidebar?: boolean | null
    default_period?: string
    last_viewed_chat_id?: string | null
    show_ai_sidebar?: boolean | null
    ai_enabled?: boolean
    theme?: string | null
    rule_prompts_disabled?: boolean | null
    rule_prompt_dismissed_at?: Date | string | null
    goals?: usersCreategoalsInput | string[]
    set_onboarding_preferences_at?: Date | string | null
    set_onboarding_goals_at?: Date | string | null
  }

  export type accountsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    imports?: importsUpdateOneWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type budgetsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_categories?: budget_categoriesUpdateManyWithoutBudgetsNestedInput
  }

  export type budgetsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    budget_categories?: budget_categoriesUncheckedUpdateManyWithoutBudgetsNestedInput
  }

  export type budgetsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    budgeted_spending?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expected_income?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoriesUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUpdateManyWithoutCategoriesNestedInput
    transactions?: transactionsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
    budget_categories?: budget_categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    classification?: StringFieldUpdateOperationsInput | string
    lucide_icon?: StringFieldUpdateOperationsInput | string
  }

  export type importsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutImportsNestedInput
    entries?: entriesUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUpdateManyWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutImportsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutImportsNestedInput
    import_rows?: import_rowsUncheckedUpdateManyWithoutImportsNestedInput
  }

  export type importsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    column_mappings?: NullableJsonNullValueInput | InputJsonValue
    status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_file_str?: NullableStringFieldUpdateOperationsInput | string | null
    normalized_csv_str?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    col_sep?: NullableStringFieldUpdateOperationsInput | string | null
    account_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    date_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    name_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    category_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    tags_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    account_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    qty_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    ticker_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    price_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    notes_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    currency_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    date_format?: NullableStringFieldUpdateOperationsInput | string | null
    signage_convention?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    number_format?: NullableStringFieldUpdateOperationsInput | string | null
    exchange_operating_mic_col_label?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_strategy?: NullableStringFieldUpdateOperationsInput | string | null
    amount_type_inflow_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type invitationsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    inviter_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    inviter_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type merchantsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateManyWithoutMerchantsNestedInput
  }

  export type merchantsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutMerchantsNestedInput
  }

  export type merchantsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    website_url?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    provider_merchant_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plaid_itemsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plaid_accounts?: plaid_accountsUpdateManyWithoutPlaid_itemsNestedInput
  }

  export type plaid_itemsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    plaid_accounts?: plaid_accountsUncheckedUpdateManyWithoutPlaid_itemsNestedInput
  }

  export type plaid_itemsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    next_cursor?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    available_products?: plaid_itemsUpdateavailable_productsInput | string[]
    billed_products?: plaid_itemsUpdatebilled_productsInput | string[]
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    plaid_region?: StringFieldUpdateOperationsInput | string
    institution_url?: NullableStringFieldUpdateOperationsInput | string | null
    institution_id?: NullableStringFieldUpdateOperationsInput | string | null
    institution_color?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type rulesUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUpdateManyWithoutRulesNestedInput
    rule_conditions?: rule_conditionsUpdateManyWithoutRulesNestedInput
  }

  export type rulesUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_actions?: rule_actionsUncheckedUpdateManyWithoutRulesNestedInput
    rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type rulesUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource_type?: StringFieldUpdateOperationsInput | string
    effective_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tagsUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    taggings?: taggingsUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    taggings?: taggingsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    color?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    chats_users_last_viewed_chat_idTochats?: chatsUpdateOneWithoutUsers_users_last_viewed_chat_idTochatsNestedInput
  }

  export type usersUncheckedUpdateWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chats_chats_user_idTousers?: chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonator_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersNestedInput
    impersonation_sessions_impersonation_sessions_impersonated_idTousers?: impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersNestedInput
    invitations?: invitationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutFamiliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password_digest?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    onboarded_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unconfirmed_email?: NullableStringFieldUpdateOperationsInput | string | null
    otp_secret?: NullableStringFieldUpdateOperationsInput | string | null
    otp_required?: BoolFieldUpdateOperationsInput | boolean
    otp_backup_codes?: usersUpdateotp_backup_codesInput | string[]
    show_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    default_period?: StringFieldUpdateOperationsInput | string
    last_viewed_chat_id?: NullableStringFieldUpdateOperationsInput | string | null
    show_ai_sidebar?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ai_enabled?: BoolFieldUpdateOperationsInput | boolean
    theme?: NullableStringFieldUpdateOperationsInput | string | null
    rule_prompts_disabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rule_prompt_dismissed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    goals?: usersUpdategoalsInput | string[]
    set_onboarding_preferences_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    set_onboarding_goals_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type impersonation_session_logsCreateManyImpersonation_sessionsInput = {
    id?: string
    controller?: string | null
    action?: string | null
    path?: string | null
    method?: string | null
    ip_address?: string | null
    user_agent?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type sessionsCreateManyImpersonation_sessionsInput = {
    id?: string
    user_id: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type impersonation_session_logsUpdateWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_session_logsUncheckedUpdateWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    controller?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    path?: NullableStringFieldUpdateOperationsInput | string | null
    method?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUpdateWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsUncheckedUpdateManyWithoutImpersonation_sessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type accountsCreateManyImportsInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    plaid_account_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesCreateManyImportsInput = {
    id?: string
    account_id: string
    entryable_type?: string | null
    entryable_id?: string | null
    amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    date?: Date | string | null
    name: string
    created_at: Date | string
    updated_at: Date | string
    notes?: string | null
    excluded?: boolean | null
    plaid_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type import_rowsCreateManyImportsInput = {
    id?: string
    account?: string | null
    date?: string | null
    qty?: string | null
    ticker?: string | null
    price?: string | null
    amount?: string | null
    currency?: string | null
    name?: string | null
    category?: string | null
    tags?: string | null
    entity_type?: string | null
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
    exchange_operating_mic?: string | null
  }

  export type accountsUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    plaid_accounts?: plaid_accountsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateManyWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_account_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    accounts?: accountsUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type entriesUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type entriesUncheckedUpdateManyWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    entryable_type?: NullableStringFieldUpdateOperationsInput | string | null
    entryable_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    excluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type import_rowsUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type import_rowsUncheckedUpdateWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type import_rowsUncheckedUpdateManyWithoutImportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    account?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableStringFieldUpdateOperationsInput | string | null
    ticker?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    exchange_operating_mic?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsCreateManyMerchantsInput = {
    id?: string
    created_at: Date | string
    updated_at: Date | string
    category_id?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: string | null
    plaid_category_detailed?: string | null
  }

  export type transactionsUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    categories?: categoriesUpdateOneWithoutTransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
    rejected_transfers_rejected_transfers_outflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
    rejected_transfers_rejected_transfers_inflow_transaction_idTotransactions?: rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
    transfers_transfers_outflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsNestedInput
    transfers_transfers_inflow_transaction_idTotransactions?: transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutMerchantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    plaid_category?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_category_detailed?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tool_callsCreateManyMessagesInput = {
    id?: string
    provider_id: string
    provider_call_id?: string | null
    type: string
    function_name?: string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
  }

  export type tool_callsUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tool_callsUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tool_callsUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: StringFieldUpdateOperationsInput | string
    provider_call_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    function_name?: NullableStringFieldUpdateOperationsInput | string | null
    function_arguments?: NullableJsonNullValueInput | InputJsonValue
    function_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type accountsCreateManyPlaid_accountsInput = {
    id?: string
    subtype?: string | null
    family_id: string
    name?: string | null
    created_at: Date | string
    updated_at: Date | string
    accountable_type?: string | null
    accountable_id?: string | null
    balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    is_active?: boolean
    classification?: string | null
    import_id?: string | null
    scheduled_for_deletion?: boolean | null
    last_synced_at?: Date | string | null
    cash_balance?: Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type accountsUpdateWithoutPlaid_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    families?: familiesUpdateOneRequiredWithoutAccountsNestedInput
    imports?: importsUpdateOneWithoutAccountsNestedInput
    balances?: balancesUpdateManyWithoutAccountsNestedInput
    entries?: entriesUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateWithoutPlaid_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
    balances?: balancesUncheckedUpdateManyWithoutAccountsNestedInput
    entries?: entriesUncheckedUpdateManyWithoutAccountsNestedInput
    holdings?: holdingsUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateManyWithoutPlaid_accountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtype?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accountable_type?: NullableStringFieldUpdateOperationsInput | string | null
    accountable_id?: NullableStringFieldUpdateOperationsInput | string | null
    balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    classification?: NullableStringFieldUpdateOperationsInput | string | null
    import_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for_deletion?: NullableBoolFieldUpdateOperationsInput | boolean | null
    last_synced_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cash_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type plaid_accountsCreateManyPlaid_itemsInput = {
    id?: string
    plaid_id?: string | null
    plaid_type?: string | null
    plaid_subtype?: string | null
    current_balance?: Decimal | DecimalJsLike | number | string | null
    available_balance?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    name?: string | null
    mask?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type plaid_accountsUpdateWithoutPlaid_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateManyWithoutPlaid_accountsNestedInput
  }

  export type plaid_accountsUncheckedUpdateWithoutPlaid_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUncheckedUpdateManyWithoutPlaid_accountsNestedInput
  }

  export type plaid_accountsUncheckedUpdateManyWithoutPlaid_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    plaid_id?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_type?: NullableStringFieldUpdateOperationsInput | string | null
    plaid_subtype?: NullableStringFieldUpdateOperationsInput | string | null
    current_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    available_balance?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    mask?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_conditionsCreateManyRule_conditionsInput = {
    id?: string
    rule_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_conditionsUpdateWithoutRule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    other_rule_conditions?: rule_conditionsUpdateManyWithoutRule_conditionsNestedInput
    rules?: rulesUpdateOneWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateWithoutRule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    other_rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateManyWithoutRule_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rule_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsCreateManyRulesInput = {
    id?: string
    action_type: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_conditionsCreateManyRulesInput = {
    id?: string
    parent_id?: string | null
    condition_type: string
    operator: string
    value?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rule_actionsUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_actionsUncheckedUpdateManyWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    action_type?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rule_conditionsUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    rule_conditions?: rule_conditionsUpdateOneWithoutOther_rule_conditionsNestedInput
    other_rule_conditions?: rule_conditionsUpdateManyWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    other_rule_conditions?: rule_conditionsUncheckedUpdateManyWithoutRule_conditionsNestedInput
  }

  export type rule_conditionsUncheckedUpdateManyWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    condition_type?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type holdingsCreateManySecuritiesInput = {
    id?: string
    account_id: string
    date: Date | string
    qty: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type security_pricesCreateManySecuritiesInput = {
    id?: string
    date: Date | string
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type tradesCreateManySecuritiesInput = {
    id?: string
    qty?: Decimal | DecimalJsLike | number | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    created_at: Date | string
    updated_at: Date | string
    currency?: string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type holdingsUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: accountsUpdateOneRequiredWithoutHoldingsNestedInput
  }

  export type holdingsUncheckedUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type holdingsUncheckedUpdateManyWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    qty?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type security_pricesUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type security_pricesUncheckedUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type security_pricesUncheckedUpdateManyWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tradesUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUncheckedUpdateWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type tradesUncheckedUpdateManyWithoutSecuritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    locked_attributes?: NullableJsonNullValueInput | InputJsonValue
  }

  export type syncsCreateManySyncsInput = {
    id?: string
    syncable_type: string
    syncable_id: string
    last_ran_at?: Date | string | null
    start_date?: Date | string | null
    status?: string | null
    error?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at: Date | string
    updated_at: Date | string
    error_backtrace?: syncsCreateerror_backtraceInput | string[]
  }

  export type syncsUpdateWithoutSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    other_syncs?: syncsUpdateManyWithoutSyncsNestedInput
  }

  export type syncsUncheckedUpdateWithoutSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
    other_syncs?: syncsUncheckedUpdateManyWithoutSyncsNestedInput
  }

  export type syncsUncheckedUpdateManyWithoutSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncable_type?: StringFieldUpdateOperationsInput | string
    syncable_id?: StringFieldUpdateOperationsInput | string
    last_ran_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_backtrace?: syncsUpdateerror_backtraceInput | string[]
  }

  export type taggingsCreateManyTagsInput = {
    id?: string
    taggable_type?: string | null
    taggable_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type taggingsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taggingsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taggingsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taggable_type?: NullableStringFieldUpdateOperationsInput | string | null
    taggable_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersCreateManyTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    inflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersCreateManyTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    outflow_transaction_id: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersCreateManyTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: string
    inflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type transfersCreateManyTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: string
    outflow_transaction_id: string
    status?: string
    notes?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type rejected_transfersUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_rejected_transfers_inflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_rejected_transfers_outflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutRejected_transfers_rejected_transfers_outflow_transaction_idTotransactionsNestedInput
  }

  export type rejected_transfersUncheckedUpdateWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rejected_transfersUncheckedUpdateManyWithoutTransactions_rejected_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_transfers_inflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutTransfers_transfers_inflow_transaction_idTotransactionsNestedInput
  }

  export type transfersUncheckedUpdateWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersUncheckedUpdateManyWithoutTransactions_transfers_outflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions_transfers_outflow_transaction_idTotransactions?: transactionsUpdateOneRequiredWithoutTransfers_transfers_outflow_transaction_idTotransactionsNestedInput
  }

  export type transfersUncheckedUpdateWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transfersUncheckedUpdateManyWithoutTransactions_transfers_inflow_transaction_idTotransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outflow_transaction_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatsCreateManyUsers_chats_user_idTousersInput = {
    id?: string
    title: string
    instructions?: string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: string
    impersonated_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type impersonation_sessionsCreateManyUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: string
    impersonator_id: string
    status?: string
    created_at: Date | string
    updated_at: Date | string
  }

  export type invitationsCreateManyUsersInput = {
    id?: string
    email?: string | null
    role?: string | null
    token?: string | null
    family_id: string
    accepted_at?: Date | string | null
    expires_at?: Date | string | null
    created_at: Date | string
    updated_at: Date | string
  }

  export type sessionsCreateManyUsersInput = {
    id?: string
    user_agent?: string | null
    ip_address?: string | null
    created_at: Date | string
    updated_at: Date | string
    active_impersonator_session_id?: string | null
    subscribed_at?: Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type chatsUpdateWithoutUsers_chats_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messagesUpdateManyWithoutChatsNestedInput
    users_users_last_viewed_chat_idTochats?: usersUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutUsers_chats_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
    users_users_last_viewed_chat_idTochats?: usersUncheckedUpdateManyWithoutChats_users_last_viewed_chat_idTochatsNestedInput
  }

  export type chatsUncheckedUpdateManyWithoutUsers_chats_user_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    error?: NullableJsonNullValueInput | InputJsonValue
    latest_assistant_response_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUpdateManyWithoutImpersonation_sessionsNestedInput
    users_impersonation_sessions_impersonated_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonated_idTousersNestedInput
    sessions?: sessionsUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonator_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonated_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type impersonation_sessionsUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUpdateManyWithoutImpersonation_sessionsNestedInput
    users_impersonation_sessions_impersonator_idTousers?: usersUpdateOneRequiredWithoutImpersonation_sessions_impersonation_sessions_impersonator_idTousersNestedInput
    sessions?: sessionsUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    impersonation_session_logs?: impersonation_session_logsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutImpersonation_sessionsNestedInput
  }

  export type impersonation_sessionsUncheckedUpdateManyWithoutUsers_impersonation_sessions_impersonated_idTousersInput = {
    id?: StringFieldUpdateOperationsInput | string
    impersonator_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    families?: familiesUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type invitationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invitationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    family_id?: StringFieldUpdateOperationsInput | string
    accepted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
    impersonation_sessions?: impersonation_sessionsUpdateOneWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_impersonator_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }

  export type sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    active_impersonator_session_id?: NullableStringFieldUpdateOperationsInput | string | null
    subscribed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prev_transaction_page_params?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}